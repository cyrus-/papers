\section{Approach}
\label{s:approach}

Figure~\ref{f:dsl-if} illustrates our approach to type-based extension for the example in Figure 1.  The class \verb|ComponentArch| defines a grammar extension to the language's expression grammar. This grammar must not conflict with the fixed base expression grammar, but because it is only used when an expression of the type \verb|ComponentArch| type is requested \emph{and} a whitespace-delimited block has been introduced, there is no need to guarantee that this grammar does not interfere with other type-associated grammars. 

The declared grammar uses a standard BNF notation except for the declaration \verb|EXP of URL| on Line 7. This indicates that at this position in the grammar, a term of type \verb|URL| is needed. Thus, the domain-specific grammar (if any) associated with the \verb|URL| class may be used here. Because URLs are typically short, it may be undesirable to require a new whitespace-delimited block, so the grammar defines blocks delimited by brackets as equivalent to whitespace-delimited blocks as well, as can be seen being used in Figure 1.

\begin{figure}
  \centering\small
  \begin{lstlisting}[language=Python,morekeywords={grammar,where,ID,TYPE,EXP}]
class ComponentArch
  grammar ::= ((component|policy) \n)+ where 
    component ::= 
      ("external ")? "component " ID ":" TYPE
        [componentProperty*]?
    componentProperty ::= 
        "location "(EXP of URL)
      | "connects to" (ID ",")* ID
    ...
  \end{lstlisting}
  \caption{Type-Associated Grammar Definition}
  \label{f:dsl-if}
\end{figure}

%In this example, we first parse the if condition using a standard
%expression parser \texttt{StdExpParser}.  The expression parser is
%passed a sub-stream that contains only tokens preceding the end of
%the line.  After parsing the condition expression, we then accept an
%\texttt{INDENT} token, indicating that we are now expecting one or
%more indented lines.  This token is consumed by using a DSL for
%parsing, which is modeled after BNF syntax.  The definition of this
%parsing DSL is not shown, but it can be defined using the same approach.
%%described in this section.
%
%After that, we use a standard statement parser to parse the indented lines as
%a series of one or more statements and construct and return
%an \texttt{IfAST} object representing the if statement.  The
%\texttt{IfAST} class is an ordinary class that implements the
%\texttt{AST} interface, which requires the class to define its semantics via
%an interpreter or via translation to lower-level constructs.  The
%details of the AST interface are out of scope here.  Once the
%semantics of \keyw{if} are defined, we can use it as shown in
%the \texttt{abs} method, which computes the absolute value of its
%argument.
%
%
\paragraph{Parsing and Typechecking}
Wyvern source code is parsed using a standard whitespace-delimited lexer followed by an initial typechecking and parsing phase that occurs in tandem.  The lexer for Wyvern generates a stream of tokens structured hierarchically, where indentation (and the equivalent bracket notation) increases the depth of the stream. Indentation and de-indentation can thus be simply  understood as a special pair of tokens, \texttt{INDENT} and \texttt{DEDENT}, generated by the lexer and delimiting portions of the stream that will be handled in a special way during the next phase.

The standard Wyvern parser reads at a single level of the stream at a time. Initially, it parses the stream as a term of sort \verb|Exp|, which represents the core expressions and declaration forms of the language. This sort includes basic facilities for declaring and working with functions and variables, objects and perhaps other to-be-determined core data types. When an indented block is encountered, however, it is left in-place within the parsed syntax tree. 

When the parsing phase at a particular level is complete, it is typechecked according to a largely conventional protocol. In Wyvern, the type of a function is determined by its declaration, and cannot be affected by its use (this constraint may be relaxed in some instances in future iterations of the language). Thus, when a function is being applied, the expected types of its arguments are known. If, at a particular location where a function argument was expected, an indented block is found, then it is parsed not according to the \verb|Exp| grammar, but according to the \emph{type-associated grammar} contained in that type's definition. Figure 4 shows an example of such a grammar. That grammar may contain productions of the form $\texttt{EXP of }\tau$ where $\tau$ is another type in scope. A delimited block must be present at this location as well, and it will be parsed by the type-associated grammar of $\tau$.

A particular function application can contain only one \emph{primary} indented block. If multiple arguments support DSL syntax, then all those other than the first in the argument ordering must be invoked by a partially-indented keyword. This can be seen in Figure \ref{f:dsl-multi}. Note that this partially-indented keyword ends the first delimited block and begins a new block for the keyword argument \verb|toServer| of the function \verb|db.sendQuery|. This can be seen as similar in form to keywords in functions in Smalltalk \cite{smalltalk}.

\paragraph{Keyword-Directed Invocation}
Keyword-directed invocation of a DSL is simply a special case of this approach. In particular, a keyword can be defined as a function with a single argument of a type specific to that keyword. The type contains the implementation of the domain-specific syntax associated with that keyword. If the construction of this type is controlled such that it can only be via the domain-specific syntax (and not any equivalent syntax in the core language), then it is precisely equivalent to keyword-directed invocation of a DSL.

As keyword-directed DSL invocation is highly explicit, we allow keywords to appear not just at the end of a line, but also within expressions.  In this case, the keyword determines how much of the expression (and potentially following indented lines) that it will parse.

%Our approach supports not just key{\-}word-based extension, as in
%\keyw{if}, but also type-based syntax extensions.  Consider the
%database query DSL used in Figure~\ref{f:dsl-query}.  When parsing
%this code, the standard Wyvern parser reads the identifier
%\texttt{productDB} and discovers, based on the architecture from
%Figure~\ref{f:dsl-arch}, that \texttt{productDB} has type
%\texttt{Database}.  To support type-based syntax extension, the Wyvern
%parser examines this type, defined in Figure~\ref{f:dsl-define}, and
%discovers that the \texttt{Database} class object implements the
%\texttt{Parser} interface.  Note that we associate the parser with the
%\texttt{Database} \textit{class}, not the \texttt{Database}
%instance. This works well because the class is available at compile
%time, during parsing,
%but the instance is not available until execution.

\begin{figure}
\centering
\begin{lstlisting}
db.sendQuery
    select x where x > 10
  toServer
    www.server.org
\end{lstlisting}
\caption{Function applications involving multiple white-space delimited arguments use partially-indented keywords.}
\label{f:dsl-multi}
\end{figure}
%\begin{figure}
%  \centering
%  \begin{lstlisting}
%class Database class implements Parser
%	class meth parse(db : AST,
%	                 stream : TokStream):AST
%		if (stream ::= "where")
%			// parse where clause
%		else ... // parse other constructs
%	... // other definitions for Database
%
%// equivalent code for if using types
%class IfKeyType class implements Parser
%	class meth parse(ifKeyword : AST,
%	                 stream:ParseStream):AST
%		val cond = ... // same code as previous Figure
%	class prop instance = new IfKeyType // singleton
%val (@if@) = IfKeyType.instance
%  \end{lstlisting}
%  \caption{Type-based DSL definition}
%  \label{f:dsl-define}
%\end{figure}
%
\paragraph{Procedural Parsing}
The grammar definition in Figure 4 is declarative and relies on a simple parser generation framework included in Wyvern. It may be desirable for more sophisticated parsing algorithms to be encoded for particular domain-specific languages. For example, an interoperability layer with another full-scale programming language may wish to support parsing features not expressible in Wyvern's declarative grammar language. It can be observed, however, that a declarative grammar inside a class definition can be thought of as inducing a class method (a concept also borrowed from Smalltalk \cite{smalltalk}) called \verb|parse|, that transforms a stream of tokens to an AST representation. This interface can be exposed directly to programmers who wish to extend the parsing capabilities of the language in more sophisticated ways. We leave the details of the AST representation and its processing during later stages of compilation as future work.

