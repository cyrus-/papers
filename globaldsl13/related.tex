% !TEX root = globaldsl13.tex
\section{Related Work}
\label{s:related}
The most well-known mechanism for extending languages is macros, as exemplified by hygienic macros in Scheme. Macros in Scheme and other Lisp-style languages are written in the language itself and benefit from its simple syntax -- parentheses universally serve as expression delimiters (although proposals for whitespace as a substitute for parentheses have been made \cite{srfi-49}). Our work is inspired by this flexibility, but aims to support richer syntax as well as static types. Wyvern's use of types to trigger parsing  avoids the overhead of needing to invoke macros explicitly by name and makes it easier to compose DSLs declaratively.

%Therefore, our approach considers the readability of language extensions from the beginning: we attempt to devise the most comfortable and natural notations for the language extensions without bothersome extra keywords and try to keep it succinct.

Some language extensibility projects provide metaprogramming facilities at levels of abstraction above parsing. For instance, OJ (previously, OpenJava)
\cite{Tatsubori00openjava:a} provides a macro system based on a meta-object
protocol, and Backstage Java~\cite{Palmer:2011:BJM:2048066.2048137}, Template Haskell \cite{sheard2002template} and others employ compile-time meta-programming.  Each of these systems provide macro-style rewriting of source code, but they provide at most limited extension of language parsing.

Other systems aim at providing forms of syntax extension that change the base language, as opposed to our whitespace-delimited approach.  For example, Camlp4 \cite{camlp4} is a preprocessor for OCaml that offers the developer the ability to extend the concrete syntax of the language via the use of parsers and extensible grammars.  SugarJ \cite{Erdweg:2011:SLL:2048147.2048199} takes a library-centric approach which supports syntactic extension of the Java language by adding libraries. In Wyvern, the core language (particularly the \keyw{EXP} sort) is not extended directly, so conflicts cannot arise at link-time. 

Scoping DSLs to expressions of a single type comes at the expense of some flexibility, but we believe that many uses of DSLs are of this form already. A previous approach has considered type-based disambiguation of parse forests for supporting quotation and anti-quotation of arbitrary object languages \cite{bravenboer2005generalized}. Our work is similar in spirit, but does not rely on generation of parse forests and associates grammars with types, rather than types with grammar productions. We believe that this is a more simple and flexible methodology. The remaining approaches to syntax extension, such as XJ \cite{DBLP:conf/scam/ClarkSW08} are keyword-directed in some form. We believe that a type-directed approach is more seamless and general, sacrificing a small amount of identifiability in some cases.

Researchers have also developed DSL frameworks and language workbenches, including MPS \cite{mps}, Spoofax \cite{KatsVisser2010}, Ens\={o} \cite{enso} and others \cite{krahn2008monticore,van1992pregmatic} that provide support for generating new programming languages and tooling in a modular manner.  
%The Marco language \cite{lee:2012:marco} similarly provides macro definition at a level of abstraction that is largely independent of the target language.
Compared to these approaches, Wyvern focuses on extensibility \emph{internal} to the language, rather than taking an approach where each DSL is \emph{external} relative to the host language, improving interoperability and composability.

Finally, recent work on Active Code Completion is related to this work in that it associates code completion palettes with types \cite{omar2012active}. Such palettes could be used for defining a DSL syntax for types. However, that syntax is  immediately translated to Java syntax at edit-time while this work integrates with the core parsing facilities of the language.

%programming
%language extensions to a higher level of abstraction and creates a
%system that consumes the target language and rules for creating
%macros and produces a safe and expressive language. In contrast, our
%approach aims only at the Wyvern programming language and tries to
%enhance its extensibility.

%However, Camlp4 does not support types for the language extensions and thus is missing the additional layer of safety that our approach provides.

%While aiming for the same goal, Backstage Java  and SugarJ
% take very different approaches.   
