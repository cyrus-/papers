We thank the referees for their careful readings. 

Clarifications:

Operators in the source language are implemented in terms of a target language, as operators in any language must be. The calculus is more expressive than systems based on desugarings/rewriting, in that operators can include typing logic stronger than the internal type system and this logic cannot be weakened even with knowledge of implementation details. This is because we hold internal types (kind ITy) abstract. This is conceptually related, but fundamentally orthogonal, to ADTs/existentials which hold types (kind *) abstract. Our mechanism allows primitive operators (= not implemented in terms of other primops) that abstract over a type’s _implementation_, but where type _identity_ is observable. We believe the parallels speak to the fundamental nature of our mechanism.

Non-interference is non-trivial – we carefully consider abstracted internal terms to admit Thm3, which states that invariants maintained by a finite collection of operators (like those in Nat), even invariants an internal type cannot capture (non-negativity), need only be established locally. Once one is convinced (perhaps by extrinsic reasoning), Thm3 implies no future extensions weaken such invariants. No other extension mechanism guarantees such non-interference. We’ll include more on the proof of Thm3 (+provide the full proof in appendix) and better discuss failure modes of other mechanisms in the final version.

Thm1 implies that if compilation of an expression succeeds, the representation schema of its type is respected. By simply ignoring the identity of the representation type, we have that translation always produces well-typed internal terms. Combining with safety of the internal language immediately implies type safety -- if compilation succeeds, the program cannot “get stuck”. 

Well-kinded operators may fail to produce a translation (e.g. badnat is well-kinded). A type-level language closer to Coq than, here, ML is needed for total correctness to follow from kind checking, because proofs of representational consistency must be provided for each operator. Our work lays simply-kinded foundations for this subsequent dependently-kinded work.

Our examples are intentionally simple to serve as a guide to the formalism; we do not claim that primitive nats / tuples represent a frontier of expressiveness or that no other mechanism permits them in some form, only that a mechanism that guarantees safety permits at least these fundamental types. It is not possible to thoroughly demonstrate both expressiveness and safety within a single conference paper, but we will include a more “tricky” example -- a prototype-based object system with static dispatch -- in the final version (+discuss sums+pattern matching in the appendix). Another paper submitted to PLDI implements a AT&T with richer syntax and other enhancements and thoroughly address expressiveness. We focus on clear theoretical foundations here.

R2 is correct: we substitute open internal terms in ATT-OP. Free variables must be in \Gamma. This is fixed by indexing rules in Fig7+8 with a corresponding \Omega, used by ITERM-INTRO. 

A separate extension language would need to refer to types, and vice-versa. Both languages would have identical safety requirements. Thus, unification is sensible.

Missing citations will be added, apologies!

