We thank the referees for their careful readings. 

Clarifications:

Operators in the source language are implemented in terms of a target language, as operators in any language must be. The calculus is more expressive than systems based on desugarings/rewriting, in that operators can include typing logic stronger than the internal type system and this logic cannot be weakened even with knowledge of its implementation details. This is because we hold internal types (kind ITy) abstract. This is conceptually related to, but fundamentally orthogonal to, ADTs/existentials which hold types (kind *) abstract, allowing functions that abstract over the _identity_ of types. Our mechanism allows primitive operators (= not implemented in terms of other primops) that abstract over a type’s implementation, but where type identity is observable. We believe the similarities speak to the fundamental nature of our mechanism.

Non-interference is non-trivial – we must carefully consider abstracted internal terms to admit Thm3, which states that invariants maintained by a finite collection of operators (e.g. those in Nat), even invariants the internal type system cannot express (non-negativity), need only be established locally. Once one is convinced (perhaps by extralinguistic reasoning) that a collection of operators maintains some invariant, Thm3 implies that no future extensions can weaken it. No other extension mechanism guarantees non-interference. We will include more about the proof of Thm3 (+provide the full proof in appendix) and better discuss failure modes of related mechanisms in the final version.

Thm1 implies that if translation of a well-typed expression succeeds, the representation schema of its type is respected. One can weaken this, by ignoring the identity of the representation type, to show that translation always produces well-typed internal terms. Combining this with type safety of the internal language immediately implies type safety -- if compilation succeeds, the resulting program cannot “get stuck”. 

Well-kinded operators may fail to produce a translation (e.g. badnat is well-kinded). Moving to a type-level language closer to Coq than, here, ML is needed for total correctness to follow from kind checking, because proofs of representational consistency must be provided for each operator. Our work lays simply-kinded foundations for this subsequent work.

Our examples are intentionally simple to serve as a guide to the formalism; we do not claim that primitive natural numbers / tuples represent a frontier in expressiveness or that no other mechanism permits them in some form, only that a mechanism that guarantees safety permits at least these fundamental types. It is not possible to thoroughly demonstrate both expressiveness and safety within a single conference paper, but space-permitting, we will include a more “tricky” example -- a prototype-based object system with static dispatch -- in the final version (and include sums in the appendix as stated). Another paper, submitted to PLDI, implements a variant of this mechanism with richer syntax and other enhancements + thoroughly addresses questions of expressiveness in a practical setting. We focus on distilling the fundamentals and safety properties in this work. 

We apologize for the missing citations!
