We thank the referees for their careful and thoughtful readings. 

Clarifications:

Operators in the source language are implemented in terms of a target language, as operators in any language must be. The calculus is more expressive than systems based on desugarings (i.e. exp-to-exp rewriting), in that operators can include typing logic stronger than the internal type system and this logic cannot be weakened even given knowledge of its implementation details. 

This is because we abstract the internal type (of kind ITy). This is conceptually similar to, but fundamentally orthogonal to, abstract datatypes/existential types which abstract types (of kind *) -- type abstraction permits functions abstracting over the identity of types, while our mechanism allows primitive operator implementations (meaning not expressed in terms of previous operators) abstracting over the details of a type’s implementation, but where type identity is observable. We believe this duality speaks to the fundamental nature of our mechanism.

Non-interference is not trivial – we must carefully reason about abstracted internal terms to prove Thm3, which implies that invariants maintained by a finite collection of operators (e.g. those in Nat), even invariants the internal type system cannot express (non-negativity), must only be reasoned about locally. Once one is convinced that some  operators maintain some invariant in isolation, Thm3 implies that no future extensions can weaken this by composition. No previous work has guaranteed non-interference. We will include more details about the proof of Thm3 (+provide the full proof in appendix) and better discuss failure modes of related work in the final version.

Thm1 implies that if translation of a well-typed expression succeeds, the representation schema of its type is respected. One can weaken this, by ignoring the identity of the representation type, to show that translation always produces well-typed internal terms. Combining this with safety of the internal language then directly implies type safety -- if compilation succeeds, the resulting program cannot “get stuck”. 

Well-kinded operators may fail to produce a translation (e.g. calls to badnat.? are well-kinded but rejected). Moving to a type-level language more similar to Coq than ML is needed for total correctness to follow from kind checking, because proofs of representational consistency must be provided for each operator. Both points in the design space are interesting; our work lays the foundation for this subsequent work.

Our examples are intentionally simple to serve as a guide to the formalism; we do not claim that primitive natural numbers / tuples represent a frontier in expressiveness or that no other mechanism permits them in some form. It is not possible to thoroughly demonstrate both expressiveness and safety within a single conference paper. But space-permitting, we will discuss a more “tricky” example of a static prototype-based object system in the final version (and include sums in the appendix). A paper submitted to PLDI implements a variant of this mechanism with richer syntax and other enhancements to more thoroughly consider issues of expressiveness in a practical setting. We wish to focus on distilling the foundations and safety properties in this work. 
