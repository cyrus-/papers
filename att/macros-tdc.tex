\newcommand{\lamTDC}{\lambda_{\text{TDC}}}
\newcommand{\cloquence}{\textsf{cl.oquence}}

% lamTDC macros
\newcommand{\fnt}[2]{#1\rightarrow#2}
\newcommand{\parsetree}{\Pi}
\newcommand{\pipe}{~|~}
\newcommand{\intlit}{\bar{n}}
\newcommand{\kfn}[3]{\lambda#1\sim#2~.~#3}
\newcommand{\kap}[2]{#1~#2}
\newcommand{\visit}[4]{{\sf visit}\,#1\,{\sf is}\,#2,\,#3,\,#4}
\newcommand{\tauadd}{\tau_{{\sf \diamond}}}
\newcommand{\taunew}{\tau_{{\sf new}}}
\newcommand{\tauaddt}{\tauadd^{\star}}
\newcommand{\taunewt}{\taunew^{{\surd}}}
\newcommand{\tauaddg}{\tauadd^\gamma}
\newcommand{\taunewg}{\taunew^\gamma}
\newcommand{\typedef}[7]{{\sf type}\langle#5\rangle\{#2; #3, #4\}}
\newcommand{\deltamap}{\delta_{{\sf rep}}}
\newcommand{\deltaL}{\delta_L}
\newcommand{\deltaR}{\delta_R}
\newcommand{\deltanew}{\delta_{{\sf new}}}
\newcommand{\typedefstd}{\typedef{\deltanew}{\taunewg}{\tauaddt}{\tauaddg}{\deltamap}{\deltaL}{\deltaR}}
\newcommand{\typedefT}{\textit{type}}
\newcommand{\efn}[3]{\lambda#1{:}#2.#3}
\newcommand{\eap}[2]{#1\ #2}
\newcommand{\tcode}{\mathcal{I}}
\newcommand{\klet}[3]{{\sf let}\,#1=#2\,{\sf in}\,#3}
\newcommand{\kparse}[1]{\pi[#1]}
\newcommand{\kvisit}[4]{{\sf visit}\,#1\,{\sf with}\,#2,#4,#3}
\newcommand{\kvisitstd}{\kvisit{\taupi}{\tau_{\#}}{\tauadd}{\taunew}}
\newcommand{\typeof}[1]{{\sf typeof}(#1)}
\newcommand{\typeofT}{\textit{typeof}}
\newcommand{\ifeq}[3]{{\sf if}~#1~{\sf then}~#2~{\sf else}~#3}
\newcommand{\err}{{\tt err}}
\newcommand{\contexts}{\mathcal{K}}
\newcommand{\xentails}[1]{\entails{\contexts}{#1}}
\newcommand{\intro}{\text{-I}}
\newcommand{\elim}{\text{-E}}
\newcommand{\newobj}[2]{#1(#2)}
\newcommand{\sfype}[1]{\langle#1\rangle}
\newcommand{\intt}{{\sf int}}
\newcommand{\tkind}{\star}
\newcommand{\translate}[2]{{\sf translate}(#2) \Rightarrow \sfype{#1}}
\newcommand{\nocode}{\textit{n/a}}
\newcommand{\bool}{{\sf bool}}
\newcommand{\tauL}{\tau_L}
\newcommand{\tauR}{\tau_R}
\newcommand{\optree}[2]{{\sf \Diamond}(#1, #2)}
\newcommand{\optreestd}{\optree{\tauL}{\tauR}}
\newcommand{\newtree}[2]{{\sf new}(#1, #2)}
\newcommand{\tautype}{\tau_{\star}}
\newcommand{\tauarg}{\tau_{\pi}}
\newcommand{\newtreestd}{\newtree{\tautype}{\tauarg}}
\newcommand{\numtree}[1]{{\sf \#}(#1)}
\newcommand{\taunum}{\tau_{n}}
\newcommand{\numtreestd}{\numtree{\taunum}}
\newcommand{\source}[1]{{\sf program}(#1)}
\newcommand{\tparse}[1]{\Gamma[#1]}
\newcommand{\tadd}[2]{\Gamma_{+}(#1, #2)}
\newcommand{\sfimes}[2]{\Gamma_{\times}(#1, #2)}
\newcommand{\absop}[2]{#1 \diamond #2}
\newcommand{\earg}{e_{{\sf arg}}}
\newcommand{\parses}[2]{#1 \hookrightarrow #2}
\newcommand{\sourcet}{\square}
\newcommand{\fault}{{\tt fault}}
\newcommand{\gnew}{{\sf g_{new}}}
\newcommand{\gop}{{\sf g_\diamond}}
\newcommand{\gammafst}[1]{\Gamma_{{\sf fst}}(#1)}
\newcommand{\gammasnd}[1]{\Gamma_{{\sf snd}}(#1)}
\newcommand{\fst}[1]{{\sf fst}(#1)}
\newcommand{\snd}[1]{{\sf snd}(#1)}
\newcommand{\valid}[1]{#1~{\tt valid}}
\newcommand{\num}{\bf{num}}
\newcommand{\gram}{\text{{\it gram}}}
\newcommand{\kelvin}{\text{{\it meter}}}
\newcommand{\taupi}{\tau_{\pi}}

\newcommand{\kinds}{\fnt{\kappa_{1}}{\kappa_{2}} \pipe \tkind \pipe \sfype{\delta} \pipe \parsetree \pipe  \sourcet}
\newcommand{\metaterms}{x \pipe \kfn{x}{\kappa}{\tau'} \pipe \kap{\tau_{1}}{\tau_{2}} \pipe \klet{x}{\tau_0}{\tau_1} \pipe \\
  &  & \ifeq{\tau_0 = \tau_1}{\tau_\true}{\tau_\false} \pipe \\
  &  & \typedefstd \pipe \err \pipe \\
 &  & \Gamma[\gamma] \pipe \Gamma_{+}(\tauL, \tauR) \pipe \Gamma_{\times}(\tauL, \tauR) \pipe \gammafst{\tau_\times} \pipe \gammasnd{\tau_\times} \pipe\\
 &  & \numtreestd \pipe \newtreestd \pipe \optreestd \pipe \\
 &  & \kvisit{\tau_{\pi}}{\tau_{\#}}{\tauadd}{\taunew} \pipe \source{e}}
\newcommand{\sourcegrammar}{\intlit \pipe \newobj{\tau}{e_0} \pipe \absop{e_{1}}{e_{2}}}
\newcommand{\datatypes}{\intt \pipe \delta \times \delta \pipe \otimes}
\newcommand{\ilgrammar}{\intlit \pipe \gamma_L + \gamma_R \pipe (\gamma_L, \gamma_R) \pipe \fst{\gamma} \pipe \snd{\gamma} \pipe  \fault}

\newcommand{\compile}[3]{#1 \stackrel{#2}{\Longrightarrow} #3}

% Statics
\newcommand{\ctx}{\mathcal{K}}

\newcommand{\varN}{(\text{var})}
\newcommand{\varF}{\inferrule{x \sim \kappa \in \ctx}{
	\entails{\mathcal{K}}{x\sim\kappa}
}}
\newcommand{\varT}{\varF\varN}

\newcommand{\kfnIN}{(\lambda \intro)}
\newcommand{\kfnIF}{\inferrule{
	\entails{\mathcal{K} \uplus x \sim \kappa_1}{\tau' \sim \kappa_2}
}{
	\xentails{\kfn{x}{\kappa_1}{\tau'} \sim \kappa_1 \rightarrow \kappa_2}
}}
\newcommand{\kfnIT}{\kfnIF\kfnIN}

\newcommand{\kfnEN}{(\lambda \elim)}
\newcommand{\kfnEF}{\inferrule{
	\xentails{\tau_1 \sim \kappa_1 \rightarrow \kappa_2}\\
	\xentails{\tau_2 \sim \kappa_2}
}{
	\xentails{\tau_1~\tau_2 \sim \kappa_2}
}}
\newcommand{\kfnET}{\kfnEF\kfnEN}

\newcommand{\letN}{(\text{let})}
\newcommand{\letF}{\inferrule{
	\xentails{\tau_0 \sim \kappa_0}\\
	\entails{\mathcal{K} \uplus x \sim \kappa_0}{\tau_1 \sim \kappa_1}
}{
	\xentails{\klet{x}{\tau_0}{\tau_1}\sim\kappa_1}
}}
\newcommand{\letT}{\letF\letN}

\newcommand{\ifN}{\text{(if)}}
\newcommand{\ifF}{\inferrule{
	\xentails{\tau_0 \sim \kappa_0}~~~~
	\xentails{\tau_1 \sim \kappa_0}~~~~
	\xentails{\tau_\true \sim \kappa}~~~~
	\xentails{\tau_\false \sim \kappa}
}{
	\xentails{\ifeq{\tau_0 = \tau_1}{\tau_\true}{\tau_\false} \sim \kappa}
}}
\newcommand{\ifT}{\ifF\ifN}

\newcommand{\typeN}{\text{(type)}}
\newcommand{\typeF}{\inferrule{
	\xentails{\taunewg \sim \sfype{\deltanew} \rightarrow \sfype{\deltamap}}\\
	\xentails{\tauaddt \sim \star \rightarrow \star \rightarrow \parsetree \rightarrow \parsetree \rightarrow \tkind}~~~~\\
	\xentails{\tauaddg \sim\sfype{\deltaL} \rightarrow \sfype{\deltaR} \rightarrow \sfype{\deltamap}}
}{
	\xentails{\typedefstd \sim \tkind}
}}
\newcommand{\typeT}{\typeF\typeN}

\newcommand{\errN}{\text{(err)}}
\newcommand{\errF}{\inferrule{ }{
	\xentails{\err\sim\tkind}
}}
\newcommand{\errT}{\errF\errN}


\newcommand{\ilrepN}{(\gamma\intro)}
\newcommand{\ilrepF}{\inferrule{
	\gamma :: \delta
}{\xentails{\Gamma[\gamma] \sim \sfype{\delta}}}}
\newcommand{\ilrepT}{\ilrepF\ilrepN}

\newcommand{\iladdN}{(\tau\text{-add})}
\newcommand{\iladdF}{\inferrule{
	\xentails{\tau_L \sim \sfype{\intt}}\\
	\xentails{\tau_R \sim \sfype{\intt}}
}{\xentails{\Gamma_{+}(\tau_L, \tau_R) \sim \sfype{\intt}}}}
\newcommand{\iladdT}{\iladdF\iladdN}

\newcommand{\iltupleN}{(\tau\text{-tuple})}
\newcommand{\iltupleF}{\inferrule{
	\xentails{\tau_L \sim \sfype{\delta_L}}\\
	\xentails{\tau_R \sim \sfype{\delta_R}}\\
	\delta_L, \delta_R \neq \otimes\\
}{\xentails{\Gamma_{\times}(\tau_L, \tau_R) \sim \sfype{\delta_L \times \delta_R}}}}
\newcommand{\iltupleT}{\iltupleF\iltupleN}

\newcommand{\ilfstN}{(\tau\text{-fst})}
\newcommand{\ilfstF}{\inferrule{
	\xentails{\tau_\times \sim \sfype{\delta_L \times \delta_R}}
}{\xentails{\gammafst{\tau_\times} \sim \sfype{\delta_L}}}}
\newcommand{\ilfstT}{\ilfstF\ilfstN}

\newcommand{\ilsndN}{(\tau\text{-snd})}
\newcommand{\ilsndF}{\inferrule{
	\xentails{\tau_\times \sim \sfype{\delta_L \times \delta_R}}
}{
	\xentails{\gammasnd{\tau_\times} \sim \sfype{\delta_R}}
}}
\newcommand{\ilsndT}{\ilsndF\ilsndN}


\newcommand{\intN}{{int}}

\newcommand{\intlitN}{\text{(\intN-lit)}}
\newcommand{\intlitF}{\inferrule{ }{\intlit :: \intt}}
\newcommand{\intlitT}{\intlitF\intlitN}

\newcommand{\addN}{\text{(\intN-add)}}
\newcommand{\addF}{\inferrule{\gamma_L :: \intt\\
\gamma_R :: \intt\\
}{\gamma_L + \gamma_R :: \intt}}
\newcommand{\addT}{\addF\addN}

\newcommand{\fstN}{\text{(fst)}}
\newcommand{\fstF}{\inferrule{
	\gamma :: \delta_L \times \delta_R
}{
	\fst{\gamma} :: \delta_L
}}
\newcommand{\fstT}{\fstF\fstN}

\newcommand{\sndN}{\text{(snd)}}
\newcommand{\sndF}{\inferrule{
	\gamma :: \delta_L \times \delta_R
}{
	\snd{\gamma} :: \delta_R
}}
\newcommand{\sndT}{\sndF\sndN}

\newcommand{\tupleN}{\text{(tuple)}}
\newcommand{\tupleF}{\inferrule{\gamma_L :: \delta_L\\
\gamma_R :: \delta_R\\
\delta_L, \delta_R \neq \otimes\\
}{(\gamma_L, \gamma_R) :: \delta_L \times \delta_R}}
\newcommand{\tupleT}{\tupleF\tupleN}

\newcommand{\faultN}{\text{(fault)}}
\newcommand{\faultF}{\inferrule{ }{\fault :: \otimes}}
\newcommand{\faultT}{\faultF\faultN}


\newcommand{\numtreePN}{\text{(num-$\pi$)}}
\newcommand{\numtreePF}{\inferrule{ }{
	\parses{\intlit}{\numtree{\tparse{\intlit}}}
}}
\newcommand{\numtreePT}{\numtreePF\numtreePN}

\newcommand{\numtreeN}{\text{(num)}}
\newcommand{\numtreeF}{\inferrule{\xentails{\tau_0 \sim \sfype{\intt}}}{\xentails{\numtree{\tau_0}\sim\parsetree}}}
\newcommand{\numtreeT}{\numtreeF\numtreeN}

\newcommand{\newtreePN}{\text{(new-$\pi$)}}
\newcommand{\newtreePF}{\inferrule{
	\parses{e}{\tau_e}
}{
	\parses{\newobj{\tau}{e}}{\newtree{\tau}{\tau_e}}
}}
\newcommand{\newtreePT}{\newtreePF\newtreePN}

\newcommand{\newtreeN}{\text{(new)}}
\newcommand{\newtreeF}{\inferrule{
	\xentails{\tau \sim \star \rightarrow \parsetree \rightarrow \star}\\
	\xentails{\tau_e \sim \parsetree}
}{
	\xentails{\newtree{\tau}{\tau_e} \sim \parsetree}
}}
\newcommand{\newtreeT}{\newtreeF\newtreeN}

\newcommand{\optreePN}{\text{(op-$\pi$)}}
\newcommand{\optreePF}{\inferrule{
	\parses{e_L}{\tauL}\\
	\parses{e_R}{\tauR}
}{
	\parses{\absop{e_L}{e_R}}{\optreestd}
}}
\newcommand{\optreePT}{\optreePF\optreePN}

\newcommand{\optreeN}{\text{(op)}}
\newcommand{\optreeF}{\inferrule{
	\xentails{\tauL \sim \parsetree}\\
	\xentails{\tauR \sim \parsetree}
}{
	\xentails{\optreestd \sim \parsetree}
}}
\newcommand{\optreeT}{\optreeF\optreeN}

\newcommand{\visitN}{\text{(visit)}}
\newcommand{\visitF}{\inferrule{\xentails{\taupi \sim \parsetree}\\
\xentails{\tau_{\#} \sim \sfype{\intt} \rightarrow \kappa}\\
\xentails{\taunew \sim \parsetree \rightarrow \kappa}\\
\xentails{\tauadd \sim \parsetree \rightarrow \parsetree \rightarrow \kappa}
}{
\xentails{\kvisit{\tau_{\pi}}{\tau_{\#}}{\tauadd}{\taunew} \sim \kappa}
}}
\newcommand{\visitT}{\visitF\visitN}

\newcommand{\sourcetN}{\text{(program)}}
\newcommand{\sourcetF}{\inferrule{
	\parses{e}{\tau_\pi}\\
	\xentails{\tau_\pi \sim\parsetree}
}{
	\xentails{\source{e} \sim \sourcet}
}}
\newcommand{\sourcetT}{\sourcetF\sourcetN}
