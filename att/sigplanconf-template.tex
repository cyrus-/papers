%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}

\begin{document}

\conferenceinfo{WXYZ '05}{date, City.} 
\copyrightyear{2005} 
\copyrightdata{[to be supplied]} 

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Type-Determined Compilation Supports Fine-Grained Composition of Language Features}
\subtitle{Removing the Barriers to Adoption of Programming Language Research}

\authorinfo{Cyrus Omar}
           {Computer Science Department\\
           Carnegie Mellon University}
           {cyrus@cmu.edu}
\authorinfo{Jonathan Aldrich}
           {Institute for Software Research\\
           Carnegie Mellon University}
           {jonathan.aldrich@cs.cmu.edu}

\maketitle

\begin{abstract}
Both general-purpose and domain-specific programming languages are commonly distributed as monolithic collections of syntactic and semantic rules useful for a particular set of tasks. However, domain experts and programming language designers typically think in terms of fine-grained composition of "language features", some of which may require compiler support to operate correctly. To support extensible compilation at the language level, we describe a framework which requires type definitions, written in a general purpose definition language, to determine their own data layout, static type checking rules, type inference rules and syntactic transformations for each operation which they support. Because these behaviors are associated with types rather than monolithic language definitions or compiler implementations, they can be composed more easily. We demonstrate how existing language designs -- a polymorphic extension of the statically-typed imperative language OpenCL (based on C99), and example dynamically typed and functional languages -- can be naturally implemented, extended with domain-specific constructs, and interoperate within this framework, without a loss of run-time performance. We also demonstrate that such a system naturally supports staged compilation.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

A programming language today is a monolithic collection of preferred rules and abstractions, along with a compiler or interpreter to verify and execute programs written using these abstractions. When programming language researchers or domain experts discover new features that may improve the expressiveness, performance, security or correctness of programs, they often turn to tools which allow them to write a new language\cite{abc}. This proliferation of distinct programming languages forces programmers to choose between production-quality languages lacking useful abstractions and prototype languages which may nevertheless offer a small number of useful features or guarantees about performance, security or correctness. Overwhelmingly, programmers have favored mature languages at the expense of these considerations. While useful abstractions occasionally are incorporated into mature languages, this happens slowly and at the whims of the language designers. This hinders the translation and evaluation of innovations in  programming languages research, and prevents domain experts from being able to easily incorporate domain-specific logic into their programming languages, particularly at compile-time and in a performant manner.



\section{System Design}
\subsection{Polymorphism and Type Inference}

\subsection{Type Definitions}

\subsection{Control of Data Layout}

\subsection{Custom Type Checking and Type Inference Rules}

\subsection{Syntactic Transformations and Macros}

\section{Language Implementations}
\subsection{Polymorphic OpenCL}

\subsubsection{Higher Order Functions}

\subsubsection{Performance}

\subsection{Dynamic Languages}

\subsection{Functional Languages}

\section{Domain-Specific Extensions}
\subsection{Scientific Unit Checks}
\subsection{HTML Structure Checking}
\section{Related Work}
\section{Discussion}
%\appendix
%\section{Appendix Title}
%
%This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{research}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}

\end{document}
