%\documentclass[12pt]{article}
\documentclass[10pt,preprint]{sigplanconf}
% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.
\usepackage{amsmath}
\usepackage{amssymb} 
\usepackage{amsthm}
\usepackage{ stmaryrd }
\usepackage{mathpartir}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

\input{macros-catlam}

\usepackage{times}
\renewcommand{\ttdefault}{txtt}
\usepackage{alltt}
\usepackage{listings}
\lstset{language=ML,
showstringspaces=false,
basicstyle=\ttfamily\footnotesize,
morekeywords={newcase,extends}}

\usepackage{url}
\usepackage{todonotes}
\lefthyphenmin=5
\sloppy

\newcommand{\moutput}{^{\color{gray}+}}
\newcommand{\rulename}[1]{(#1)}
\def \TirNameStyle #1{\small\rulename{#1}}
\renewcommand{\MathparLineskip}{\lineskiplimit=.6\baselineskip\lineskip=.6\baselineskip plus .2\baselineskip}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\newtheorem{tyconinvariant}{Tycon Invariant}
\newenvironment{proof-sketch}{\noindent{\emph{Proof Sketch.}}}{\qed}
\makeatletter

% Heather-added packages for the fancy table
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{pdflscape}
\usepackage{colortbl}%
\newcommand{\myrowcolour}{\rowcolor[gray]{0.925}}
\usepackage{wasysym}

\renewcommand\topfraction{0.85}
\renewcommand\bottomfraction{0.85}
\renewcommand\textfraction{0.1}
\renewcommand\floatpagefraction{0.85}

\begin{document}

\conferenceinfo{-}{-} 
\copyrightyear{-} 
\copyrightdata{[to be supplied]} 

%\titlebanner{{\tt \textcolor{Red}{{\small Under Review -- distribute within CMU only.}}}}        % These are ignored unless
%\preprintfooter{Distribute within CMU only.}   % 'preprint' option specified.

\title{Modularly Composing Typed Language Fragments}
\subtitle{Supplemental Material}
\authorinfo{}{}{}
%\authorinfo{Cyrus Omar \and Jonathan Aldrich}
 %         {Carnegie Mellon University}
  %         {\{comar, aldrich\}@cs.cmu.edu}   

\maketitle

%\category{D.3.2}{Programming Languages}{Language Classifications}[Extensible Languages]
%\category{D.3.4}{Programming Languages}{Processors}[Compilers]
%\category{F.3.1}{Logics \& Meanings of Programs}{Specifying and Verifying and Reasoning about Programs}[Specification Techniques]
%\keywords
%extensible languages; module systems; type abstraction; typed compilation; type-level computation

\section{Internal Language}
\todo{copy from one of the 312 HWs}

\subsection{Substitutions}

\subsection{Abstraction Theorem}
\todo{hm...}

\section{Tycon Contexts}
\subsection{Tycon Context Well-Definedness}

\subsection{Equality Kinds}
Need an equational theory for SL to state equality kind property, but not important for other metatheory. 

\subsection{Full Examples}

\section{Static Language}
\subsection{Kind Formation}

\subsection{Kinding Context Formation}

\subsection{Kinding}

\subsection{Dynamic Semantics}

\subsection{Kind Safety}

\section{Types}
\subsection{Type Translations}

\subsection{Typing Context Translations}

\paragraph{Unicity}
The rules are structured so that if a term is well-typed, both its type and translation are unique.\todo{could move this whole thing to supplement if room needed}
\begin{theorem}[Unicity]
If $\vdash \Phi$ and $\vdash_\Phi \Upsilon \leadsto \Gamma$ and $\vdash_\Phi \st \leadsto \tau$ and $\vdash_\Phi \st' \leadsto \tau'$ and $\eanaX{e}{\st}{\iota}$ and $\eanaX{e}{\st'}{\iota'}$ then $\st = \st'$ and $\tau=\tau'$ and $\iota = \iota'$.
\end{theorem}

\section{External Language}
\subsection{Additional Desugarings}
\subsection{Typing}
\subsection{Proof of Regular String Soundness Tycon Invariant}


\newpage
% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrv}

% The bibliography should be embedded for final submission.

\bibliography{../research}
%\softraggedright
%P. Q. Smith, and X. Y. Jones. ...reference text...

\newpage
\appendix
\section{Appendix}
\begin{mathpar}
\small
\inferrule[s-ty-step]{
    \sstep{\st}{\argEnv}{\st'}
}{
    \sstep{\sty{c}{\st}}{\argEnv}{\sty{c}{\st'}}
}

\inferrule[s-ty-err]{
    \serr{\st}{\argEnv}
}{
    \serr{\sty{c}{\st}}{\argEnv}
}

\inferrule[s-ty-v]{
    \sval{\st}{\argEnv}
}{
    \sval{\sty{c}{\st}}{\argEnv}
}

\inferrule[s-otherty-v]{ }{
    \sval{\sotherty{m}{\tau}}{\argEnv}
}
\end{mathpar}

\begin{mathpar}
\small
\inferrule[s-tycase-step]{
    \sstep{\st}{\argEnv}{\st'}
}{
    \sstep{\stycase{c}{\st}{\sx}{\st_1}{\st_2}}{\argEnv}{\stycase{c}{\st'}{x}{\st_1}{\st_2}}
}

\inferrule[s-tycase-err]{
    \serr{\st}{\argEnv}
}{
    \serr{\stycase{c}{\st}{\sx}{\st_1}{\st_2}}{\argEnv}
}
\end{mathpar}
\begin{mathpar}\small
\inferrule[s-tycase-match]{
    \sval{\sty{c}{\st}}{\argEnv}
}{
    \sstep{\stycase{c}{\sty{c}{\st}}{\sx}{\st_1}{\st_2}}{\argEnv}{[\st/x]\st_1}
}

\inferrule[s-tycase-fail]{
    \st \neq \sty{c}{\st'}
}{
    \sstep{\stycase{c}{\st}{\sx}{\st_1}{\st_2}}{\argEnv}{\st_2}
}
\end{mathpar}
\begin{mathpar}
\small
\inferrule[keq-k]{\kvar \in \kDelta}{\keq{\kDelta}{\kvar}}

\inferrule[keq-ind]{\keq{\kDelta, \kvar}{\kappa}}{
  \keq{\kDelta}{\kmu{\kvar}{\kappa}}}

\inferrule[keq-unit]{ }{\keq{\kDelta}{\kunit}}
\end{mathpar}\begin{mathpar}
\small
\inferrule[keq-prod]{
  \keq{\kDelta}{\kappa_1}~~~~
  \keq{\kDelta}{\kappa_2}
}{
  \keq{\kDelta}{\kprod{\kappa_1}{\kappa_2}}
}

\inferrule[keq-sum]{
  \keq{\kDelta}{\kappa_1}~~~~
  \keq{\kDelta}{\kappa_2}
}{
  \keq{\kDelta}{\ksum{\kappa_1}{\kappa_2}}
}

\inferrule[keq-ty]{ }{\keq{\kDelta}{\kty}}
\end{mathpar}
 %We will discuss strategies for fragments that benefit from more sophisticated equivalences in Section \ref{examples}.\todo{do this}

\begin{mathpar}

\inferrule[k-ity-alpha]{ }{\sofkX{\sqity{\alpha}}{\kity}}
\end{mathpar}

\begin{mathpar}
\small
\inferrule[s-ity-lam-step-1]{
    \sstep{\sqity{\qity_1}}{\argEnv}{\sqity{\qity_1'}}%\sstep{\sqity{\qity_1}}{\argEnv}{\sstep{\sqity{\qity_1'}}}
}{
    \sstep{\sqity{\qity_1\times\qity_2}}{\argEnv}{\sqity{\qity_1' \times \qity_2}}
}

\inferrule[s-ity-lam-step-2]{
    \sval{\sqity{\qity_1}}{\argEnv}\\
    \sstep{\sqity{\qity_2}}{\argEnv}{\sqity{\qity_2'}}%\sstep{\sqity{\qity_1}}{\argEnv}{\sstep{\sqity{\qity_1'}}}
}{
    \sstep{\sqity{\qity_1\times\qity_2}}{\argEnv}{\sqity{\qity_1 \times \qity_2'}}
}

\inferrule[s-ity-lam-err-1]{
    \serr{\sqity{\qity_1}}{\argEnv}
}{
    \serr{\sqity{\qity_1\times\qity_2}}{\argEnv}
}

\inferrule[s-ity-lam-err-2]{
    \serr{\sqity{\qity_2}}{\argEnv}
}{
    \serr{\sqity{\qity_1\times\qity_2}}{\argEnv}
}

\inferrule[s-ity-lam-v]{
    \sval{\sqity{\qity_1}}{\argEnv}\\
    \sval{\sqity{\qity_2}}{\argEnv}
}{
    \sval{\sqity{\qity_1\times\qity_2}}{\argEnv}
}

\inferrule[s-ity-alpha-v]{ }{
    \sval{\sqity{\alpha}}{\argEnv}
}
\end{mathpar}
\begin{mathpar}
\small
\inferrule[k-tycase-parr]{
    \sofkX{\st}{\kty}\\
    \sofk{\kDelta}{\kGamma, \sx :: \kty \times \kty}{\Phi}{\st_1}{\kappa}\\
    \sofkX{\st_2}{\kappa}
}{
    \sofkX{\stycase{\rightharpoonup}{\st}{\sx}{\st_1}{\st_2}}{\kappa}
}
\end{mathpar}
\begin{mathpar}
\small
\inferrule[s-ity-unquote-step]{
    \sstep{\st}{\argEnv}{\st'}
}{
    \sstep{\sqity{\qtuq{\st}}}{\argEnv}{\sqity{\qtuq{\st'}}}
}

\inferrule[s-ity-unquote-err]{
    \serr{\st}{\argEnv}
}{
    \serr{\sqity{\qtuq{\st}}}{\argEnv}
}
\end{mathpar}
\begin{mathpar}
\inferrule[s-ity-trans-step]{
    \sstep{\st}{\argEnv}{\st'}
}{
    \sstep{\sqity{\srep{\st}}}{\argEnv}{\sqity{\srep{\st'}}}
}

\inferrule[s-ity-trans-err]{
    \serr{\st}{\argEnv}
}{
    \serr{\sqity{\srep{\st}}}{\argEnv}
}
\end{mathpar}
This judgement is defined by the following straightforward rules:
\begin{mathpar}\small
\inferrule[tstore-emp]{ }{\emptyset \leadsto \emptyset : \emptyset}

\inferrule[tstore-ext]{\memD \leadsto \delta : \Delta}{(\memD, \st \leftrightarrow \tau/\alpha) \leadsto (\delta, \tau/\alpha) : (\Delta, \alpha)}
\end{mathpar}

\[\small
\begin{array}{lll}
\textbf{Description} ~~~~& \textbf{Concrete Form}~~~~ & \textbf{Desugared Form}\\
\text{sequences} & (e_1, \ldots, e_n) ~\text{or}~ \texttt{[}e_1, \ldots, e_n\texttt{]} & \eintro{()}{e_1; \ldots; e_n}\\
\text{labeled sequences} & \{\mathtt{lbl}_1=e_1, \ldots, \mathtt{lbl}_n=e_n\} & \eintro{\texttt{[}\mathtt{lbl}_1, \ldots, \mathtt{lbl}_n\texttt{]}}{e_1; \ldots; e_n}\\
\text{label application} & \mathtt{lbl}\langle e_1, \ldots, e_n \rangle & \eintro{\mathtt{lbl}}{e_1, \ldots, e_n}\\
\text{numerals} & n & \eintro{n}{\cdot}\\
\text{labeled numerals} & n\texttt{lbl} & \eintro{(n, \texttt{lbl})}{\cdot}\\
\text{strings} & \texttt{"s"} & \eintro{\texttt{"s"}}{\cdot}
\end{array}
\]

\begin{mathpar}\small
\inferrule[s-itm-var-v]{ }{
    \sval{\sqitm{x}}{\argEnv}
}

\inferrule[s-itm-lam-step-1]{
    \sstep{\sqity{\qity}}{\argEnv}{\sqity{\qity'}}
}{
    \sstep{\sqitm{\ilam{\qity}{x}{\qitm}}}{\argEnv}{\sqitm{\ilam{\qity'}{x}{\qitm}}}
}

\inferrule[s-itm-lam-step-2]{
    \sval{\sqity{\qity}}{\argEnv}\\
    \sstep{\sqitm{\qitm}}{\argEnv}{\sqitm{\qitm'}}
}{
    \sstep{\sqitm{\ilam{\qity}{x}{\qitm}}}{\argEnv}{\sqitm{\ilam{\qity}{x}{\qitm'}}}
}
\end{mathpar}
\begin{mathpar}\small
\inferrule[s-itm-lam-err-1]{
    \serr{\sqity{\qity}}{\argEnv}
}{
    \serr{\sqitm{\ilam{\qity}{x}{\qitm}}}{\argEnv}
}

\inferrule[s-itm-lam-err-2]{
    \serr{\sqitm{\qitm}}{\argEnv}
}{
    \serr{\sqitm{\ilam{\qity}{x}{\qitm}}}{\argEnv}
}

\inferrule[s-itm-lam-v]{
    \sval{\sqity{\qity}}{\argEnv}\\
    \sval{\sqitm{\qitm}}{\argEnv}
}{
    \sval{\sqitm{\ilam{\qity}{x}{\qitm}}}{\argEnv}
}
\end{mathpar}
\begin{mathpar}\small
\inferrule[k-itm-unquote]{
    \sofkX{\st}{\kitm}
}{
    \sofkX{\sqitm{\quq{\st}}}{\kitm}
}
\end{mathpar}

\begin{mathpar}\small
\inferrule[s-itm-unquote-step]{
    \sstep{\st}{\argEnv}{\st'}
}{
    \sstep{\sqitm{\quq{\st}}}{\argEnv}{\sqitm{\quq{\st'}}}
}

\inferrule[s-itm-unquote-err]{
    \serr{\st}{\argEnv}
}{
    \serr{\sqitm{\quq{\st}}}{\argEnv}
}

\inferrule[s-itm-unquote-elim]{
    \sval{\sqitm{\qitm}}{\argEnv}
}{
    \sstep{\sqitm{\quq{\sqitm{\qitm}}}}{\argEnv}{\sqitm{\qitm}}
}
\end{mathpar}
\begin{mathpar}
\inferrule[s-ana-step]{
    \sstep{\st}{\argEnv}{\st'}
}{
    \sstep{\sana{n}{\st}}{\argEnv}{\sana{n}{\st'}}
}

\inferrule[s-ana-err]{
    \serr{\st}{\argEnv}
}{
    \serr{\sana{n}{\st}}{\argEnv}
}

\inferrule[s-itm-anatrans-step]{
    \sstep{\st}{\argEnv}{\st'}
}{
    \sstep{\sqitm{\anatrans{n}{\st}}}{\argEnv}{\sqitm{\anatrans{n}{\st'}}}
}

\inferrule[s-itm-anatrans-err]{
    \serr{\st}{\argEnv}
}{
    \serr{\sqitm{\anatrans{n}{\st}}}{\argEnv}
}
\end{mathpar}
, as specified by the judgement $\memG \leadsto \gamma : \Gamma$ defined by the following rules:
\begin{mathpar}
\inferrule[ttrs-emp]{ }{\emptyset \leadsto \emptyset : \emptyset}

\inferrule[ttrs-ext]{
    \memG \leadsto \gamma : \Gamma
}{
    (\memG, n : \st \leadsto \iota/x : \tau) \leadsto (\gamma, \iota/x) : (\Gamma, x : \tau)
}
\end{mathpar}


\begin{mathpar}\small
\inferrule[k-itm-lam]{
    \sofkX{\sqity{\qity}}{\kity}\\
    \sofkX{\sqitm{\qitm}}{\kitm}
}{
    \sofkX{\sqitm{\ilam{\qity}{x}{\qitm}}}{\kitm}
}
\end{mathpar} 
\begin{mathpar}\small
\inferrule[k-raise]{\kDelta \vdash \kappa}{\sofkX{\sraise{\kappa}}{\kappa}}

\inferrule[s-raise]{ }{\serr{\sraise{\kappa}}{\argEnv}}
\end{mathpar}

\begin{mathpar}\small
\inferrule[s-syn-success]{
    \keyw{nth}[n](\es) = e\\
    \esynX{e}{\st}{\iota}
}{
    \sstep{\ssyn{n}}{\es;\Upsilon;\Phi}{(\st, \sqitm{\syntrans{n}})}
}

\inferrule[s-syn-fail]{
    \keyw{nth}[n](\es) = e\\
    [\Upsilon \vdash_\Phi e \nRightarrow]
}{
    \serr{\ssyn{n}}{\es;\Upsilon;\Phi}
}
\end{mathpar}

\begin{mathpar}\small
\inferrule[k-itm-syntrans]{
    n' < n
}{
    \sofkX{\sqitm{\syntrans{n'}}}{\kitm}
}
\end{mathpar}
, e.g. for lambdas:
\begin{mathpar}\small
%\inferrule[abs-var]{ }{\edeabs{\tc}{\argEnv}{x}{\memD}{\memG}{x}{\memD}{\memG}}
%
\inferrule[abs-lam]{
    \tdeabs{\Phi}{\tc}{\qity}{\memD}{\ity}{\memD'}\\
    \edeabs{\tc}{\es;\Upsilon;\Phi}{\qitm}{\memD'}{\memG}{\itm}{\memD''}{\memG'}
}{
    \edeabs{\tc}{\es;\Upsilon;\Phi}{\ilam{\qity}{x}{\qitm}}{\memD}{\memG}{\ilam{\tau}{x}{\itm}}{\memG'}{\memD''}
}
\end{mathpar}
\begin{mathpar}\small
\inferrule[abs-anatrans-stored]{
    n : \st \leadsto \iota/x : \tau \in \memG
}{
    \edeabs{\tc}{\argEnv}{\anatrans{n}{\st}}{\memG}{\memD}{x}{\memG}{\memD}
}

\inferrule[abs-syntrans-stored]{
    n : \st \leadsto \iota/x : \tau \in \memG
}{
    \edeabs{\tc}{\argEnv}{\syntrans{n}}{\memG}{\memD}{x}{\memG}{\memD}
}\end{mathpar}
\begin{mathpar}\small
\inferrule[k-itm-anatrans]{
    n' < n\\
    \sofkX{\st}{\kty}
}{
    \sofkX{\sqitm{\anatrans{n'}{\st}}}{\kitm}
}
\end{mathpar}
\begin{mathpar}\small
\inferrule[abs-syntrans-new]{
    n \notin \text{dom}(\memG)\\
    \keyw{nth}[n](\es) = e\\
    \esynX{e}{\st}{\iota}\\
    \tdeabs{\Phi}{\tc}{\srep{\st}}{\memD}{\ity}{\memD'}\\
    (x~\text{fresh})
}{
    \edeabs{\tc}{\es;\Upsilon;\Phi}{\syntrans{n}}{\memG}{\memD}{x}{\memG, n : \st \leadsto \iota/x : \tau}{\memD'}
}
\end{mathpar}

\begin{mathpar}\small
\inferrule[etctx-emp]{ }{\vdash_\Phi \emptyset \leadsto \emptyset}

\inferrule[etctx-ext]{\vdash_\Phi \Upsilon \leadsto \Gamma\\\istype{\st}{\Phi}\\\vdash_\Phi \st \leadsto \tau}{\vdash_\Phi \Upsilon, x \Rightarrow \st \leadsto \Gamma, x : \tau}
\end{mathpar}

\[\small
\begin{array}{lll}
\textbf{Description}& \textbf{Concrete Form}~~~~ & \textbf{Desugared Form}\\
\text{index projection} & e_\text{targ}\texttt{\#}n & \etarg{\opname{idx}}{n}{e_\text{targ}}{\cdot}\\
\text{label projection} & e_\text{targ}\texttt{\#}\conclbl{lbl} & \etarg{\opname{prj}}{\conclbl{lbl}}{e_\text{targ}}{\cdot}\\
\text{explicit invocation}~~~~ & e_\text{targ}{\cdot}\opname{op}[\sttmidx](\es) & \etarg{\opname{op}}{\sttmidx}{e_\text{targ}}{\es}\\
& e_\text{targ}{\cdot}\opname{op}(\es) & \etarg{\opname{op}}{()}{e_\text{targ}}{\es}\\
& e_\text{targ}{\cdot}\opname{op}(\conclbl{lbl}_1=e_1, \ldots, \conclbl{lbl}_n=e_n) & \keyw{targ}[\opname{op}; \texttt{[}\conclbl{lbl}_1, \ldots, \conclbl{lbl}_n\texttt{]}](e_\text{targ}; \\
& & \quad e_1; \ldots; e_n)\\
\text{labeled case analysis} & e_\text{targ}{\cdot}\opname{case}\,\{ & \keyw{targ}[{\opname{case}}; {\texttt{[}\st_1, \ldots, \st_n\texttt{]}}]({e_\text{targ}}; \\
 & ~|~~\st_1\langle x_1, \ldots, x_k \rangle \Rightarrow e_1 & \quad \eanalam{x_1}{\ldots \eanalam{x_k}{e_1}};\\
 & ~|~~\ldots & \quad \ldots;\\ 
 & ~|~~\st_n\langle x_1, \ldots, x_k \rangle \Rightarrow e_n\} & \quad \eanalam{x_1}{\ldots \eanalam{x_k}{e_n}})
\end{array}
\]

 For example, 
\begin{mathpar}
\small
\inferrule[abs-prod]{
    \tdeabs{\Phi}{\tc}{\qity_1}{\memD}{\ity_1}{\memD'}\\
    \tdeabs{\Phi}{\tc}{\qity_2}{\memD'}{\ity_2}{\memD''}
}{
    \tdeabs{\Phi}{\tc}{\qity_1 \times \qity_2}{\memD}{\ity_1 \times \ity_2}{\memD''}
}
\end{mathpar}

The argument interfaces that populate the list provided to opcon definitions is derived from the argument list by the judgement $\keyw{args}(\es)=_n \stx{args}$, defined as follows:
\begin{mathpar}\small
\inferrule[args-z]{ }{
    \keyw{args}(\cdot)=_0 \skap{\karg}{\svar{nil}}
}

\inferrule[args-s]{
    \keyw{args}(\es)=_{n} \st
}{
    \keyw{args}(\es;e)=_{n+1} \skap{\karg}{\svar{rcons}}~\st~(\slam{\kty}{\svar{ty}}{\sana{n}{\svar{ty}}},\slam{\kunit}{\_}{\ssyn{n}})
}
\end{mathpar}
We assume that the definitions of the standard helper functions $\small\svar{nil} :: \kforall{\kalpha}{\klist{\kalpha}}$ and $\small\svar{rcons} :: \kforall{\kalpha}{\klist{\kalpha} \rightarrow \kalpha \rightarrow \klist{\kalpha}}$, which adds an item to the end of a list, have been substituted into these rules. The result is that the $n$th element of the argument interface list simply wraps the static terms $\sana{n}{\st}$ and $\ssyn{n}$.\end{document}
