%\documentclass[12pt]{article}
\documentclass[10pt,preprint]{sigplanconf}
% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.
\usepackage{amsmath}
\usepackage{amssymb} 
\usepackage{amsthm}
\usepackage{ stmaryrd }
\usepackage{mathpartir}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

\input{macros-catlam}

\usepackage{times}
\renewcommand{\ttdefault}{txtt}
\usepackage{alltt}
\usepackage{listings}
\lstset{language=ML,
showstringspaces=false,
basicstyle=\ttfamily\footnotesize,
morekeywords={newcase,extends}}

\usepackage{url}
\usepackage{todonotes}
\lefthyphenmin=5
\sloppy

\newcommand{\moutput}{^{\color{gray}+}}
\newcommand{\rulename}[1]{(#1)}
\def \TirNameStyle #1{\small\rulename{#1}}
\renewcommand{\MathparLineskip}{\lineskiplimit=.6\baselineskip\lineskip=.6\baselineskip plus .2\baselineskip}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\newtheorem{tyconinvariant}{Tycon Invariant}
\newenvironment{proof-sketch}{\noindent{\emph{Proof Sketch.}}}{\qed}
\makeatletter

% Heather-added packages for the fancy table
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{pdflscape}
\usepackage{colortbl}%
\newcommand{\myrowcolour}{\rowcolor[gray]{0.925}}
\usepackage{wasysym}

\renewcommand\topfraction{0.85}
\renewcommand\bottomfraction{0.85}
\renewcommand\textfraction{0.1}
\renewcommand\floatpagefraction{0.85}

\begin{document}

\conferenceinfo{-}{-} 
\copyrightyear{-} 
\copyrightdata{[to be supplied]} 

%\titlebanner{{\tt \textcolor{Red}{{\small Under Review -- distribute within CMU only.}}}}        % These are ignored unless
%\preprintfooter{Distribute within CMU only.}   % 'preprint' option specified.

\title{Modularly Composing Typed Language Fragments}
\subtitle{Supplemental Material}
\authorinfo{}{}{}
%\authorinfo{Cyrus Omar \and Jonathan Aldrich}
 %         {Carnegie Mellon University}
  %         {\{comar, aldrich\}@cs.cmu.edu}   

\maketitle

%\category{D.3.2}{Programming Languages}{Language Classifications}[Extensible Languages]
%\category{D.3.4}{Programming Languages}{Processors}[Compilers]
%\category{F.3.1}{Logics \& Meanings of Programs}{Specifying and Verifying and Reasoning about Programs}[Specification Techniques]
%\keywords
%extensible languages; module systems; type abstraction; typed compilation; type-level computation

\section{Internal Language}
We assume the statics of the IL are specified in the standard way by judgements for  type formation {$\iDelta \vdash \tau$}, typing context formation { $\iDelta \vdash \iGamma$} and type assignment {$\iDelta~\iGamma \vdash \iota : \tau\moutput$}. 
%The typing and type formation contexts obey standard structural properties (i.e. weakening, exchange and contraction). 
The internal dynamics are specified as a structural operational semantics with a stepping judgement {\small $\iota \mapsto \iota\moutput$} and a value judgement {$\iota~\mathtt{val}$}. The multi-step judgement $\iota \mapsto^{*} \iota\moutput$ is the reflexive, transitive closure of the stepping judgement and the evaluation judgement $\iota \Downarrow \iota'$ is defined iff $\iota \mapsto^{*} \iota'$ and $\iota'~\mathtt{val}$. Both the static and dynamic semantics of the IL can be found in any standard textbook covering typed lambda calculi (we directly follow \cite{pfpl}), so we assume familiarity and give the lemmas in this section without proof.

We use {$\mathcal{L}\{{\rightharpoonup}\,{\forall}\,{\mu}\,{\iunit}\,{\times}\,{+}\}$}, the syntax for which is shown in Figure \ref{syntax-IL}, as representative of any intermediate language for a typed functional language. In fact, our intention is not to prescribe a particular choice of IL, so we will here only review the key metatheoretic properties that the IL must possess. Each choice of IL is technically a distinct dialect of @$\lambda$, but for the broad class of ILs that enjoy these properties, the metatheory in the remainder of the supplement should follow without trouble.

\begin{lemma}[Internal Type Assignment]
If $\Delta \vdash \Gamma$ and $\Delta~\Gamma \vdash \iota : \tau$ then $\Delta \vdash \tau$.
\end{lemma}

Internal type safety follows the standard methodology of proving preservation and progress lemmas.

\begin{lemma}[Internal Progress]
If $\emptyset~\emptyset \vdash \iota : \tau$ then either $\iota~\texttt{val}$ or $\iota \mapsto \iota'$.
\end{theorem}
\begin{lemma}[Internal Preservation]
If $\emptyset~\emptyset \vdash \iota : \tau$ and $\iota \mapsto \iota'$ then $\emptyset~\emptyset \vdash \iota' : \tau$. 
\end{lemma}

We assume substitution and simultaneous $n$-ary substitutions, $\delta$ and $\gamma$, have the standard semantics, and that typing and type formation contexts, $\Delta$ and $\Gamma$, obey standard properties of weakening, exchange and contraction. We assume that the names of variables and type variables are unimportant, so that $\alpha$-equivalent terms, types and contexts can be identified implicitly throughout this work. In particular, we need the definitions of substitution validity shown in Figures \ref{fig:internal-type-substitution-validity} and \ref{fig:internal-term-substitution-validity} and the following lemmas.

\begin{figure}[t]
\small
\hspace{-5px}\input{syntax-table-IL}
\caption{Syntax of {$\mathcal{L}\{{\rightharpoonup}\,{\forall}\,{\mu}\,{\iunit}\,{\times}\,{+}\}$}, our internal language (IL). Metavariable $x$ ranges over term variables and $\alpha$ and $t$ both range over type variables.}
\label{syntax-IL}
\end{figure}

\begin{figure}
\small\fbox{$\Delta \vdash \delta : \Delta$}~~$\delta ::=  \emptyset ~|~ \delta, \tau/\alpha$

\begin{mathpar}
\inferrule[tysub-emp]{ }{\Delta \vdash \emptyset : \emptyset}

\inferrule[tysub-ext]{
    \Delta \vdash \delta : \Delta'\\
    \Delta \vdash \tau
}{
    \Delta \vdash \delta, \tau/\alpha : \Delta', \alpha
}
\end{mathpar}
\caption{Internal Type Substitution Validity}
\label{fig:internal-type-substitution-validity}
\end{figure}
\begin{figure}
\small\fbox{$\Delta~\Gamma \vdash \gamma : \Gamma$}~~$\gamma ::= \emptyset ~|~ \gamma, \iota/x$
\begin{mathpar}
\inferrule[tmsub-emp]{ }{\Delta~\Gamma \vdash \emptyset : \emptyset}

\inferrule[tmsub-ext]{
    \Delta~\Gamma \vdash \gamma : \Gamma'\\
    \Delta \vdash \tau\\
    \Delta~\Gamma \vdash \iota : \tau
}{
    \Delta~\Gamma \vdash \gamma, \iota/x : \Gamma', x : \tau
}
\end{mathpar}
\caption{Internal Term Substitution Validity}
\label{fig:internal-term-substitution-validity}
\end{figure}
\begin{lemma}[Internal Type Substitution on Types] If $\Delta \vdash \delta : \Delta'$ and $\Delta\Delta' \vdash \tau$ then $\Delta \vdash [\delta]\tau$.\end{lemma}

\begin{lemma}[Internal Type Substitutions on Typing Contexts] If $\Delta \vdash \delta : \Delta'$ and $\Delta\Delta' \vdash \Gamma$ then $\Delta \vdash [\delta]\Gamma$.
\end{lemma}

\begin{lemma}[Internal Type Substitutions on Terms] If $\Delta \vdash \delta : \Delta'$ and $\Delta\Delta' \vdash \tau$ and $\Delta\Delta' \vdash \Gamma$ and $\Delta\Delta'~\Gamma \vdash \iota : \tau$ then $\Delta~[\delta]\Gamma \vdash [\delta]\iota : [\delta]\tau$.
\end{lemma}


\begin{lemma}[Internal Term Substitutions] If $\Delta \vdash \Gamma$ and $\Delta \vdash \Gamma'$ and $\Delta~\Gamma \vdash \gamma : \Gamma'$ and $\Delta~\Gamma\Gamma' \vdash \iota : \tau$ then $\Delta~\Gamma \vdash [\gamma]\iota : \tau$.
\end{lemma}


\section{Tycon Contexts}
\begin{figure}\fbox{$\vdash \Phi$}\vspace{-25px}
\begin{mathpar}
\small
\inferrule[tcc-emp]{ }{\vdash \cdot}

\inferrule[tcc-ext]{
    \vdash \Phi\\
    \tc \notin \text{dom}(\Phi)\\
    \keq{\emptyset}{\ktyidx}\\
    \sofkz{\emptyset}{\emptyset}{\Phi}{\stx{schema}}{\ktyidx \rightarrow \kity}\\\\
    \vdash_{\Phi,  \tcdef{\tc}{\tcsig{\ktyidx}{\chi}}{\tcstruct{\stx{schema}}{\omega}}} \omega \sim \tcsig{\ktyidx}{\chi}
}{
    \vdash \Phi, \tcdef{\tc}{\tcsig{\ktyidx}{\chi}}{\tcstruct{\stx{schema}}{\omega}}
}
\end{mathpar}
\caption{Tycon context well-definedness.}
\label{fig:tycon-ctxs}
\end{figure}
\begin{figure}[t]
\small\fbox{$\vdash_\Phi \omega \sim \psi$}
\begin{mathpar}\small
\inferrule[ocstruct-intro]{
    \introsig{\klitidx} \in \chi\\
    \emptyset \vdash \klitidx\\\\
    \sofkz{\emptyset}{\emptyset}{\Phi}{\stx{def}}{\ktyidx \rightarrow \klitidx \rightarrow \kargs \rightarrow \kitm}
}{
    \vdash_\Phi \tcstructn{\stx{def}} \sim \tcsig{\ktyidx}{\chi}
}

\inferrule[ocstruct-targ]{
    \vdash_\Phi \omega \sim \tcsig{\ktyidx}{\chi}\\
    \opname{op}\notin\text{dom}(\chi)\\
    \emptyset \vdash \klitidx\\\\
    \sofkn{\emptyset}{\emptyset}{\Phi}{0}{\stx{def}}{\ktyidx \rightarrow \klitidx \rightarrow \kargs \rightarrow (\kty \times \kitm)}
}{
    \vdash_\Phi \tcstructc{\omega}{op}{\stx{def}} \sim \tcsig{\ktyidx}{\chi, \opsig{\opname{op}}{\klitidx}}
}
\end{mathpar}
\caption{Checking opcon structures against tycon signatures.}
\label{ocstruct}
\end{figure}


\subsection{Tycon Context Well-Definedness}

\subsection{Equality Kinds}
Need an equational theory for SL to state equality kind property, but not important for other metatheory. 

\subsection{Full Examples}

\section{Static Language}
\subsection{Kind Formation}

\subsection{Kinding Context Formation}

\subsection{Kinding}

\subsection{Dynamic Semantics}

\subsection{Kind Safety}

\section{Types}
\subsection{Type Translations}

\subsection{Typing Context Translations}

\paragraph{Unicity}
The rules are structured so that if a term is well-typed, both its type and translation are unique.\todo{could move this whole thing to supplement if room needed}
\begin{theorem}[Unicity]
If $\vdash \Phi$ and $\vdash_\Phi \Upsilon \leadsto \Gamma$ and $\vdash_\Phi \st \leadsto \tau$ and $\vdash_\Phi \st' \leadsto \tau'$ and $\eanaX{e}{\st}{\iota}$ and $\eanaX{e}{\st'}{\iota'}$ then $\st = \st'$ and $\tau=\tau'$ and $\iota = \iota'$.
\end{theorem}

\section{External Language}
\subsection{Additional Desugarings}
\subsection{Typing}
\subsection{Proof of Regular String Soundness Tycon Invariant}


\newpage
% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrv}

% The bibliography should be embedded for final submission.

\bibliography{../research}
%\softraggedright
%P. Q. Smith, and X. Y. Jones. ...reference text...

\newpage
\appendix
\section{Appendix}
\begin{mathpar}
\small
\inferrule[s-ty-step]{
    \sstep{\st}{\argEnv}{\st'}
}{
    \sstep{\sty{c}{\st}}{\argEnv}{\sty{c}{\st'}}
}

\inferrule[s-ty-err]{
    \serr{\st}{\argEnv}
}{
    \serr{\sty{c}{\st}}{\argEnv}
}

\inferrule[s-ty-v]{
    \sval{\st}{\argEnv}
}{
    \sval{\sty{c}{\st}}{\argEnv}
}

\inferrule[s-otherty-v]{ }{
    \sval{\sotherty{m}{\tau}}{\argEnv}
}
\end{mathpar}

\begin{mathpar}
\small
\inferrule[s-tycase-step]{
    \sstep{\st}{\argEnv}{\st'}
}{
    \sstep{\stycase{c}{\st}{\sx}{\st_1}{\st_2}}{\argEnv}{\stycase{c}{\st'}{x}{\st_1}{\st_2}}
}

\inferrule[s-tycase-err]{
    \serr{\st}{\argEnv}
}{
    \serr{\stycase{c}{\st}{\sx}{\st_1}{\st_2}}{\argEnv}
}
\end{mathpar}
\begin{mathpar}\small
\inferrule[s-tycase-match]{
    \sval{\sty{c}{\st}}{\argEnv}
}{
    \sstep{\stycase{c}{\sty{c}{\st}}{\sx}{\st_1}{\st_2}}{\argEnv}{[\st/x]\st_1}
}

\inferrule[s-tycase-fail]{
    \st \neq \sty{c}{\st'}
}{
    \sstep{\stycase{c}{\st}{\sx}{\st_1}{\st_2}}{\argEnv}{\st_2}
}
\end{mathpar}
\begin{mathpar}
\small
\inferrule[keq-k]{\kvar \in \kDelta}{\keq{\kDelta}{\kvar}}

\inferrule[keq-ind]{\keq{\kDelta, \kvar}{\kappa}}{
  \keq{\kDelta}{\kmu{\kvar}{\kappa}}}

\inferrule[keq-unit]{ }{\keq{\kDelta}{\kunit}}
\end{mathpar}\begin{mathpar}
\small
\inferrule[keq-prod]{
  \keq{\kDelta}{\kappa_1}~~~~
  \keq{\kDelta}{\kappa_2}
}{
  \keq{\kDelta}{\kprod{\kappa_1}{\kappa_2}}
}

\inferrule[keq-sum]{
  \keq{\kDelta}{\kappa_1}~~~~
  \keq{\kDelta}{\kappa_2}
}{
  \keq{\kDelta}{\ksum{\kappa_1}{\kappa_2}}
}

\inferrule[keq-ty]{ }{\keq{\kDelta}{\kty}}
\end{mathpar}
 %We will discuss strategies for fragments that benefit from more sophisticated equivalences in Section \ref{examples}.\todo{do this}

\begin{mathpar}

\inferrule[k-ity-alpha]{ }{\sofkX{\sqity{\alpha}}{\kity}}
\end{mathpar}

\begin{mathpar}
\small
\inferrule[s-ity-lam-step-1]{
    \sstep{\sqity{\qity_1}}{\argEnv}{\sqity{\qity_1'}}%\sstep{\sqity{\qity_1}}{\argEnv}{\sstep{\sqity{\qity_1'}}}
}{
    \sstep{\sqity{\qity_1\times\qity_2}}{\argEnv}{\sqity{\qity_1' \times \qity_2}}
}

\inferrule[s-ity-lam-step-2]{
    \sval{\sqity{\qity_1}}{\argEnv}\\
    \sstep{\sqity{\qity_2}}{\argEnv}{\sqity{\qity_2'}}%\sstep{\sqity{\qity_1}}{\argEnv}{\sstep{\sqity{\qity_1'}}}
}{
    \sstep{\sqity{\qity_1\times\qity_2}}{\argEnv}{\sqity{\qity_1 \times \qity_2'}}
}

\inferrule[s-ity-lam-err-1]{
    \serr{\sqity{\qity_1}}{\argEnv}
}{
    \serr{\sqity{\qity_1\times\qity_2}}{\argEnv}
}

\inferrule[s-ity-lam-err-2]{
    \serr{\sqity{\qity_2}}{\argEnv}
}{
    \serr{\sqity{\qity_1\times\qity_2}}{\argEnv}
}

\inferrule[s-ity-lam-v]{
    \sval{\sqity{\qity_1}}{\argEnv}\\
    \sval{\sqity{\qity_2}}{\argEnv}
}{
    \sval{\sqity{\qity_1\times\qity_2}}{\argEnv}
}

\inferrule[s-ity-alpha-v]{ }{
    \sval{\sqity{\alpha}}{\argEnv}
}
\end{mathpar}
\begin{mathpar}
\small
\inferrule[k-tycase-parr]{
    \sofkX{\st}{\kty}\\
    \sofk{\kDelta}{\kGamma, \sx :: \kty \times \kty}{\Phi}{\st_1}{\kappa}\\
    \sofkX{\st_2}{\kappa}
}{
    \sofkX{\stycase{\rightharpoonup}{\st}{\sx}{\st_1}{\st_2}}{\kappa}
}
\end{mathpar}
\begin{mathpar}
\small
\inferrule[s-ity-unquote-step]{
    \sstep{\st}{\argEnv}{\st'}
}{
    \sstep{\sqity{\qtuq{\st}}}{\argEnv}{\sqity{\qtuq{\st'}}}
}

\inferrule[s-ity-unquote-err]{
    \serr{\st}{\argEnv}
}{
    \serr{\sqity{\qtuq{\st}}}{\argEnv}
}
\end{mathpar}
\begin{mathpar}
\inferrule[s-ity-trans-step]{
    \sstep{\st}{\argEnv}{\st'}
}{
    \sstep{\sqity{\srep{\st}}}{\argEnv}{\sqity{\srep{\st'}}}
}

\inferrule[s-ity-trans-err]{
    \serr{\st}{\argEnv}
}{
    \serr{\sqity{\srep{\st}}}{\argEnv}
}
\end{mathpar}
This judgement is defined by the following straightforward rules:
\begin{mathpar}\small
\inferrule[tstore-emp]{ }{\emptyset \leadsto \emptyset : \emptyset}

\inferrule[tstore-ext]{\memD \leadsto \delta : \Delta}{(\memD, \st \leftrightarrow \tau/\alpha) \leadsto (\delta, \tau/\alpha) : (\Delta, \alpha)}
\end{mathpar}

\[\small
\begin{array}{lll}
\textbf{Description} ~~~~& \textbf{Concrete Form}~~~~ & \textbf{Desugared Form}\\
\text{sequences} & (e_1, \ldots, e_n) ~\text{or}~ \texttt{[}e_1, \ldots, e_n\texttt{]} & \eintro{()}{e_1; \ldots; e_n}\\
\text{labeled sequences} & \{\mathtt{lbl}_1=e_1, \ldots, \mathtt{lbl}_n=e_n\} & \eintro{\texttt{[}\mathtt{lbl}_1, \ldots, \mathtt{lbl}_n\texttt{]}}{e_1; \ldots; e_n}\\
\text{label application} & \mathtt{lbl}\langle e_1, \ldots, e_n \rangle & \eintro{\mathtt{lbl}}{e_1, \ldots, e_n}\\
\text{numerals} & n & \eintro{n}{\cdot}\\
\text{labeled numerals} & n\texttt{lbl} & \eintro{(n, \texttt{lbl})}{\cdot}\\
\text{strings} & \texttt{"s"} & \eintro{\texttt{"s"}}{\cdot}
\end{array}
\]

\begin{mathpar}\small
\inferrule[s-itm-var-v]{ }{
    \sval{\sqitm{x}}{\argEnv}
}

\inferrule[s-itm-lam-step-1]{
    \sstep{\sqity{\qity}}{\argEnv}{\sqity{\qity'}}
}{
    \sstep{\sqitm{\ilam{\qity}{x}{\qitm}}}{\argEnv}{\sqitm{\ilam{\qity'}{x}{\qitm}}}
}

\inferrule[s-itm-lam-step-2]{
    \sval{\sqity{\qity}}{\argEnv}\\
    \sstep{\sqitm{\qitm}}{\argEnv}{\sqitm{\qitm'}}
}{
    \sstep{\sqitm{\ilam{\qity}{x}{\qitm}}}{\argEnv}{\sqitm{\ilam{\qity}{x}{\qitm'}}}
}
\end{mathpar}
\begin{mathpar}\small
\inferrule[s-itm-lam-err-1]{
    \serr{\sqity{\qity}}{\argEnv}
}{
    \serr{\sqitm{\ilam{\qity}{x}{\qitm}}}{\argEnv}
}

\inferrule[s-itm-lam-err-2]{
    \serr{\sqitm{\qitm}}{\argEnv}
}{
    \serr{\sqitm{\ilam{\qity}{x}{\qitm}}}{\argEnv}
}

\inferrule[s-itm-lam-v]{
    \sval{\sqity{\qity}}{\argEnv}\\
    \sval{\sqitm{\qitm}}{\argEnv}
}{
    \sval{\sqitm{\ilam{\qity}{x}{\qitm}}}{\argEnv}
}
\end{mathpar}
\begin{mathpar}\small
\inferrule[k-itm-unquote]{
    \sofkX{\st}{\kitm}
}{
    \sofkX{\sqitm{\quq{\st}}}{\kitm}
}
\end{mathpar}

\begin{mathpar}\small
\inferrule[s-itm-unquote-step]{
    \sstep{\st}{\argEnv}{\st'}
}{
    \sstep{\sqitm{\quq{\st}}}{\argEnv}{\sqitm{\quq{\st'}}}
}

\inferrule[s-itm-unquote-err]{
    \serr{\st}{\argEnv}
}{
    \serr{\sqitm{\quq{\st}}}{\argEnv}
}

\inferrule[s-itm-unquote-elim]{
    \sval{\sqitm{\qitm}}{\argEnv}
}{
    \sstep{\sqitm{\quq{\sqitm{\qitm}}}}{\argEnv}{\sqitm{\qitm}}
}
\end{mathpar}
\begin{mathpar}
\inferrule[s-ana-step]{
    \sstep{\st}{\argEnv}{\st'}
}{
    \sstep{\sana{n}{\st}}{\argEnv}{\sana{n}{\st'}}
}

\inferrule[s-ana-err]{
    \serr{\st}{\argEnv}
}{
    \serr{\sana{n}{\st}}{\argEnv}
}

\inferrule[s-itm-anatrans-step]{
    \sstep{\st}{\argEnv}{\st'}
}{
    \sstep{\sqitm{\anatrans{n}{\st}}}{\argEnv}{\sqitm{\anatrans{n}{\st'}}}
}

\inferrule[s-itm-anatrans-err]{
    \serr{\st}{\argEnv}
}{
    \serr{\sqitm{\anatrans{n}{\st}}}{\argEnv}
}
\end{mathpar}
, as specified by the judgement $\memG \leadsto \gamma : \Gamma$ defined by the following rules:
\begin{mathpar}
\inferrule[ttrs-emp]{ }{\emptyset \leadsto \emptyset : \emptyset}

\inferrule[ttrs-ext]{
    \memG \leadsto \gamma : \Gamma
}{
    (\memG, n : \st \leadsto \iota/x : \tau) \leadsto (\gamma, \iota/x) : (\Gamma, x : \tau)
}
\end{mathpar}


\begin{mathpar}\small
\inferrule[k-itm-lam]{
    \sofkX{\sqity{\qity}}{\kity}\\
    \sofkX{\sqitm{\qitm}}{\kitm}
}{
    \sofkX{\sqitm{\ilam{\qity}{x}{\qitm}}}{\kitm}
}
\end{mathpar} 
\begin{mathpar}\small
\inferrule[k-raise]{\kDelta \vdash \kappa}{\sofkX{\sraise{\kappa}}{\kappa}}

\inferrule[s-raise]{ }{\serr{\sraise{\kappa}}{\argEnv}}
\end{mathpar}

\begin{mathpar}\small
\inferrule[s-syn-success]{
    \keyw{nth}[n](\es) = e\\
    \esynX{e}{\st}{\iota}
}{
    \sstep{\ssyn{n}}{\es;\Upsilon;\Phi}{(\st, \sqitm{\syntrans{n}})}
}

\inferrule[s-syn-fail]{
    \keyw{nth}[n](\es) = e\\
    [\Upsilon \vdash_\Phi e \nRightarrow]
}{
    \serr{\ssyn{n}}{\es;\Upsilon;\Phi}
}
\end{mathpar}

\begin{mathpar}\small
\inferrule[k-itm-syntrans]{
    n' < n
}{
    \sofkX{\sqitm{\syntrans{n'}}}{\kitm}
}
\end{mathpar}
, e.g. for lambdas:
\begin{mathpar}\small
%\inferrule[abs-var]{ }{\edeabs{\tc}{\argEnv}{x}{\memD}{\memG}{x}{\memD}{\memG}}
%
\inferrule[abs-lam]{
    \tdeabs{\Phi}{\tc}{\qity}{\memD}{\ity}{\memD'}\\
    \edeabs{\tc}{\es;\Upsilon;\Phi}{\qitm}{\memD'}{\memG}{\itm}{\memD''}{\memG'}
}{
    \edeabs{\tc}{\es;\Upsilon;\Phi}{\ilam{\qity}{x}{\qitm}}{\memD}{\memG}{\ilam{\tau}{x}{\itm}}{\memG'}{\memD''}
}
\end{mathpar}
\begin{mathpar}\small
\inferrule[abs-anatrans-stored]{
    n : \st \leadsto \iota/x : \tau \in \memG
}{
    \edeabs{\tc}{\argEnv}{\anatrans{n}{\st}}{\memG}{\memD}{x}{\memG}{\memD}
}

\inferrule[abs-syntrans-stored]{
    n : \st \leadsto \iota/x : \tau \in \memG
}{
    \edeabs{\tc}{\argEnv}{\syntrans{n}}{\memG}{\memD}{x}{\memG}{\memD}
}\end{mathpar}
\begin{mathpar}\small
\inferrule[k-itm-anatrans]{
    n' < n\\
    \sofkX{\st}{\kty}
}{
    \sofkX{\sqitm{\anatrans{n'}{\st}}}{\kitm}
}
\end{mathpar}
\begin{mathpar}\small
\inferrule[abs-syntrans-new]{
    n \notin \text{dom}(\memG)\\
    \keyw{nth}[n](\es) = e\\
    \esynX{e}{\st}{\iota}\\
    \tdeabs{\Phi}{\tc}{\srep{\st}}{\memD}{\ity}{\memD'}\\
    (x~\text{fresh})
}{
    \edeabs{\tc}{\es;\Upsilon;\Phi}{\syntrans{n}}{\memG}{\memD}{x}{\memG, n : \st \leadsto \iota/x : \tau}{\memD'}
}
\end{mathpar}

\begin{mathpar}\small
\inferrule[etctx-emp]{ }{\vdash_\Phi \emptyset \leadsto \emptyset}

\inferrule[etctx-ext]{\vdash_\Phi \Upsilon \leadsto \Gamma\\\istype{\st}{\Phi}\\\vdash_\Phi \st \leadsto \tau}{\vdash_\Phi \Upsilon, x \Rightarrow \st \leadsto \Gamma, x : \tau}
\end{mathpar}

\[\small
\begin{array}{lll}
\textbf{Description}& \textbf{Concrete Form}~~~~ & \textbf{Desugared Form}\\
\text{index projection} & e_\text{targ}\texttt{\#}n & \etarg{\opname{idx}}{n}{e_\text{targ}}{\cdot}\\
\text{label projection} & e_\text{targ}\texttt{\#}\conclbl{lbl} & \etarg{\opname{prj}}{\conclbl{lbl}}{e_\text{targ}}{\cdot}\\
\text{explicit invocation}~~~~ & e_\text{targ}{\cdot}\opname{op}[\sttmidx](\es) & \etarg{\opname{op}}{\sttmidx}{e_\text{targ}}{\es}\\
& e_\text{targ}{\cdot}\opname{op}(\es) & \etarg{\opname{op}}{()}{e_\text{targ}}{\es}\\
& e_\text{targ}{\cdot}\opname{op}(\conclbl{lbl}_1=e_1, \ldots, \conclbl{lbl}_n=e_n) & \keyw{targ}[\opname{op}; \texttt{[}\conclbl{lbl}_1, \ldots, \conclbl{lbl}_n\texttt{]}](e_\text{targ}; \\
& & \quad e_1; \ldots; e_n)\\
\text{labeled case analysis} & e_\text{targ}{\cdot}\opname{case}\,\{ & \keyw{targ}[{\opname{case}}; {\texttt{[}\st_1, \ldots, \st_n\texttt{]}}]({e_\text{targ}}; \\
 & ~|~~\st_1\langle x_1, \ldots, x_k \rangle \Rightarrow e_1 & \quad \eanalam{x_1}{\ldots \eanalam{x_k}{e_1}};\\
 & ~|~~\ldots & \quad \ldots;\\ 
 & ~|~~\st_n\langle x_1, \ldots, x_k \rangle \Rightarrow e_n\} & \quad \eanalam{x_1}{\ldots \eanalam{x_k}{e_n}})
\end{array}
\]

 For example, 
\begin{mathpar}
\small
\inferrule[abs-prod]{
    \tdeabs{\Phi}{\tc}{\qity_1}{\memD}{\ity_1}{\memD'}\\
    \tdeabs{\Phi}{\tc}{\qity_2}{\memD'}{\ity_2}{\memD''}
}{
    \tdeabs{\Phi}{\tc}{\qity_1 \times \qity_2}{\memD}{\ity_1 \times \ity_2}{\memD''}
}
\end{mathpar}

The argument interfaces that populate the list provided to opcon definitions is derived from the argument list by the judgement $\keyw{args}(\es)=_n \stx{args}$, defined as follows:
\begin{mathpar}\small
\inferrule[args-z]{ }{
    \keyw{args}(\cdot)=_0 \skap{\karg}{\svar{nil}}
}

\inferrule[args-s]{
    \keyw{args}(\es)=_{n} \st
}{
    \keyw{args}(\es;e)=_{n+1} \skap{\karg}{\svar{rcons}}~\st~(\slam{\kty}{\svar{ty}}{\sana{n}{\svar{ty}}},\slam{\kunit}{\_}{\ssyn{n}})
}
\end{mathpar}
We assume that the definitions of the standard helper functions $\small\svar{nil} :: \kforall{\kalpha}{\klist{\kalpha}}$ and $\small\svar{rcons} :: \kforall{\kalpha}{\klist{\kalpha} \rightarrow \kalpha \rightarrow \klist{\kalpha}}$, which adds an item to the end of a list, have been substituted into these rules. The result is that the $n$th element of the argument interface list simply wraps the static terms $\sana{n}{\st}$ and $\ssyn{n}$.\end{document}
