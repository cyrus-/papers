
\documentclass{acm_proc_article-sp}
\newcommand{\lamAce}{\lambda_{\text{Ace}}}
% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.
\usepackage{afterpage}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb} 

% Hack. Something's wrong with PLAS paper when using the ACM Proc docclass
\let\proof\relax
\let\endproof\relax
\usepackage{amsthm}

\usepackage{ stmaryrd }
\usepackage{verbatimbox}
\input{../att-icfp14/macros-atlam}
\usepackage{alltt}
\renewcommand{\ttdefault}{txtt}
\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{light-gray}{gray}{0.5}
\usepackage{listings}
\usepackage{wasysym}
    \makeatletter
\usepackage{enumitem}
\usepackage{enumerate}

% \btIfInRange{number}{range list}{TRUE}{FALSE}
%
% Test if int number <number> is element of a (comma separated) list of ranges
% (such as: {1,3-5,7,10-12,14}) and processes <TRUE> or <FALSE> respectively
%
        \newcount\bt@rangea
        \newcount\bt@rangeb

        \newcommand\btIfInRange[2]{%
            \global\let\bt@inrange\@secondoftwo%
            \edef\bt@rangelist{#2}%
            \foreach \range in \bt@rangelist {%
                \afterassignment\bt@getrangeb%
                \bt@rangea=0\range\relax%
                \pgfmathtruncatemacro\result{ ( #1 >= \bt@rangea) && (#1 <= \bt@rangeb) }%
                \ifnum\result=1\relax%
                    \breakforeach%
                    \global\let\bt@inrange\@firstoftwo%
                \fi%
            }%
            \bt@inrange%
        }

        \newcommand\bt@getrangeb{%
            \@ifnextchar\relax%
            {\bt@rangeb=\bt@rangea}%
            {\@getrangeb}%
        }

        \def\@getrangeb-#1\relax{%
            \ifx\relax#1\relax%
                \bt@rangeb=100000%   \maxdimen is too large for pgfmath
            \else%
                \bt@rangeb=#1\relax%
            \fi%
        }

%
% \btLstHL{range list}
%
        \newcommand{\btLstHL}[1]{%
            \btIfInRange{\value{lstnumber}}{#1}%
            {\color{black!10}}%
            {\def\lst@linebgrd}%
        }%

%
% \btInputEmph[listing options]{range list}{file name}
%
        \newcommand{\btLstInputEmph}[3][\empty]{%
            \lstset{%
                linebackgroundcolor=\btLstHL{#2}%
                \lstinputlisting{#3}%
            }% \only
        }

% Patch line number key to call line background macro
        \lst@Key{numbers}{none}{%
            \def\lst@PlaceNumber{\lst@linebgrd}%
            \lstKV@SwitchCases{#1}{%
                none&\\%
                left&\def\lst@PlaceNumber{\llap{\normalfont
                \lst@numberstyle{\thelstnumber}\kern\lst@numbersep}\lst@linebgrd}\\%
                right&\def\lst@PlaceNumber{\rlap{\normalfont
                \kern\linewidth \kern\lst@numbersep
                \lst@numberstyle{\thelstnumber}}\lst@linebgrd}%
            }{%
                \PackageError{Listings}{Numbers #1 unknown}\@ehc%
            }%
        }

% New keys
        \lst@Key{linebackgroundcolor}{}{%
            \def\lst@linebgrdcolor{#1}%
        }
        \lst@Key{linebackgroundsep}{0pt}{%
            \def\lst@linebgrdsep{#1}%
        }
        \lst@Key{linebackgroundwidth}{\linewidth}{%
            \def\lst@linebgrdwidth{#1}%
        }
        \lst@Key{linebackgroundheight}{\ht\strutbox}{%
            \def\lst@linebgrdheight{#1}%
        }
        \lst@Key{linebackgrounddepth}{\dp\strutbox}{%
            \def\lst@linebgrddepth{#1}%
        }
        \lst@Key{linebackgroundcmd}{\color@block}{%
            \def\lst@linebgrdcmd{#1}%
        }

% Line Background macro
        \newcommand{\lst@linebgrd}{%
            \ifx\lst@linebgrdcolor\empty\else
                \rlap{%
                    \lst@basicstyle
                    \color{-.}% By default use the opposite (`-`) of the current color (`.`) as background
                    \lst@linebgrdcolor{%
                        \kern-\dimexpr\lst@linebgrdsep\relax%
                        \lst@linebgrdcmd{\lst@linebgrdwidth}{\lst@linebgrdheight}{\lst@linebgrddepth}%
                    }%
                }%
            \fi
        }

 % Heather-added packages for the fancy table
 \usepackage{longtable}
 \usepackage{booktabs}
 \usepackage{pdflscape}
 \usepackage{colortbl}%
 \newcommand{\myrowcolour}{\rowcolor[gray]{0.925}}
 \usepackage{wasysym}
 
    \makeatother

\lstset{
  language=Python,
  showstringspaces=false,
  formfeed=\newpage,
  tabsize=4,
  commentstyle=\itshape\color{light-gray},
  basicstyle=\ttfamily\scriptsize,
  morekeywords={lambda, self, assert, as, cls},
  numbers=left,
  numberstyle=\scriptsize\color{light-gray}\textsf,
  xleftmargin=2em,
  stringstyle=\color{mauve}
}
\lstdefinestyle{Bash}{
    language={}, 
    numbers=left,
    numberstyle=\scriptsize\color{light-gray}\textsf,
    moredelim=**[is][\color{blue}\bf\ttfamily]{`}{`},
}
\lstdefinestyle{OpenCL}{
	language=C++,
	morekeywords={kernel, __kernel, global, __global, size_t, get_global_id, sin, printf, int2}
}

\usepackage{float}
\floatstyle{ruled}
\newfloat{codelisting}{tp}{lop}
\floatname{codelisting}{Listing}
\setlength{\floatsep}{10pt}
\setlength{\textfloatsep}{10pt}


\usepackage{url}

\usepackage{todonotes}

\usepackage{placeins}

\usepackage{textpos}

\renewcommand\topfraction{0.85}
\renewcommand\bottomfraction{0.85}
\renewcommand\textfraction{0.1}
\renewcommand\floatpagefraction{0.85}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{bussproofs}    % Gentzen-style deduction trees *with aligned sequents!*
\usepackage{mathpartir}	% For type-settting type checking rule figures
\usepackage{syntax}		% For type-setting formal grammars.


\usepackage{hyperref}		% For links in citations

\usepackage{float}			% Make figures float if [H] option is passed.

\iffalse
\usepackage{listings}		% For typesetting code listings
\usepackage{callout}
\usepackage{titlesec}
\usepackage[T1]{fontenc}
\usepackage{upquote}
\lstset{upquote=true}
\fi

\usepackage{textcomp}		% For \textquotesingle as used in introduction
\usepackage{color}			% for box colors, like in TAPL.

\usepackage{amsmath}		% Begin Carthage default packages
\usepackage{makeidx}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphics}
\usepackage{enumerate}
\usepackage{multicol}
\usepackage{epsfig}
\usepackage{csquotes}
\usepackage{enumitem}

\newtheorem{thm}{Theorem}                                                       
\newtheorem{cor}[thm]{Corollary}                                                
\newtheorem{lem}[thm]{Lemma}                                                    
\newtheorem{prop}[thm]{Proposition}                                             
\newtheorem{ax}[thm]{Axiom}                                                     
\theoremstyle{definition}                                                       
\newtheorem{defn}[thm]{Definition}                                              
\newtheorem{exam}[thm]{Example}                                                 
\newtheorem{rem}[thm]{Remark} 

%
% For type setting inference rules with labels.
%
\newcommand{\inferlbl}[3]
			{\inferrule{#3}{#2}{\textsf{\footnotesize{\sc #1}}}}
\newcommand{\inferline}[3]
			{\inferrule{#3}{#2} & {\textsf{\footnotesize{\sc #1}}} \\ \\}

\newcommand{\Lagr}{\mathcal{L}}
\newcommand{\lang}[1]{\Lagr\{#1\}}
\newcommand{\stru}[2]{ {\tt string\_union}(#1,#2)}


\newcommand{\dconvert}[2]{ {\tt dconvert}(#1,#2) }
\newcommand{\filter}[2]{ {\tt filter}(#1,#2) }
\newcommand{\ifilter}[2]{ {\tt ifilter}(#1,#2) }

\newcommand{\reduces}{ \Rightarrow }
\newcommand{\gvd}{\Gamma \vdash }
\newcommand{\ovd}{\Omega \vdash }

\newcommand{\trep}{{\tt rep}}

\newcommand{\tstrf}[1]{`#1\textrm'} %??
\newcommand{\strf}[1]{``#1"}

%%
%% Source and Target language definitions.
%%
\newcommand{\lambdas}{\lambda_S}
\newcommand{\lambdap}{\lambda_P}

% Source language terms.
\newcommand{\sisubst}[3]{{\sf rreplace}[#1](#2,#3)} \newcommand{\rreplace}[3]{{\sf rreplace}[#1](#2,#3)} % lots of legacy naming around these parts...

\newcommand{\rssreplace}[3]{\sisubst{#1}{#2}{#2}} % TODO-nrf fix this.

\newcommand{\coerce}[2]{ {\sf rcoerce}[#1](#2)}
\newcommand{\sistr}[1]{{\sf rstr}[#1]}   \newcommand{\rstr}[1]{{\sf rstr}[#1]} % Lots of legacy naming around these parts...

\newcommand{\strin}[1]{\sistr{#1}}
\newcommand{\rsconcat}[2]{{\sf rconcat}(#1,#2)}

% Source language types.
\newcommand{\stringin}[1]{{\sf stringin}[#1]}

% target language terms.
\newcommand{\tsubst}[3]{{\sf replace}(#1,#2,#3)} \newcommand{\metareplace}[3]{{\sf replace}(#1,#2,#3)} % TODO-nrf rename the commands. Lots of legacy naming around these parts...

\newcommand{\tcheck}[2]{{\sf check}(#1, #2)}
\renewcommand{\tstr}[1]{{{\sf str}[#1]}}
\newcommand{\tconcat}[2]{{\sf concat}(#1,#2)}
\newcommand{\regext}[1]{ {\sf rx}[#1] } % TODO-nrf remove
\newcommand{\rx}[1]{ {\sf rx}[#1] }

% Target language types
\newcommand{\str}{{\sf string}}
\newcommand{\regex}{{\sf regex}}

% Meta-theoretic functions
\newcommand{\dosubst}[3]{{\tt replace}(#1,#2,#3)}
\newcommand{\lsubst}[3]{{\tt lreplace}(#1,#2,#3)}

% Judgements
\newcommand{\err}{\ {\sf err}}
\newcommand{\trden}[1]{\llbracket #1 \rrbracket} % = Translation Denotation.

% Relations
\newcommand{\treduces}{ \Downarrow }
\newcommand{\sreduces}{ \Downarrow }

%%
%% Constrain the size of full-page diagrams and rule lists
%%
%%\newcommand{\pagewidth}{5in}
%%\newcommand{\rulelistwidth}{3in}

% Names of type systems presented in paper
\newcommand{\lcs}{\lambda_{CS}}

\setlength{\grammarindent}{3em}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

%dep_docclass\conferenceinfo{-}{-} 
%dep_docclass\copyrightyear{-} 
%dep_docclass\copyrightdata{[to be supplied]} 

%\titlebanner{{\tt \textcolor{Red}{{\small Under Review -- distribute within CMU only.}}}}        % These are ignored unless
%\preprintfooter{Distribute within CMU only.}   % 'preprint' option specified.

\newcommand{\Ace}{\textsf{Ace}}

\title{A Type System for String Sanitation\\Implemented Inside a Python}

%\authorinfo{~}{~}{~}
%dep_docclass\authorinfo{Nathan Fulton\and Cyrus Omar\and Jonathan Aldrich}
%dep_docclass           {School of Computer Science\\
%dep_docclass            Carnegie Mellon University}
%dep_docclass           {\{nathanfu, comar, aldrich\}@cs.cmu.edu}

\maketitle
\begin{abstract}
%Evidence suggests that programmers are reluctant to adopt new languages to
ABSTRACT HERE
\end{abstract}

%\category{D.3.2}{Programming Languages}{Language Classifications}[Extensible Languages]
%\category{D.3.4}{Programming Languages}{Processors}[Compilers]
%\category{F.3.1}{Logics \& Meanings of Programs}{Specifying and Verifying and Reasoning about Programs}[Specification Techniques]
%\keywords
%type-level computation, typed compilation
\section{Introduction}\label{intro}
In web applications and other settings, incorrect input sanitation often causes
security vulnerabilities. In fact, ...OWASP says it's important... .
Mention CVE stats.
For this reason, modern web frameworks and libraries use various techniques to
ensure proper sanitation of arbitrary user input. On the rare occasions when
these methods are unavailable or insufficient, developers (hopefully) create 
ad hoc sanitation algorithms. Im most cases, sanitation algorithms -- ad hoc 
or otherwise -- are ultimately implemented using the language's regular
expression capabilities. Therefore, a system capable of statically 
checking properties about operations performed using regular expressions will
be expressive enough to capture real-world implementations of sanitation 
algorithms.

Input sanitation is the problem of ensuring that an arbitrary string
is coerced into a safe form before potentially unsafe use. For example, 
preventing SQL injection attacks requires ensuring that any string
coming from user input to a query does not contain unescaped SQL. 
The point at which arbitrary user input is concatenated into a SQL query is called a use site.
Although we believe are general approach extends to a wider class of problems
(e.g. sanitation algorithms for preventing XSS attacks might be definable using
regular tree languages), these generalizations are beyond the scope of the 
present paper.

This paper presents a language extension, definable in the Ace programming language,
for ensuring that input sanitation algorithms are implemented correctly with
respect to use site specifications. If use site specifications are sufficient, 
then type checking ensures the absence of vulnerabilities and other bugs which
arise from improper sanitation. Our extension focuses on sanitation algorithms 
which aim to prevent command-injection style attacks (e.g. SQL injection or RFI). 

\subsection{Related Work and Alternative Approaches}

The input sanitation problem is well-understood. There exist a large number
of techniques and technologies, proposed by both practitioners and researchers, for
preventing injection-style attacks. In this section, we defend the novelty and
significance of our approach with respect to the state of the art in practice 
and in research.

Unlike frameworks provided by languages such as Haskell and
Ruby, our type system provides a \emph{static} guarantee that input is always 
properly sanitized before use. We achieve this by defining a typing relation
which captures idiomatic sanitation algorithms. Type safety in our system relies upon 
several closure and decidability results about regular languages. 

Libraries and frameworks available in functional programming language communities often
make claims about security and sometimes even sophistically mention sophisticated
type systems as evidence of freedom from injection-style attacked.
However, even the specification that input is always sanitized properly before use is not
actually captured by the type system or anywhere else; in fact, the full specification of these
algorithms is rarely characterized by anything more specific than the type
String $\rightarrow$ String, which is a class of safe input sanitation algorithms
only in the most degenerate case.

A number of research languages provide actually static guarantees that a program
is free of input sanitation vulnerabilities. Most rely on some form of information
flow. TODO-nrf  give citations and examples. Our extension to Ace differs from
these systems in the ways following:
\begin{itemize}
  \item Our system is a light-weight solution to a single class of sanitation
  vulnerabilities (e.g. we do not address Cross-Site Scripting). We present our
  system not as a comprehensive solution to the web security problem, but rather as
  evidence that composable, light-weight and simple analyses can address security
  problems.
  \item Our system is defined as a library in terms of an extensible type system,
  as opposed to a stand-alone language. This is important for two reasons.
  First, our system is one of the first large examples written in Ace, and serves
  as an extended case study. Second, although our approach requires
  developers to adopt a new language, it does not require developers to adopt
  a language specifically for web development.
  \item Ace is implemented in Python and shares its grammar. Since Python is a 
  popular programming language among web developers, the barrier between our research
  and adopted technologies is far lower than is e.g. Ur/Web's.
  \item In general, our is a composable, light-weight and
  natural solution to a single problem -- rather than a comprehensive 
  solution to the web security problem. Our goal is to demonstrate that extensible
  type systems can capture static properties of common idioms, and thereby ensure
  safety without introducing much additional complexity.
\end{itemize}

Finally, incorporating regular expressions into the type system is not novel.
The XDuce system \cite{pierce} typechecks XML schemas using regular expressions.
We differ from this and related work in at least two ways.
First, our system  is defined within an extensible type system;
this first difference introduced an interesting class of design problems (see \S ???).
TODO-nrf this is the second time this is used as a warrant. Factor out this argument
and place it at the top???
Second, our focus on security required novel design decisions; for instance, the
filter elimination form is unique to Ace.

In conclusion, our system is novel in at least two ways:
\begin{itemize}
\item The safety guarantees provided by libraries and frameworks in popular languages
are not as (statically) justified as is often belived (or even claimed).
\item Our extension is the first major demonstration of how an extensible type
system may be used to provide light-weight, composable security analyses based upon
idiomatic code.
\end{itemize}

\subsection{Outline}

An outline of this paper follows:

TODO-nrf real outline!
\begin{itemize}
  \item In \S 2, we define the type system's static and dynamic semantics.
  \item Section 3 recalls some classical results about regular expressions and presents meta-theory for our system, including
    the main soundness theorem for $\lcs$.
  \item Finally, \S 4 discusses our implemention of $\lcs$ as a type system extension  within the Ace programming language.
\end{itemize}

\section{A Type System for String Sanitation}

The $\lcs$ language is characterized by a type of strings indexed by regular
expressions, together with operations on such strings which correspond to common
input sanitation patterns.

This section presents the grammar and semantics of $\lcs$.
The semantics are defined in terms of an internal language with at least strings and a regex filter function.
These constraints are captured by the internal term valuations.
The internal language does not necessarily need a regex filter function because
any dynamic conversion is easily definable using a combination of filters and safe
casting.
%
% Begin Grammar 
%

% Remove the < > from grammar productions.
\renewcommand{\grammarlabel}[2]{#1\hfill#2}

\begin{figure}
\begin{grammar}
<r> ::= $\epsilon$ | $.$ | $a$ | $r \cdot r$ | $r + r$ | $r*$ \hfill $a \in \Sigma$

\caption{Regular expressions over the alphabet $\Sigma$.}
\end{grammar}
\end{figure}

\begin{figure}
\begin{grammar}

<$\psi$> ::=	...			\hfill	source types					\alt
$\stringin{r}$				 

<S> ::= ... \hfill source terms \alt
      $\strin{s}$ \hfill $s \in \Sigma^{*}$ \alt
      $\rsconcat{S}{S}$ \alt
      $\sisubst{r}{S}{S}$ \alt
      $\coerce{r}{S}$
\caption{Syntax for the string sanitation fragment of our source language, $\lambdas$.}
\end{grammar}
\end{figure}

\begin{figure}
\begin{grammar}

<$\theta$> ::= ... \hfill target types \alt
$\str$ \alt $\regex$


<P> ::= ... \hfill target terms \alt
  $\tstr{s}$ \alt
  $\rx{r}$ \alt
  $\tconcat{P}{P}$ \alt
  $\tsubst{P}{P}{P}$ \alt
  $\tcheck{P}{P}$ 
  \end{grammar}
\caption{Syntax for the fragment of our target language, $\lambdap$, containing strings and statically constructed regular expressions.}
\label{fig:lcsSyntax}
\end{figure}

there's extra space here because of the next page...

%The $\lcs$ language gives static semantics for common regular expression library
%functions. In this treatment, we include concatenation and filtering.
%The ${\tt filter}$ function removes all instances of a regular expression in a string,
%while concatenation ($+$) concatenates two strings.
%
%\subsection{Typing}
%
%The $\strin[r]$ type is parameterized by regular expressions; if $e:\strin[r]$,
%then $e \in r$. Mapping from an arbitrary $\str$ to a $\strin[r]$ requires
%defining an algorithm -- in terms of filter -- for converting a $\strin[.*]$
%into a $\strin[r]$. The static semantics of the language defines the types of
%operations on regular expressions in terms of well-understood properties about
%regular lanugages; we recall these properties in section 3.
%
%\subsection{Dynamics}
%
%There are two evaluation judgements: $e:T \reduces e'$ and $e:T \treduces i$.
%The $\reduces$ relation is between $\lcs$ expressions, while the $\treduces$
%relation is a mapping from $\lcs$ expressions into internal language expressions
%$i$ such that $i \ival$.
%
%Safety of the evaluation relation depends upon an injective mapping from $\lcs$ types info
%internal language types. This relation, $h$, is defined below.
%
%\subsection{Type Safety}
%
%The type safety proof relies upon some assumptions about the type system and
%dynamics of the internal language, as well as some properties of regular
%languages.
%
%There must exist a translation from $\lcs$ types to the types of the internal
%language. For the remainder of this paper, we call the type translation function
%$h$.
%
%\begin{defn}[Type Translation Function $h$]
%  The type translation function $h : Type \rightarrow IType$ is defined as follows:
%  \begin{itemize}
%    \item $\forall r. h(\strin[r]) = istr$
%    \item $h(\str) = istr$
%  \end{itemize}
%\end{defn}
%
%Additionally, we assume that the internal language contains an implementation of strings,
%together with operations for concatenation and filtering by regular expression.
%
%\begin{defn}[Types of internal values]
%  Let $\tstrf{s}$ range over string literals and $r$ over regular expressions.
%  Internal values are typed as follows:
%\begin{itemize}
%  \item If $e=\tstrf{s}$ then $e:istr$.
%  \item If $e=\ifilter{r}{\tstrf{s}}$ then $e:istr$.
%  \item If $e=\tstrf{s_1}+\tstrf{s_2}$ then $e:istr$.
%\end{itemize}
%\end{defn}
%
%For simplicity, we assume a fixed translation from
%$\lcs$ regular expressions to regular expressions recognizable by the internal
%language's regex library (in practice, a fixed translation is acceptable.)
%To summarize, we assume an internal language containing 
%a string type together with operations for string concatentation and filtering. We
%expect closure over strings for both operations.
%Finally, recall that ${\tt ifilter}$ is only needed for dynamic casts, which may be removed without
%descreasing the expressivity or even usability of the language.
%Finally, the semantics of the filter function are defined in terms of ${\tt rl\_filter}$,
%which is a static version of ${\tt ifilter}$.
%


% I can't achieve the correct latout here. We should have something like:
%       Lam_S Synax         Lam_P Syntax
%       Lam_S Sematics      LAm_P Semantics
%                Translation rules
% Or, alternatively, we can flip reflect things so that the entire page
% reads top-down (Lam_S syntax Lam_S smantics horizontally aligned w/ one
% another).

% Unfortunately, I can't get that to work. So, we're settling for something
% slightly ugly, where the fitures appear in the incorrect order and the 
% translation rules are on top.

% The translations rules *just won't* go to the bottom of the page, so 
% instead I am placing them at the top. Since the figures are out of order,
% it's even more important that we get the number gith. therefore, the counter
% is modified before and after this figure.
\addtocounter{figure}{4}
\begin{figure*}

$\fbox{\inferrule{}{\trden{S} = P}}$
\begin{mathpar}

\inferrule[Tr-string]
{ \ }
{\trden{\strin{s}} = \tstr{s}}

\inferrule[Tr-Concat]
{ \trden{S_1} = P_1 \\ \trden{S_2} = P_2}
{\trden{\rsconcat{S_1}{S_2}} = \tconcat{P_1}{P_2}}

\inferrule[Tr-Subst]
{ \trden{S_1} = P_1 \\ \trden{S_2} = P_2 }
{\trden{ \sisubst{r}{S_1}{S_2} } = \tsubst{\rx{r}}{P_1}{P_2} }

\inferrule[Tr-Coerce-Ok]
{ S : \strin{r} \\ \lang{r'} \subseteq \lang{r}}
{\trden{ \coerce{r'}{S} } = \tstr{s}}

\inferrule[Tr-Coerce-NotOk]
{\trden{S} = P \\ S : \strin{r} \\ \lang{r'} \not \subseteq \lang{r}}
{\trden{\coerce{r'}{S}} = \tcheck{\rx{r'}}{P}}

\end{mathpar}
\caption{Translation from source terms (S) to target terms (P).
The translation is type-directed in the Tr-Coerce cases.}
\end{figure*}
\addtocounter{figure}{-5}



%
% Begin typing/translation relation
%


\newcommand{\sctx}{\Psi} % Context for external typing
\newcommand{\tctx}{\Theta} % Context for internal typing

\newcommand{\ereduces}{\Downarrow}

\begin{figure}[t]
\small
$\fbox{\inferrule{}{\sctx \vdash S : \psi}}$
~~~~$\sctx ::= \emptyset \pipe \sctx, x : \psi$
\begin{mathpar}
\inferrule[S-T-Stringin-I]
{s \in \lang{r}}
{\sctx \vdash \strin{s} : \stringin{r}}

\inferrule[S-T-Concat]
{\sctx \vdash S_1 : \stringin{r_1} \\ \sctx \vdash S_2 : \stringin{r_2}}
{\sctx \vdash \rsconcat{S_1}{S_2} : \stringin{r_1 \cdot r_2}}

\inferrule[S-T-replace]
{\sctx \vdash S_1 : \stringin{r_1} \\ \sctx \vdash S_2 : \stringin{r_2} \\\\ {\tt lsubst}(r,r_1,r_2) = r'}
{\sctx \vdash \sisubst{r}{S_1}{S_2} : \stringin{r'}}

\inferrule[S-T-coerce]
{\sctx \vdash S : \stringin{r'}}
{\sctx \vdash \coerce{r}{S} : \stringin{r}}

\end{mathpar}

\caption{Typing rules for our fragment of $\lambdas$. 
The typing context $\sctx$ is standard.}
\label{fig:etyping}
\end{figure}



\begin{figure}[t]
\small
$\fbox{\inferrule{}{S \sreduces S}}$
$\fbox{\inferrule{}{S \err}}$
\begin{mathpar}
\inferrule[S-E-RStr]
{ \ }
{\strin{s} \sreduces \strin{s}}

\inferrule[S-E-Concat]
{S_1 \sreduces \strin{s_1} \\ S_2 \sreduces \strin{s_2}} 
{\rsconcat{S_1}{S_2} \sreduces \strin{s_1 s_2}} % ???

\inferrule[S-E-Replace]
{S_1 \sreduces \strin{s_1} \\ S_2 \sreduces \strin{s_2} \\ \dosubst{r}{s_1}{s_2} = s} 
{\sisubst{r}{S_1}{S_2} \sreduces \sistr{s}}

\inferrule[S-E-Coerce-OK]
{S \sreduces \strin{s} \\ s \in \lang{r}}
{\coerce{r}{S} \sreduces \strin{s}}

\inferrule[S-E-Coerce-Err]
{S \sreduces \strin{s} \\ s \not \in \lang{r}}
{\coerce{r}{S} \err}

\end{mathpar}
\caption{Big step semantics for our fragment of $\lambdas$.
Error propagation rules are omitted.}
\label{fig:eeval}
\end{figure}

\newpage

\begin{figure}[t]
\small
$\fbox{\inferrule{}{\tctx \vdash P : \theta}}$
~~~~$\tctx ::= \emptyset \pipe \tctx, x : \theta$

\begin{mathpar}
\inferrule[P-T-String]
{ \ }
{\tctx \vdash \tstr{s} : \str}

\inferrule[P-T-Regex]
{ \ }
{\tctx \vdash \rx{r} : \regex}

\inferrule[P-T-Concat]
{\tctx \vdash P_1 : \str \\ \tctx \vdash P_2 : \str}
{\tctx \vdash \tconcat{P_1}{P_2} : \str}

\inferrule[P-T-Replace]
{\tctx \vdash P_1 : \regex \\ \tctx \vdash P_2 : \str \\ \tctx \vdash P_3 : \str }
{\tctx \vdash \tsubst{P_1}{P_2}{P_3} : \str}

\inferrule[P-T-Check]
{\tctx \vdash P_1 : \regex \\ \tctx \vdash P_2 : \str \\ }
{\tctx \vdash \tcheck{P_1}{P_2} : \str}
\end{mathpar}
\caption{Typing rules for our fragment of $\lambdap$.
The typing context $\tctx$ is standard.}
\label{fig:etyping}
\end{figure}

\begin{figure}[t]
\small
$\fbox{\inferrule{}{P \treduces P}}$
$\fbox{\inferrule{}{P \err}}$

\begin{mathpar}
\inferrule[P-E-Str]
{ \ }
{\tstr{s} \treduces \tstr{s}}

\inferrule[P-E-Rx]
{ \ }
{\rx{r} \treduces \rx{r}}

\inferrule[P-E-Concat]
{P_1 \treduces \tstr{s_1} \\ P_2 \treduces \tstr{s_2}} 
{\tconcat{P_1}{P_2} \treduces \tstr{s_1 s_2}} % ???

\inferrule[P-E-Replace]
{P_1 \treduces \rx{r} \\ P_2 \treduces \tstr{s_2} \\ P_3 \treduces \tstr{s_3} \\ \dosubst{r}{s_2}{s_3} = s} 
{\tsubst{P_1}{P_2}{P_3} \treduces \tstr{s}}

\inferrule[P-E-Check-OK]
{P_1 \treduces \rx{r} \\ P_2 \treduces \strin{s} \\ s \in \lang{r}}
{\tcheck{P_1}{P_2} \treduces \tstr{s}}

\inferrule[P-E-Check-Err]
{P_1 \treduces \rx{r} \\ P_2 \treduces \tstr{s} \\ s \not \in \lang{r}}
{\tcheck{P_1}{P_2} \err}
\end{mathpar}
\caption{Big step semantics for our fragment of $\lambdap$.
Error propagation rules are omitted.}
\label{fig:ieval}
\end{figure}


\newpage
\ 
\newpage
\ 
\newpage
Note that we never insert an internal check where the type of the string implies
that a check must succeed. Furthermore, expensive calculations (such as language
inclusion or ${\tt dsubst}$, all occur at compile time.
Since sanitation problems are generally expressible with smalle, simple expressions,
we believe that the compile-time overhead is not significant enough to prohibiour target usecase. Informal experimentation with our implementation seems to
support this assertion.

Due to Ei-Replace, all of our meta-theory depends upon a correct implementation
of both regular expression replacement and inclusion checking in the internal language.
We believe this assumption is okay for two reasons. First, our system is still
superior to the status quo, which relies upon the correctness of these libraries
\emph{in addition to} correct application logic. Second, regular expression libraries are
generally well-tested and there exist verified implementations.


\subsection{Properties of Regular Languages}

The soundness theorems in this section depend upon some well-known properties
of regular expressions. Throughout this section, suppose regular expression
$r$ and strings $s$ are defined over a single, fixed, finite alphabet $\Sigma$.

\begin{thm} \label{thm:closure}
The regular expressions are closed under complements and concatenation.
\end{thm}
\begin{proof}
See \cite{cinderella}.
\end{proof}


\begin{defn}[$\tt{subst}$]
  The function $\subst{r}{s_1}{s_2}$ produces a string in which all substrings
  of $s_1$ matching $r$ are replaced with $s_2$.
\end{defn}

\begin{defn}[$\tt{lsubst}$]
  The function $\lsubst{r}{r_1}{r_2}$ produces a regular expression in which
  and sublanguage $r_1'$ of $r_1$ satisfying the condition $\lang{r_1'} \subseteq{r}$
  is replaced with $r_2$.
\end{defn}

We now present some properties about substitution.

\begin{thm}
  String substitution ($\subst{r}{s_1}{s_2}$) is decidable and defined for all expressions
  and strings over similar alpha.
\end{thm}

\begin{thm}
  Language substittion $(\lsubst{r}{r_1}{r_2})$ is decidable and defined for
  all expressions.
\end{thm}

The following relationship between string substituion and language substitution is at
the heart of our main correctness reesult.

\begin{thm}
  For all $r$, if $s_1 \in r_1$ and $s_2 \in r_2$ then 
  $\subst{r}{s_1}{s_2} \subseteq \lsubst{r}{r_1}{r_2}$.
\end{thm}

\begin{lem}{Coercion Lemma.} \label{thm:coercionalemma}
Suppose that $R$ and $L$ are regular expressions, and that $s \in R$ is a finite string.  Let $s' := coerce(R,L,s)$ with all maximal substrings recognized by $L$ replaced with $\epsilon$.  Then $s'$ is recognized by $(R \backslash L) + \emptyset$ and the construction of $R \backslash L$ is decidable.
\end{lem}
\begin{proof}
Let $F,G$ be FAs corresponding to $R$ and $L$, and let $G'$ be $G$ with its final states inverted (so that $G'$ is the complement of $L$).  Define an FA $H$ as a DFA corresponding to the NFA found by combining $F$ and $G'$ such that $H$ accepts only if $R$ and $L'$ accept or if $s$ is empty (this construction may result in an exponential blowup in state size.)  Clearly, $H$ corresponds to $R \backslash L + \emptyset$.  Thus, the construction of $R \backslash L + \emptyset$ is decidable.

If $R \subset L$, $s' = \emptyset$.  If $L \subset R$, either $s' = \emptyset$, or $s' \in R$ and $s' \not \in L$. If $R$ and $L$ are not subsets of one another, then it may be the case that $L$ recognizes part of $R$.  Consider $L$ as the union of two languages, one which is a subset of $R$ and one which is disjoint.  The subset language is considered above and the disjoint language is inconsequential.
\end{proof}


\subsection{Safety of the Source and Target Languages}


\begin{lem}
  If $\sctx \vdash S : \stringin[r]$ then $r$ is a well-formed regular expression. 
\end{lem}
\begin{proof}
  By induction on the typing derivation and the closure lemmas for regular
  expressions.
\end{proof}


We now prove safety for the string fragment of the source and target languages.

\begin{thm}
  Let $S$ be a term in the source language. If $\sctx \vdash S : \stringin{r}$ 
  then $S \sreduces \rstr{s}$ and $\rstr{s} : \stringin{r}$, or else $S \sreduces \err$.
\end{thm}
\begin{proof}
By induction on the derivation of $\sctx \vdash S : \psi$. The interesting case
is S-T-Replace, which requires Lemma C.

\begin{description}
\item[S-T-Stringin-I:]
If $S = \rsconcat{S_1}{S_2} : \stringin{r}$ then
$S \treduces S$ by S-E-RStr, and $\sctx \vdash S : \psi$ by assumption.

\item[S-T-Concat:] 
Suppose $S = \rsconcat{S_1}{S_2} : \stringin{r_1 r_2}$.
By inversion, $\sctx \vdash S_1 : \stringin{r_1}$ and $\sctx \vdash S_1 : \stringin{r_2}$.
It follows by induction that either $S_1 \treduces \err$, $S_2 \treduces \err$, 
or $S_1 \treduces \rstr{s_1}$ and $S_2 \treduces \rstr{s_2}$ for some $s_1 \in \lang{r_1}$ and $s_2 \in \lang{r_2}$.
In the latter case $S \reduces \rstr{s_1s_2}$ by S-E-Concat and $\sctx \vdash \rstr{s_1s_2} : \tstr{r_1r_2}$ by Lemma B.
In the former cases, $S \sreduces \err$.

\item[S-T-Replace]:
Suppose $S = \rreplace{r}{S_1}{S_2}$ and $\sctx \vdash S : \stringin{r'}$.
By inversion $\sctx \vdash S_1 : \stringin{r_1}$ and $\sctx \vdash S_2 : \stringin{r_2}$ such that $\lsubst{r}{r_1}{r_2} = r'$.
By induction, $S_1 \sreduces \err$, $S_2 \sreduces \err$ 
or $S_1 \sreduces \rstr{s_1}$ and $S_2 \sreduces \rstr{s_2}$ such that 
In the latter case, we know $\metareplace{r}{s_1}{s_2} \in \lang{\lsubst{r}{r_1}{r_2}}$ by Lemma C;
therefore by S-E-Replace, $S \treduces \rstr{s}$ such that  $s \in \lang{\lsubst{r}{r_1}{r_2}} = \lang{r'}$.
So by S-T-String-I, $\rstr{s} : \stringin{r'}$.
In the former cases, $S \treduces \err$.

\item[S-T-Coerce]:
Suppose $S = \coerce{r}{S_1}$ and $S : \stringin{r}$.
By inversion, $\sctx \vdash S_1 : \stringin{r'}$.
By induction, $S_1 \treduces \err$ or $S_1 \treduces \rstr{s}$.
In the former case $S \treduces \err$ by propagation rules.
In the latter case we have by Lemma B(2) that $s \in \lang{r}$ or else
$s \not \in \lang{r}$.
If $s \in \lang{r}$ then $\rstr{s} : \stringin{r}$.
If $s \not \in \lang{r}$ then $S \treduces \err$. 
\end{description}
\end{proof}

\begin{thm}
  Let $P$ be a term in the target language. If $\tctx \vdash P : \theta$ 
  then $P \sreduces P'$ and $P' : \theta$.
\end{thm}
\begin{proof}
The proof proceeds by induction on the typing relation and is trivial give
and inversion lemma for the typing relation. \textbf{We can write up this proof if we end up having enough space...}
\end{proof}

\subsection{Translation Correctness}

We now present the main correctness result.

\begin{thm}
If $S : \strin{r}$ then there exists a T such that $\trden{s} = T$ and either: 
\begin{description}
  \item[(a)] $T \treduces \tstr{s}$ and $S \sreduces \strin{s}$, and $s \in lang{r}$.
  \item[(b)] $T \err$ and $S \err$.
  \end{description}
\end{thm}
\begin{proof}
  \textbf{This is a proof for a different theorem that was swapped out at some point, 
    and is no longer valid. Working on the new proof now, by induction on the typing
  relation and correct choice of T}.
  By induction on the derivation of $\trden{S} = T$. (is this an old proof?) 
\begin{description}
\item[Tr-string] By assumption $\trden{S} = \tstr{s}$. The (a) property follows.
By S-E-Str, $S \sreduces \str{s}$ and by T-E-Str, $\tstr{s} \treduces \tstr{s}$.
By source language type safety, it follows that $s \in \lang{r}$.
\item[Tr-Concat]
By inversion of the typing relaiton for the source lnaguage, $S_1 : \strin{r_1}$ and $S_2 : \stringin{S_2}$.
By induction on the left premise, $T_1 \treduces \tstr{s_1}$, $S_1 \sreduces \str{s_1}$ and $s_1 \in \lang{r_1}$
or else $T_1 err$. 
Similarly for $T_2$ and $S_2$.
In the error cases, the propagations rules corresponding to S-E-Concat and T-E-Concat imply that $\tconcat{T_1}{T_2} \err$ and $\rsconcat{S_1}{S_2} \err$.
In the non-error case, $\rsconcat{S_1}{S_2} \sreduces \strin{s_1 s_2}$ by S-E-Concat and $\tconcat{T_1}{T_2} \treduces \tstr{s_1 s_2}$ by T-E-Concat.
Finally, $s_1 \in \lang{r_1}$ and $s_2 \in \lang{r_2}$ implies that $s_1 s_2 \in \lang{r}$ by \ref{lemmaregex}.
\item[Tr-subst]
Suppose $\sisubst{r}{S_1}{S_2} : \strin{s}$ for some $x$. 
By inverison, $S_1 : \strin{r_1}$ and $S_2 : \strin{r_2}$.
Note that $s : \subst{r}{S_1}{S_2} : \stringin{\tsubst{r}{r_1}{r_2}}$ by S-T-Subst.
By induction, $\trden{S_1} = T_1$ and $\trden{S_2} = T_2$.
Either (a) or (b) holds for each.

If (a) holds for both, the $S_1 \sreduces \strin{S_1}$ and $S_2 \sreduces \strin{S_2}$ for $s_1 \in \lang{r_1}$ and $s_2 \in \lang{r_2}$.
Therefore, $\sisubst{r}{S_1}{S_2} \sreduces \strin{\dosubst{r,s_1,s_2}}$.
The same fact can be shown in an analogous manner for $T_1$ and $T_2$.
Finally, $s_1 \in \lang{r_1}$ and $s_2 \in \lang{r_2}$, which implies that $\dosubst{r}{s_1}{s_2} \in \lang{\sisubst{r}{s_1}{s_2}}$ by \ref{substhm}.

If (b) holds for either the left or right premise, then $\sisubst{r}{S_1}{S_2} \err$ by the propagation rules corresponding to S-T-subst, 
and $\tsubst{S_1}{S_2} \err$ by the propagation rules corresponding to T-T-Subst.

\item[Tr-Coerce-Ok] TODO-nrf.

\item[Tr-Coerce-NotOk] TODO-nrf.

\end{description}
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END SECTION TWO -- THIS IS THE CONFLICT LINE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\newcommand{\F}[1]{\textsf{#1}~}
\newcommand{\FF}[1]{\textsf{#1}}
\newcommand{\Q}{\FF{Arg}}
\newcommand{\xlA}[1]{\lfloor #1 \rfloor_{\lambda}}
\newcommand{\xA}[1]{$\lfloor #1 \rfloor_{\text{Ace}}$}
\newcommand{\rtotau}[1]{\lfloor #1 \rfloor}

\newcommand{\tremp}{{\tt tremp}}
\newcommand{\trdot}{{\tt trdot}}
\newcommand{\trchar}[1]{{\tt trchar}[#1]}
\newcommand{\trseq}[2]{{\tt trseq}(#1; #2)}
\newcommand{\tror}[2]{{\tt tror}(#1; #2)}
\newcommand{\tlstr}[1]{{\tt tstr}[#1]}
\begin{table*}[t]
\centering
\begin{tabular}{ l l l }
$r$ & $\xlA{r}$ & \xA{r}\\
\hline
$\epsilon$ & $\tremp$ & \verb|""|\\
$.$ & $\trdot$ & \verb|"."|\\
$a$ & $\trchar{a}$ & \verb|"|$a$\verb|"|\\
$r_1 \cdot r_2$ & $\trseq{\xlA{r_1}}{\xlA{r_2}}$ & \xA{r_1}\verb| + |\xA{r_2}\\
$r_1 + r_2$ & $\tror{\xlA{r_1}}{\xlA{r_2}}$ & \verb|"(" + |\xA{r_1}\verb! + "|" + !\xA{r_2}\verb| + ")"|\\
\\
$\psi$ & $\xlA{\psi}$ & \xA{\psi}\\
\hline
${\tt string\_in}[r]$ & $\fvar{stringin}[\xlA{r}]$ & \verb|string_in[|\xA{r}\verb|]|\\
\\
  $S$ & $\xlA{S}$ & \xA{S} \\
  \hline
  ${\tt str\_in}[s]$ & $\FF{intro}[\FF{str}[s]]()$ & \verb|"|$s$\verb|"|\\
  ${\tt concat}(S_1; S_2)$  & $\xlA{S_1}\cdot\FF{elim}[\tvar{concat}](\xlA{S_2})$ & \xA{S_1}\verb| + |\xA{S_2} \\
  ${\tt subst}[r](S_1; S_2)$  & $\xlA{S_1}\cdot\FF{elim}[\tvar{subst}~\xlA{r}](\xlA{S_2})$ & \xA{S_1}\verb|.subst(|\xA{r}\verb|, |\xA{S_2}\verb|)|\\
  ${\tt coerce}[r](S)$  & $\xlA{S}\cdot\FF{elim}[\tvar{coerce}~\xlA{r}]()$ & \xA{S}\verb|.coerce(|\xA{r}\verb|)|
\end{tabular}
\caption{Embeddings of the ${\tt string\_in}$ fragment into $\lamAce$ and Ace.}
\end{table*}
%
\newcommand{\atjsynX}[3]{\Gamma \vdash_\fvalCtx #1 \Rightarrow #2 \leadsto #3}
\newcommand{\atjanaX}[3]{\Gamma \vdash_\fvalCtx #1 \Leftarrow #2 \leadsto #3}
\newcommand{\atjerrX}[1]{\Gamma \vdash_\fvalCtx #1~ \mathtt{error}}
\begin{figure*}[t]
\small
$\fbox{\inferrule{}{\atjsynX{e}{\tau}{i}}}$~~~~
$\fbox{\inferrule{}{\atjanaX{e}{\tau}{i}}}$~~~~
%$\fbox{\inferrule{}{\atjerrX{e}}}$
\begin{mathpar}
\inferrule[att-flip]{
	\atjsynX{e}{\tau}{i}
}{
	\atjanaX{e}{\tau}{i}
}

%\inferrule[att-var]{
%	x \Rightarrow \tau \in \Gamma
%}{
%	\atjsynX{x}{\tau}{x}
%}
%
%\inferrule[att-asc]{
%    \tau \Downarrow_\fvalCtx \tau'\\
%	\atjanaX{e}{\tau'}{i}
%}{
%	\atjsynX{e : \tau}{\tau'}{i}
%}
%
%\inferrule[att-let-syn]{
%	\atjsynX{e_1}{\tau_1}{i_1}\\
%	\Gamma, x \Rightarrow \tau_1 \vdash_\fvalCtx e_2 \Rightarrow \tau_2 \leadsto i_2\\
%	\trepof{\tau_1} \Downarrow_\fvalCtx \titype{\sigma_1}
%}{
%	\atjsynX{\F{let}x = e_1~\F{in}e_2}{\tau_2}{(\ilam{x}{\sigma_1}{i_2})~i_1}
%}
%
%\inferrule[att-lam-ana]{
%	\Gamma, x \Rightarrow \tau_1 \vdash_\fvalCtx e \Leftarrow \tau_2 \leadsto i\\
%	\trepof{\tau_1} \Downarrow_\fvalCtx \titype{\sigma_1}
%}{
%	\atjanaX{\lambda x.e}{\ttype{arrow}{(\tau_1, \tau_2)}}{\ilam{x}{\sigma_1}{i}}
%}
%
%\inferrule[att-lam]{
%	\tau_1 \Downarrow_\fvalCtx \tau_1'\\
%		\trepof{\tau_1'} \Downarrow_\fvalCtx \titype{\sigma}\\\\
%	\Gamma, x \Rightarrow \tau_1' \vdash_\fvalCtx e \Rightarrow \tau_2 \leadsto i
%%	i \hookrightarrow_\fvalCtx i'\\
%%		\sigma \hookrightarrow_\fvalCtx \sigma'
%%	\ddbar{\fvar{Arrow}}{\fvalCtx}{\trepof{\tau_1'}}{\sbar_1}\\
%	%\delfromtau{$\Xi_0$}{\fvalCtx}{\tau_1'}{\sabs}\\\\
%}{
%	\atjsynX{\elam{x}{\tau_1}{e}}{\ttype{arrow}{(\tau_1', \tau_2)}}{\ilam{x}{\sigma'}{i}}
%}
%
\inferrule[att-intro-ana]{
	\vdash_\fvalCtx \FF{iana}(\fvar{tycon})=\taudef\\
	\taudef~\taut{opidx}~\taut{tyidx}~((\Gamma; e_1)? :: \ldots :: (\Gamma; e_n)? :: []) \Downarrow_\fvalCtx \titerm{i}\\\\
%	\trepof{\ttype{tycon}{\tauidx'}} \Downarrow_\fvalCtx \titype{\sigma}\\
		\trepof{\ttype{tycon}{\taut{tyidx}}} \Downarrow_\fvalCtx \titype{\sigma}\\
		\Gamma \vdash_\fvalCtx i : \sigma
}{
	\atjanaX{\FF{intro}[\taut{opidx}](e_1; \ldots; e_n)}{\ttype{tycon}{\taut{tyidx}}}{i}
}

%\inferrule[att-i-asc-ty]{
%	\atjanaX{I}{\tau}{i}
%}{
%	\atjsynX{I : \tau}{\tau}{i}
%}
%
%\inferrule[att-i-asc-tycon]{
%	\vdash_\fvalCtx \FF{isyn}(\fvar{tycon})=\taudef\\\\
%	\taudef~\tauidx~((\Gamma; e_1)? {::}{\ldots}{::}(\Gamma; e_n)? {::} []) \Downarrow_\fvalCtx \tden{\titerm{i}}{\ttype{tycon}{\tauidx'}}\\
%			\trepof{\tau_1'} \Downarrow_\fvalCtx \titype{\sigma}\\
%	\Gamma \vdash_\fvalCtx i : \sigma
%}{
%	\atjsynX{\FF{intro}[\tauidx](e_1; \ldots; e_n)] :: \fvar{tycon}}{\ttype{tycon}{\tauidx'}}{i'}
%}
%
\inferrule[att-elim-syn]{
	\atjsynX{e}{\ttype{tycon}{\taut{tyidx}}}{i}\\
	\vdash_\fvalCtx \FF{esyn}(\fvar{tycon})=\taudef\\\\
	\taudef~\taut{opidx}~\taut{tyidx}~\titerm{i}~((\Gamma; e)? :: (\Gamma; e_1)? :: \ldots :: (\Gamma; e_n)? :: []) \Downarrow_\fvalCtx (\tau, \titerm{i'})\\\\
			\trepof{\tau} \Downarrow_\fvalCtx \titype{\sigma}\\
	\Gamma \vdash_\fvalCtx i' : \sigma
}{
	\atjsynX{e\cdot\FF{elim}[\taut{opidx}](e_1; \ldots; e_n)}{\tau}{i'}
}
\end{mathpar}
%\vspace{-10px}
\caption{The bidirectional active typechecking and translation judgements.}
\label{atj}
\end{figure*}
\newcommand{\tlevalX}[2]{#1 \Downarrow_\fvalCtx #2}
\begin{figure*}[t]
\small
$\fbox{\inferrule{}{\tau \Downarrow_\fvalCtx \tau'}}$~~~~
\begin{mathpar}
\inferrule[trstr-eval]{ }{\tlevalX{\tlstr{s}}{\tlstr{s}}}

\inferrule[tremp-eval]{ }{\tremp \Downarrow_\fvalCtx \tremp}

\cdots

\inferrule[tror-eval]{
	\tlevalX{\tau_1}{\tau_1'}\\
	\tlevalX{\tau_2}{\tau_2'}
}{
	\tlevalX{\tror{\tau_1}{\tau_2}}{\tror{\tau_1'}{\tau_2'}}
}

trmatch

trlsubst

trsublang


%\inferrule[repof]{
%	\tau \Downarrow_\fvalCtx \ttype{tycon}{\tauidx}\\
%	\vdash_\fvalCtx \FF{rep}(\fvar{tycon}) = \taurep\\
%	\taurep~\tauidx \Downarrow_\fvalCtx \titype{\sigma}
%}{
%	\FF{repof}(\tau) \Downarrow_\fvalCtx \titype{\sigma}
%}
%
\inferrule[syn]{
    \tau \Downarrow_\fvalCtx (\Gamma; e)?\\
	\atjsynX{e}{\tau}{\iota}\\\\
    [\tau/\tvar{t}_{ty}, \titerm{\iota}/\tvar{t}_{trans}]\tau_2 \Downarrow_\fvalCtx \tau_2'
}{
	\FF{syn}(\tau_1; \tvar{t}_{ty}, \tvar{t}_{trans}.\tau_2) \Downarrow_\fvalCtx \tau_2'
}

\inferrule[ana]{
	\tau_1 \Downarrow_\fvalCtx (\Gamma; e)?\\
	\tau_2 \Downarrow_\fvalCtx \tau_2'\\
	\atjanaX{e}{\tau_2'}{\iota}\\\\
	[\titerm{\iota}/\tvar{t}_{trans}]\tau_3 \Downarrow_\fvalCtx \tau_3'
}{
	\FF{ana}(\tau_1; \tau_2; \tvar{t}_{trans}.\tau_3) \Downarrow_\fvalCtx \tau_3'
}

TODO: add rx, str stuff
\end{mathpar}
\caption{\small Normalization semantics for the type-level language. Missing rules (including error propagation rules and normalization of quoted internal terms and types) are unsurprising and will be given later.}
\label{tleval}
\end{figure*}
\begin{figure}[t]
\small\begin{flalign}
& \F{tycon}\fvar{stringin}~\F{of}\FF{R}~\{\\
& \quad \F{iana}\{\tlam{opidx}{\FF{String}}{
	\tlam{tyidx}{\FF{R}}{
	\tlam{a}{\klist{\Q}}{\\
& \quad\quad \tvar{arity0}~\tvar{a}~(\tvar{check}~\tvar{opidx}~\tvar{tyidx}~\titerm{\iup{\tvar{opidx}}})
	}}
}\}\\
& \quad \F{esyn}\{\tlam{opidx}{\kunit+(\FF{R}+\FF{R})}{
	\tlam{a}{\klist{\Q}}{\\
& \quad\quad \tsumcase{\tvar{opidx}}{\_}{\\
& \quad\quad\quad \tvar{arity2}~\tvar{a}~\tlam{a1}{\Q}{\tlam{a2}{\Q}{\\
& \quad\quad\quad\quad \tvar{rsyn}~\tvar{a1}~\tlam{r1}{\FF{R}}{\tlam{i1}{\kITerm}{~}}\\
& \quad\quad\quad\quad \tvar{rsyn}~\tvar{a2}~\tlam{r2}{\FF{R}}{\tlam{i2}{\kITerm}{~}}\\
& \quad\quad\quad\quad\quad (\ttype{stringin}{\FF{rseq}(\tvar{r1}; \tvar{r2})}, \\
& \quad\quad\quad\quad\quad\titerm{{\tt iconcat}(\iup{\tvar{i1}}; \iup{\tvar{i2}})})
}}\\
& \quad\quad}{opidx'}{d}}
}\}
\};\\
& \F{def}\tvar{concat} = \tinl{\kunit, \FF{R}+\FF{R}}{\tunit};\\
& \F{def}\tvar{subst} = \tlam{r}{\FF{R}}{\tinr{\kunit, \FF{R}+\FF{R}}{\tinl{\FF{R},\FF{R}}{\tvar{r}}}};\\
& \F{def}\tvar{coerce} = \tlam{r}{\FF{R}}{\tinr{\kunit, \FF{R}+\FF{R}}{\tinr{\FF{R},\FF{R}}{\tvar{r}}}}
\end{flalign}
\caption{Definition of $\phi_S$, which enables the embedding of fragment $S$ into $\lamAce$.}
\end{figure}
%\begin{figure}
%\[
%\begin{array}{lcl}
%% & & Definition & Kind\\
%\tvar{concat} & := & \tinl{\kunit, \FF{R}+\FF{R}}{\tunit}\\%& \kunit + (R + R)\\
%\tvar{replace} & := & \tlam{r}{\FF{R}}{\tinr{\kunit, \FF{R}+\FF{R}}{\tinl{\FF{R},\FF{R}}{\tvar{r}}}}\\% & \karrow{a}{b}\\
%\tvar{coerce} & := & \tlam{r}{\FF{R}}{\tinr{\kunit, \FF{R}+\FF{R}}{\tinr{\FF{R},\FF{R}}{\tvar{r}}}}\\
%\end{array}
%\]
%\caption{Definitions}
%\end{figure}

\subsection{Background: Ace}
TODO: Make a TR out of the OOPSLA submission.
\subsection{Explicit Conversions}
\subsection{Adding Subtyping to Ace}
\subsection{Theory}

\section{Related Work}

\section{Discussion}


\bibliographystyle{abbrv}

% The bibliography should be embedded for final submission.

\bibliography{../research}
%\softraggedright
%P. Q. Smith, and X. Y. Jones. ...reference text...


\end{document}
