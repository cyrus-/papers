\documentclass[11pt,leqno]{article}
\usepackage{cmu-titlepage2}
\usepackage{fullpage}
\usepackage[small,bf]{caption2}
\usepackage{times}
\usepackage{helvet}
\usepackage{courier}

\usepackage{amsmath}
\usepackage{amssymb} 
\usepackage{amsthm}
\usepackage{ stmaryrd }
\usepackage{mathpartir}
\usepackage{enumerate}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tabularx}
\usepackage{morefloats}
\usepackage{bussproofs}    % Gentzen-style deduction trees *with aligned sequents!*
\usepackage{mathpartir}    % For type-settting type checking rule figures
\usepackage{syntax}        % For type-setting formal grammars.
\usepackage{hyperref}       % For links in citations
\usepackage{enumerate}
\usepackage{enumitem}

\input{../../att-icfp14/macros-atlam}

\usepackage{todonotes}

\newtheorem{tr}{TR Item}
\renewcommand{\thetr}{\Alph{tr}} % "letter-numbered" theorems
\newtheorem{trexam}[tr]{Example}
\newtheorem{trthm}[tr]{Theorem}
\newtheorem{trlem}[tr]{Lemma}
\newtheorem{trdef}[tr]{Definition}
\newtheorem{trconj}[tr]{Conjecture}
\newtheorem{ass}[tr]{Assumption}

\newtheorem{thm}{Theorem}                                                       
\newtheorem{cor}[thm]{Corollary}                                                
\newtheorem{lem}[thm]{Lemma}                                                    
\newtheorem{prop}[thm]{Proposition}                                             
\newtheorem{ax}[thm]{Axiom}                                                     
\theoremstyle{definition}                                                       
\newtheorem{defn}[thm]{Definition}                                              
\newtheorem{exam}[thm]{Example}                                                 
\newtheorem{rem}[thm]{Remark} 
%\renewcommand*{\proofname}{Proof Sketch}

%
% For type setting inference rules with labels.
%
\newcommand{\inferlbl}[3]
            {\inferrule{#3}{#2}{\textsf{\footnotesize{\sc #1}}}}
\newcommand{\inferline}[3]
            {\inferrule{#3}{#2} & {\textsf{\footnotesize{\sc #1}}} \\ \\}

\newcommand{\Lagr}{\mathcal{L}}
\newcommand{\lang}[1]{\Lagr\{#1\}}
\newcommand{\stru}[2]{ {\tt string\_union}(#1,#2)}


\newcommand{\dconvert}[2]{ {\tt dconvert}(#1,#2) }
\newcommand{\filter}[2]{ {\tt filter}(#1,#2) }
\newcommand{\ifilter}[2]{ {\tt ifilter}(#1,#2) }

\newcommand{\reduces}{ \Rightarrow }
\newcommand{\gvd}{\Gamma \vdash }
\newcommand{\ovd}{\Omega \vdash }

\newcommand{\trep}{{\tt rep}}

\newcommand{\tstrf}[1]{`#1\textrm'} %??
\newcommand{\strf}[1]{``#1"}


\newcommand{\iso}{\cong}
%%
%% Source and Target language definitions.
%%
\newcommand{\lambdas}{\lambda_{RS}}
\newcommand{\lambdap}{\lambda_P}

% Source language terms.
\newcommand{\sisubst}[3]{{\sf rreplace}[#1](#2;#3)} \newcommand{\rreplace}[3]{{\sf rreplace}[#1](#2;#3)} % lots of legacy naming around these parts...

\newcommand{\rssreplace}[3]{\sisubst{#1}{#2}{#2}} % TODO-nrf fix this.

\newcommand{\coerce}[2]{ {\sf rcoerce}[#1](#2)}
\newcommand{\rcoerce}[2]{{\sf rcoerce}[#1](#2)}
\newcommand{\sistr}[1]{{\sf rstr}[#1]}   \newcommand{\rstr}[1]{{\sf rstr}[#1]} % Lots of legacy naming around these parts...

\newcommand{\val}{{\sf val}}

\newcommand{\rcheck}[4]{ {\sf rcheck}[#1](#2;#3;#4) }


\newcommand{\strin}[1]{\sistr{#1}}
\newcommand{\rsconcat}[2]{{\sf rconcat}(#1;#2)} \newcommand{\rconcat}[2]{{\sf rconcat}(#1;#2)} % lots of legact naming around these parts..

% Source language types.
\newcommand{\stringin}[1]{{\sf stringin}[#1]}

% target language terms.
\newcommand{\tsubst}[3]{{\sf replace}(#1;#2;#3)} \newcommand{\metareplace}[3]{{\sf replace}(#1;#2;#3)} % TODO-nrf rename the commands. Lots of legacy naming around these parts...

\newcommand{\tcheck}[4]{{\sf check}(#1; #2; #3; #4)}
\renewcommand{\tstr}[1]{{{\sf str}[#1]}}
\newcommand{\preplace}[3]{{\sf replace}(#1;#2;#3)}
\newcommand{\tconcat}[2]{{\sf concat}(#1;#2)} \newcommand{\concat}[2]{{\sf concat}(#1;#2)} % lots of legacy naming around these parts...

\newcommand{\regext}[1]{ {\sf rx}[#1] } % TODO-nrf remove
\newcommand{\rx}[1]{ {\sf rx}[#1] }

% Target language types
\newcommand{\str}{{\sf string}}
\newcommand{\regex}{{\sf regex}}

% Meta-theoretic functions
\newcommand{\lsubst}[3]{{\sf subst}(#1;#2;#3)} % This used to renderlreplace(...) so there're probably mistkes wherever this command was used now.
\newcommand{\lreplace}[3]{{\sf lreplace}(#1; #2; #3)}

\newcommand{\sctx}{\Psi} % Context for external typing
\newcommand{\tctx}{\Theta} % Context for internal typing
\newcommand{\ereduces}{\Downarrow}


\newcommand{\strcase}[3]{ {\sf rstrcase}(#1; #2; #3)}
\newcommand{\pstrcase}[3]{ {\sf strcase}(#1; #2; #3)}

\newcommand{\lhead}[1]{ {\sf lhead}(#1) }
\newcommand{\ltail}[1]{ {\sf ltail}(#1) }


% Judgements
\newcommand{\trden}[1]{\llbracket #1 \rrbracket} % = Translation Denotation.
% Relations
\newcommand{\treduces}{ \Downarrow }
\newcommand{\sreduces}{ \Downarrow }

%%
%% Constrain the size of full-page diagrams and rule lists
%%
%%\newcommand{\pagewidth}{5in}
%%\newcommand{\rulelistwidth}{3in}

% Names of type systems presented in paper
\newcommand{\lcs}{\lambda_{S}}

\setlength{\grammarindent}{3em}

% Arguments to lreplace are as follows:
% lreplace(pattern to replace, target, replacement).
% 
% ie lreplace(a,b,c) reads "replace all instances of a in b with c" and
% correspondes to Python's b.replace(a,c). 
\renewcommand{\lreplace}[3]{{\tt lreplace}(#1, #2, #3)}
\newcommand{\freplace}[3]{{\tt freplace}(#1, #2, #3)}
\newcommand{\freplacep}[4]{{\tt freplace}(#1,#2,#3,#4)}

\newcommand{\eps}{\epsilon}

\title{Statically Typed String Sanitation Inside a Python (Technical Report)}
\author{Nathan Fulton \and Cyrus Omar \and Jonathan Aldrich}
\date{December 2014}
\trnumber{CMU-ISR-14-112}
\keywords{type systems; regular languages; input sanitation; string sanitation}
\support{This work was supported by the National Security Agency lablet contract \#H98230-14-C-0140.}
\abstract{This report contains supporting evidence for claims put forth and explained in the paper ``Statically Typed String Sanitation Inside a Python'' \cite{fulton2014}, including proofs of lemmas
and theorems asserted in the paper, examples, and additional discussion of the paper's technical content.}
\begin{document}
\maketitle
\section{Terminology and Notation}
Theorems and lemmas appearing in \cite{fulton2014} are numbered, while supporting facts appearing only in the Technical Report are lettered.
Numbered items correspond to the numbering in \cite{fulton2014}.

\section{$\lambdas$}

This section presents proofs of lemmas and theorems about the type systems
presented in \cite{fulton2014}, the accompanying paper. In addition, we provide some examples to help 
motivate and explain definitions.

To facilitate the type safety proof, we introduce
a small step semantics for both $\lambdas$ and $\lambdap$. All theorems in
this section are proven as stated in \cite{fulton2014}.

\subsection{Head and Tail Operations}

\begin{defn}[Definition of \lhead{r}]\label{def:lhead}
The relation $\lhead{r}=r'$ is defined in terms of the structure of $r$:
\begin{align*}
\lhead{r}                 &= \lhead{r, \epsilon} \\
\lhead{\epsilon, r'}      &= \epsilon \\
\lhead{a, r'}             &= a \\
\lhead{r_1\cdot r_2, r'}  &= \lhead{r_1, r_2} \\
\lhead{r_1 + r_2, r'}     &= \lhead{r_1, r'} + \lhead{r_2, r'} \\
\lhead{r^*, r'}           &= \lhead{r', \epsilon} + \lhead{r, \epsilon}
\end{align*}
\end{defn}

\begin{defn}[Brzozowski's Derivative]\label{def:derivative}
  The \emph{derivative of $r$ with respect to $s$} is denoted by $\delta_s(r)$
  and is $\delta_s(r) = \{t | st \in \lang{r}\}$.
\end{defn}

\begin{defn}[Definition of \ltail{r}]
The relation $\ltail{r} = r'$ is defined in terms of $\lhead{r}$.
Note that $\lhead{r} = a_1 + a_2 + ... + a_i$.
We define $\ltail{r} = \delta_{a_1}(r) + \delta_{a_2}(r) + ... + \delta_{a_i}(r) + \epsilon$.
\end{defn}

Using these definitions of head and tail, we establish a correctness
result upon which type soundness for the concatenation operator in
$\lambdas$ depends.

Throughout the following proofs, we abbreviate $s \in \lang{r}$ by $s \in r$.

\begin{trlem}[Leading characters are in the head] \label{trlemmax}
If $s = c_1  c_2 \cdots c_m \in \lang{r}$, then
$c_1 \in \lhead{r}$.
\end{trlem}
\begin{proof}
By structural induction on $r$.

If $r = x$ for some character $x$ then $s \in \lang{r}$ implies $s = x$.
By definition of lhead, $\lhead{s} = \lhead{s, \epsilon} = \lhead{x, \epsilon} = x$.
Finally, $x \in \lang{x}$.

If $r = r_1 \cdot r_2$ then $s \in \lang{r}$ implies $s = c_1 s_1 s_2$
such that $c_1 s_1 \in \lang{r_1}$. 
By definition of lhead, $\lhead{r_1 \cdot r_2} = \lhead{r_1, r_2} =
\cdots + \lhead{r_1, \epsilon} = \cdots + \lhead{r_1}$. Therefore, $r_1 \subseteq \lhead{r_1, r_2}$
and so it suffices to show that $s = c_1 s_1 s_2$ such that $c_1 \in \lhead{r_1}$,
\todo{this is why we break out the $c_1$ from the $s_1$, both here and going forward}
which holds by induction because $c_1 s_1 \in \lang{r_1}$. 

If $r = r_1 + r_2$ then $s \in r$ implies either $s \in r_1$ or $s \in r_2$.
Without loss of generality suppose $s \in r_1$.
Then by induction $s = c_1 \cdots c_m$ such that $c_1 \in \lhead{r_1}$.
By definition, $\lhead{r} = \lhead{r_1, \epsilon} + \lhead{r_2, \epsilon} = \lhead{r_1} + \cdots$.
Therefore, $c_1 \in \lhead{r}$.

If $r = r_1^*$ then $s \in r$ implies that $s = s_1 \cdots s_k$ where $k \ge 0$ and $s_i \in \lang{r}$.
By definition of lhead, $\lhead{r_1^*} = \epsilon + \lhead{r_1}$.
If $s = \epsilon$, then $s \in \lang{\epsilon} \subseteq \lang{\lhead{r_1}}$.
If $s = s_1 \cdots s_k$, then $s_1 \in \lang{r}$ and so by induction $s_1 = c_1 \cdots c_k$ such that $c_1 \in \lang{\lhead{r}}$.
\end{proof}

\begin{trthm}[Correctness of \textsf{ltail}]
If $s \in \lang{r}$ then $s \in \lang{\lhead{r} \cdot \ltail{r}}$.
\end{trthm}
\begin{proof}
The proof proceeds by structural induction on $r$.
In each case, we identify sublanguages of the head and tail of $r$ such that 
$s$ is in the concatenation of the the sublanguages.
Throughout the proof, we use the fact that $\lang{r'} \subseteq \lang{r}$ and $\lang{q'} \subseteq \lang{q}$
implies $\lang{r' \cdot q'} \subseteq \lang{r \cdot q}$.

\begin{itemize}[label=$ $,itemsep=1ex]

\item \textbf{Case $r = c$ for $c \in Sigma$}.
By definition, if $s \in \lang{c}$ then $s = c$.
By definition of lhead and ltail, $\lhead{c} = \lhead{c, \epsilon} = c$
and $\lang{\epsilon} \subseteq \lang{\ltail{r}}$.
Therefore, $c \in \lang{c \cdot \epsilon} \subseteq \lang{\lhead{r} + \ltail{r}}$.

\item \textbf{Case $r = r_1 \cdot r_2$}.
Suppose $s \in \lang{r}$.
We may decompose $s$ as $s_1  \cdots s_n$ such that $s_1 = c_1 s_1' \in \lang{r_1}$.
Note that $c_1 \in \lhead{r_1}$ by \ref{trlemmax}.
Therefore, $c_1 \in \lhead{r_1 \cdot r_2}$ by definition of lhead.
It suffices to show that $s_1' s_2 \in \lang{\delta_{c_1}(r)}$.
Since $s = c_1 s_1' s_2\in \lang{r}$, it follows by the definition of derivative that $s_1' s_2 \in \delta_{c_1}(r)$.
Therefore, $s = c_1 s_1' s_2 \in \lang{ c_1 \cdot \delta_{c_1} } \subseteq \lang{ \lhead{r} \cdot \ltail{r}}$.


\item \textbf{Case $r = r_1 + r_2$}.
Suppose $s \in \lang{r_1 + r_2}$
so that $s \in \lang{r_1}$ or $s \in \lang{r_2}$.
Consider without loss of generality the case where $s \in \lang{r_1}$.
By induction, $s \in \lang{\lhead{r_1} \cdot \ltail{r_1}}$
Note that $\lhead{r_1} \subseteq \lhead{r}$
and $\ltail{r_1} \subseteq \ltail{r}$.
Therefore, $\lhead{r_1} \cdot \ltail{r_2} \subseteq \lhead{r_1} \cdot \ltail{r_1}$.


\item \textbf{Case $r = q^*$}.
Either $s$ is the empty string or else the $k^{th}$ unwinding (i.e., $s = s_1 \cdots s_k$ where $k > 0$ and $s_i \in \lang{q}$).

Suppose $s = \epsilon$.
By definition of lhead, $\lhead{r} = \lhead{q^*} = \lhead{q^*, \epsilon} = \lhead{\epsilon, \epsilon} + \cdots = \epsilon + \cdots$.
By definition of ltail, $\ltail{r} = \epsilon \cdots$.
From these facts we conclude that $s = \epsilon \in \lang{\epsilon \cdot \epsilon} \subseteq \lang{\lhead{r} \cdot \ltail{r}}$.

Suppose instead that $s = s_1 \cdots s_k$ for $k < 0$ where $s_i \in \lang{q}$.
If $q = \epsilon$ then $s = \epsilon$ and the conclusion follows for the same reason as the epsilon subcase of the character case.
Otherwise, $s$ is not the empty string and so $s = c_1 s_1 s_2$ where $s_1$ and $s_2$ might be empty.
By the lemma above, $c_1 \in \lhead{s}$.
By the definition of derivative, $s_1s_2 \in \delta_{c_1}(s)$.
Therefore, $s \in \lang{\lhead{s} \cdot \delta_{c_1}(s)} \subseteq \lang{\lhead{r} \cdot \ltail{r}}$, where the set inclusion follows by the definition
of lhead and ltail.
\end{itemize}
\end{proof}

\begin{trexam}[Decomposition is not Reversible]\label{exam:headsandtails}
$r \not = \lhead{r} \cdot \ltail{r}$.
\end{trexam}
\begin{proof}
A simple counter-example is $ab + cd$. 
Note that $\lhead{a\cdot b + c\cdot d} = a+c$ and $\ltail{a\cdot b + c\cdot d} = b + d$. 
Therefore, $\{ad,bc\} \subset \lang{\lhead{a\cdot b + cd\cdot } \cdot \ltail{a\cdot b + c\cdot d}}$ even though neither of these is in $\lang{r}$.
\end{proof}

Example~\ref{exam:headsandtails} does not imply a counter-example to type soundness because $s \in \lang{r} \implies s \in \lhead{r}\cdot\ltail{r}$ is the
property required for soundness. 

This is a general pattern in string operations: $\lambdas$ simulates -- within the type system -- common operations on strings. 
If there is an operation for concatenating to strings, we define an operation for concatenating two regular expressions.
If there is an operation for peeling off the first (n) characters of a string, then we define an operation for 
converting a regular expression $r$ into a regular expression $r'$ which recognizes any $n^{th}$ suffix of a string in $r$.

It is important to note, however, that the type system need not \emph{exactly} simulate the action of string operations.
In the case of concatenation, we lose some information because more string values are possible -- according the types --
than are actually possible in the dynamic semantics.
Soundness is not lost because the types are conservative in their approximation.

In the case of string replacement, there are \emph{trivial} definitions of substitution (on strings) and replacement (on languages) which over-approximate 
the effect of a substitution. Closing these gaps in approximation is important, and motivates the string operations portion of this technical report.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Substitution.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Some Corollaries About Substitution and Language Replacement}

\begin{defn}[$\tt{subst}$]
We consider several choices in the string operations section.
\end{defn}

\begin{defn}[$\tt{lreplace}$]
We consider several choices in the string operations section.
\end{defn}

\begin{prop}[Closure] \label{thm:total}
  If $\lang{r}, \lang{r_1}$ and $\lang{r_2}$ are regular languages, then $\lang{\lreplace{r}{r_1}{r_2}}$ is also a regular language.
\end{prop}
\begin{proof}
This result is proven for various formulations in the next section.
\end{proof}

\begin{prop}[Substitution Correspondence] \label{thm:substcorrespondence}
  If $s_1 \in \lang{r_1}$ and $s_2 \in \lang{r_2}$ then $\lsubst{r}{s_1}{s_2} \in \lang{\lreplace{r}{r_1}{r_2}}$.
\end{prop}
\begin{proof}
This is exactly the correctness result proven for some pairs of ${\tt subst}$ and ${\tt replace}$ in the previous section.
\end{proof}

\begin{ass}[Properties of Regular Languages.] \label{thm:regexprops}
~
\begin{enumerate}

\item If $s_1 \in \lang{r_1}$ and $s_2 \in \lang{r_2}$ then $s_1s_2 \in \lang{r_1\cdot r_2}$.
\item For all strings $s$ and regular expressions $r$, either $s \in \lang{r}$ or $s \not \in \lang{r}$.
\item Regular languages are closed under reversal.
\end{enumerate}
\end{ass}

Lemma~\ref{thm:regexprops} states some well-known properties about regular expressions.

%\begin{lem}
%  If $\emptyset \vdash e : \stringin{r}$ then $r$ is a well-formed regular expression.
%\end{lem}
%\begin{proof}
%  The proof proceeds by induction on the derivation of the premise.
%  The only non-trivial cases (those which require more than an appeal to inversion) are S-T-Case, S-T-Replace and S-T-Concat. 
%
%In the S-T-Case case, note that ${\sf lhead}$ and ${\sf ltail}$ are total functions for well-formed regular expressions to well-formed regular expressions.
%
%In the S-T-Concat case, note that Lemma~\ref{thm:total} implies that if $r_1$ and $r_2$ are regular expressions then so is $r_1 \cdot r_2$.
%
%In the S-T-Replace case, it suffices to show that $\lreplace{r}{r_1}{r_2}$ is a regular expression assuming (inductively) that $r, r_1$ and $r_2$ are all regular expressions.
%This follows from the Closure proposition.
%\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Type Safety and Security.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Small Step Semantics}

To prove type safety and the security theorems for the big step semantics, we
first prove type safety for a small step semantics in Figure~\ref{fig:sdlambdas}
and then extend this to the big step semantics in Figure~\ref{fig:dlambdas} by
proving a correspondence between the semantics.





%\newcommand{\therel}{R_{\stringin{r}}}
%\begin{trdef}[Relation over $\stringin{r}$]
%$\therel(e)$ iff $e$ halts and $\emptyset \vdash e : \stringin{r}$.
%\end{trdef}

%\begin{trconj}
%if $\Gamma \vdash e : \sigma$ then $e \mapsto^* v$ such that $v \ \val$.
%\end{trconj}
%%\begin{trthm}[Termination of small step semantics]
%%\end{trthm}
%%\begin{proof}
%We do not develop the full proof here, but note that the simply typed lambda calculus terminates.
%For the string fragment, observe that the S-T- rules do not add any non-trivial binding structure because substitutions
%$[e/x]e'$ may only occur in the special case where $e = \rstr{s}$, so that the length of the term
%never increases and the number of free variables strictly decreases. Therefore, the standard normalization
%argument proceeds without complication after fixing an evaluation order for the compatibility rules 
%(all our other proofs are agnostic to evaluation order).
%\end{proof}

\begin{trlem}[Canonical Forms]\label{cfgen}
If $\emptyset \vdash v : \sigma$ then:
\begin{enumerate}
\item If $\sigma = \stringin{r}$ then $u = \rstr{s}$.
\item If $\sigma = \sigma_1 \rightarrow \sigma_2$ then $v = \lambda x . e'$ and $s \in \lang{r}$.
\end{enumerate}

\end{trlem}
\begin{proof}
By inspection of valuation and typing rules.
\end{proof}

For the sake of completeness, we include a statement of the weaker lemma
stated in the paper:

\begin{lem}[Canonical Forms for the String Fragment of $\lambdas$]\label{thm:cfs}
  If $\emptyset \vdash e : \stringin{r}$ and $e \sreduces v$ then $v=\rstr{s}$. 
\end{lem}
\begin{proof}
This fact follows directly from Lemma~\ref{cfgen} and the preservation lemma.
\end{proof}



\begin{trlem}[Progress of small step semantics.]
If $\emptyset\vdash e : \sigma$ either $e = v$ or $e \mapsto e'$ for some $e'$.
\end{trlem}
\begin{proof}
The proof proceeds by induction on the derivation of $\emptyset\vdash e : \sigma$.
\begin{itemize}[label=$ $,itemsep=1ex]
\item \textbf{$\lambda$ fragment}. Cases SS-T-Var, SS-T-Abs, and SS-T-App are exactly as in a proof of progress for
the simply typed lambda calculus.

\item \textbf{S-T-Stringin-I}. Suppose $\emptyset\vdash \rstr{s} : \stringin{s}$.
Then $\rstr{s} \ \val$ by SS-E-RStr.

\item \textbf{S-T-Concat}. Suppose $\emptyset\vdash \rconcat{e_1}{e_2} : \stringin{r}$ and $\emptyset e_1 : \stringin{r_1}$ and $\emptyset \vdash e_2 : \stringin{r_2}$.
By induction, $e_1 \mapsto e_1'$ or $e_1 = v_1$ and similarly
for $e_2$. 
If $e_1$ steps, then SS-E-Concat-Left applies and so
$\rconcat{e_1}{e_2} \mapsto \rconcat{e_1'}{e_2}$. Similarly, if $e_2$ steps
then $e$ steps by SS-E-Concat-Right.

In the remaining case, $e_1 =v_1$ and $e_2 =v_2$.
But then it follows by Canonical Forms that $e_1 = \rstr{s_1}$
and $e_2 = \rstr{s_2}$.
Finally, by SS-E-Concat, $\rconcat{\rstr{s_1}}{\rstr{s_2}} \mapsto \rstr{s_1s_2}$.

\def\mline#1{\par\hspace*{-\leftmargin}\parbox{\textwidth}{\[#1\]}}
\item \textbf{S-T-Case}.
Suppose $e = \strcase{e_1}{e_2}{x,y.e_3}$ and $\emptyset\vdash e_1 : \stringin{r}$.
%\begin{align}
%&\vdash e_1 : \stringin{r} \\
%&\vdash e_2 : \sigma \\
%x:\stringin{\lhead{r}}, y : \stringin{\ltail{r}} &\vdash e_3 : \sigma
%\end{align}
%Actually this isn't even necessary...
%By (2), $e_2 \mapsto e_2'$ or $e_2 \val$. 
%In the former case, $e \mapsto \strcase{e_1}{e_2'}{x,y.e_3}$.
By induction and Lemma~\ref{thm:cfs} it follows that $e_1 \mapsto e_1'$ or $e_1 = \rstr{s}$.
In the former case, $e$ steps by S-E-Case-Left.
In the latter case, note that $s = \epsilon$ or $s = at$ for some string $t$.
If $s = \epsilon$ then $e$ steps by S-E-Case-$\epsilon$-Val,
and if $s = at$ the $e$ steps by S-E-Case-Concat.

\item \textbf{S-T-Replace}.
Suppose $e = \rreplace{r}{e_1}{e_2}$, $\emptyset\vdash e : \stringin{r'}$ and:
\begin{align}
&\emptyset\vdash e_1 : \stringin{r_1} \\
&\emptyset\vdash e_2 : \stringin{r_2} \\
&\lreplace{r}{r_1}{r_2} = r'
\end{align}

By induction on (1), $e_1 \mapsto e_1'$ or $e_1 = v_1$  for some $e_1'$.
If $e_1 \mapsto e_1'$ then $e$ steps by SS-E-Replace-Left.
Similarly, if $e_2$ steps then $e$ steps by SS-E-Replace-Right.
The only remaining case is where $e_1 = v_1$ and also $e_2 = v_2$.
By Canonical Forms, $e_1 = \strin{s_1}$ and $e_2 = \strin{s_2}$.
Therefore, $e \mapsto \rstr{\lsubst{r}{s_1}{s_2}}$ by SS-E-Replace.

\item \textbf{S-T-SafeCoerce}.
Suppose that $\emptyset\vdash \rcoerce{r}{e_1} : \stringin{r}$.
and
%\begin{align}
$\emptyset\vdash e_1 : \stringin{r'}$ for $\lang{r'} \subseteq \lang{r}$.% \\
%&\lang{r'} \subseteq \lang{r}
%\end{align}
By induction, $e_1 =v_1$ or $e_1 \mapsto e_1'$ for some $e_1'$.
If $e_1 \mapsto e_1'$ then $e$ steps by SS-E-SafeCoerce-Step.
Otherwise, $e_1 =v$ and by Canonical Forms $e_1 = \rstr{s}$.
In this case, $e = \rcoerce{r}{\rstr{s}} \mapsto \rstr{s}$ by SS-E-SafeCoerce.

\item \textbf{S-T-SafeCheck}
Suppose that $\emptyset\vdash \rcheck{r}{e_0}{x.e_1}{e_2} : \stringin{r}$ and:
\begin{align}
&\vdash e_0 : \stringin{r_0}  \\
x:\stringin{r} &\vdash e_1 : \sigma \\
&\vdash e_2 : \sigma \label{align6}
\end{align}

By induction,  $e_0 \mapsto e_0'$ or $e_0 = v$.
In the former case $e$ steps by SS-E-Check-StepRight.
Otherwise, $e_0 = \rstr{s}$ by Canonical Forms.
By Lemma~\ref{thm:regexprops} part 2, either $s \in \lang{r_0}$ or $s \not\in\lang{r_0}$.
In the former case $e$ takes a step by SS-E-Check-Ok.
In the latter case $e$ takes a step by SS-E-Check-NotOk.

\end{itemize}

\end{proof}

\begin{trlem}[Substitution] \label{lem:subst}
If $\Psi\ x : \sigma \vdash e : \sigma'$ and $\psi \vdash e' : \sigma$, then
$\psi \vdash [e' / x] e : \sigma'$.
\end{trlem}

\begin{trlem}[Preservation for Small Step Semantics]
If $\emptyset \vdash e : \sigma$ and $e \mapsto e'$ then $\emptyset \vdash e' : \sigma$.
\end{trlem}
\begin{proof}

By induction on the derivation of $e \mapsto e'$ and $\emptyset \vdash e : \sigma$.

\begin{itemize}[label=$ $,itemsep=1ex]
\item \textbf{$\lambda$ fragment}. Cases SS-T-Var, SS-T-Abs, and SS-T-App are exactly as in a proof of type safety for
the simply typed lambda calculus.

\item \textbf{SS-E-Concat-Left}.
Suppose $e = \rconcat{e_1}{e_2} \mapsto \rconcat{e_1'}{e_2}$ and $e_1 \mapsto e_1'$.
The only rule that applies is S-T-Concat, so $\emptyset\vdash e_1 : \stringin{r_1}$ and $\emptyset\vdash e_2 : \stringin{r_2}$.
By induction, $\emptyset\vdash e_1' : \stringin{r_1}$.
Therefore, by S-T-Concat, $\emptyset\vdash \rconcat{e_1'}{e_2} : \stringin{r_1r_2}$.

\item {\textbf{SS-E-Concat-Right}}. 
Suppose $e = \rconcat{e_1}{e_2} \mapsto \rconcat{e_1}{e_2'}$ and $e_2 \mapsto e_2'$.
The only rule that applies is S-T-Concat, so $\emptyset\vdash e_1 : \stringin{r_1}$ and $\emptyset\vdash e_2 : \stringin{r_2}$.
By induction, $\emptyset\vdash e_2' : \stringin{r_2}$.
Therefore, by S-T-Concat, $\emptyset\vdash \rconcat{e_1}{e_2'} : \stringin{r_1r_2}$.


\item \textbf{SS-E-Concat}. 
Suppose $\rconcat{\rstr{s_1}}{\rstr{s_2}} \mapsto \rstr{s_1s_2}$.
The only applicable rule is S-T-Concat, so 
$\emptyset\vdash\rstr{s_1} : \stringin{r_1}$ 
and
$\emptyset\vdash\rstr{s_2} : \stringin{r_2}$. 
By Lemma~\ref{lem:cfs}, $s_1 \in \lang{r_1}$ and $s_2 \in  \lang{r_2}$ from which it follows by Lemma~\ref{thm:regexprops}
that $s_1s_2 \in \lang{r_1r_2}$. Therefore, $\emptyset\vdash \rstr{s_1s_2} : \stringin{r_1r_2}$ by S-T-Rstr.

\item \textbf{S-E-Case-Left}.
Suppose 
$e \mapsto \strcase{e_1'}{e_2}{x,y.e_3}$
and $\emptyset \vdash e : \sigma$ and $e_1 \rightarrow e_1'$.
The only rule that applies is S-T-Case, so:
\begin{align}
\emptyset&\vdash e_1 : \stringin{r} \label{align7} \\
\emptyset&\vdash e_2 : \sigma \label{align8} \\ 
x:\stringin{\lhead{r}}, y : \stringin{\ltail{r}} &\vdash e_3 : \sigma \label{align9}
\end{align}
By (\ref{align7}) and the assumption that $e_1 \mapsto e_1'$, it follows by induction that $\emptyset\vdash e_1' : \stringin{r}$.
This fact together with (\ref{align8}) and (\ref{align9}) implies by S-T-Case that
$\emptyset\vdash\strcase{e_1'}{e_2}{x,y.e_3} : \sigma$.

%\item \textbf{SS-E-Case-Right}. 
%We have that $e = \strcase{e_1}{e_2}{x,y.e_3}$, Suppose $e \mapsto \strcase{e_1}{e_2'}{x,y.e_3}$
%and $\emptyset \vdash e : \stringin{r}$.
%By inversion of S-T-Case:
%\begin{align}
%\emptyset&\vdash e_1 : \stringin{r} \label{align10}\\
%\emptyset&\vdash e_2 : \sigma \label{align11} \\ 
%x:\stringin{\lhead{r}}, y : \stringin{\ltail{r}} &\vdash e_3 : \sigma \label{align12}
%\end{align}
%By (\ref{align11}) and the assumption that $e_2 \mapsto e_2'$, it follows by induction that $\emptyset\vdash e_2' : \stringin{r}$.
%This fact together with (\ref{align10}) and (\ref{align12}) implies by S-T-Case that 
%$\emptyset\vdash\strcase{e_1}{e_2'}{x,y.e_3} : \sigma$.

\item \textbf{SS-E-Case-$\epsilon$-Val}.
Suppose: \begin{align*}
&e = \strcase{e_0}{e_2}{x,y.e_3} \\
&\emptyset\vdash e: \sigma \\
&e \mapsto e_2
\end{align*}
The only rule htat applies is S-T-Case, so $e_2 : \sigma$.

\item \textbf{SS-E-Case-Concat}.
Suppose that $e = \strcase{\rstr{as}}{e_2}{x,y.e_3} \mapsto [\rstr{a}, \rstr{s} / x,y] e_3$
and that $\emptyset\vdash e : \sigma$.
By inversion of S-T-Case:
\begin{align}
\emptyset&\vdash \rstr{as} : \stringin{r} \label{align13}\\
\emptyset&\vdash e_2 : \sigma \label{align14} \\ 
x:\stringin{\lhead{r}}, y : \stringin{\ltail{r}} &\vdash e_3 : \sigma \label{align15}
\end{align}

We know that $as \in \lang{r}$ by canonical forms on (\ref{align13}) 
Therefore, $a \in \lang{\lhead{r}}$ by definition of ${\sf lhead}$.
Furthermore, $\ltail{r} = ... + \delta_a{r} + ...$ by definition of ${\sf ltail}$.
Note that $s \in \lang{\delta_a{r}}$ by definition of the derivative, and so
$s \in \lang{\ltail{r}}$

From these facts about $a$ and $s$ we know by S-T-Rstr that $\emptyset\vdash \rstr{a} : \stringin{\lhead{r}}$
and $\emptyset\vdash \rstr{s} : \stringin{\lhead{r}}$.
It follows by (\ref{lem:subst}) that  $\emptyset\vdash [\rstr{a}, \rstr{s} / x,y] e_3 : \sigma$.

\item \textbf{Cases SS-E-Replace-Left, SS-E-Replace-Right, SS-E-Check-StepLeft, SS-E-SafeCoerce-Step, SS-E-Check-StepRight}. \todo{todo}

\item \textbf{Case SS-E-Replace}.

Suppose $e = \rreplace{r}{\rstr{s_1}}{\rstr{s_2}} \mapsto \rstr{\lsubst{r}{s_1}{s_2}}$.
The only applicable rule is 
S-T-Replace, so
\begin{align*}
\emptyset &\vdash \rstr{s_1} : \stringin{r_1} \\
\emptyset &\vdash \rstr{s_2} : \stringin{r_2}
\end{align*}
By conanical forms,
$s_1 \in \lang{r_1}$ and $s_2 \in \lang{r_2}$.
Therefore, $\lreplace{r}{s_1}{s_2} \in \lang{\lreplace{r}{r_1}{r_2}}$ by Theorem~\ref{thm:substcorrespondence}.
It is finally derivable by S-T-Rstr that:

$\emptyset \vdash \rstr{\lreplace{r}{s_1}{s_2}} : \stringin{\lreplace{r}{r_1}{r_2}}$.


\item \textbf{Case SS-E-SafeCoerce}.
Suppose that $\rcoerce{r}{\rstr{s_1}} \mapsto \rstr{s_1}$.
The only applicable rule is S-T-SafeCoerce, so 
$\emptyset\vdash \rcoerce{r}{s_1} : \stringin{r}$.
By Canonical Forms, $s \in \lang{r}$. Therefore, $\emptyset\vdash \rstr{s} : \stringin{r}$.

\item \textbf{Case SS-E-Check-Ok}.
Suppose $\rcheck{r}{\rstr{s}}{x.e_1}{e_2} \mapsto \subst{\rstr{s}}{x}{e_1}$,
$s \in \lang{r}$, and $\emptyset \vdash \rcheck{r}{\rstr{s}}{x.e_1}{e_2} : \sigma$.
By inversion of S-T-Check, $x : \stringin{r} \vdash e_1 : \sigma$.
Note that $s \in \lang{r}$ implies that $s : \stringin{r}$ by S-T-RStr.
Therefore, $\emptyset \vdash \subst{\rstr{s}}{x}{e_1} : \sigma$.

\item \textbf{Case SS-E-Check-NotOk}.
Suppose $\rcheck{r}{\rstr{s}}{x.e_1}{e_2} \mapsto e_2$,
$s \not \in \lang{r}$, and $\emptyset \vdash \rcheck{r}{\rstr{s}}{x.e_1}{e_2} : \sigma$.
The only applicable rule is S-T-Check, so $\emptyset \vdash e_2 : \sigma$.

\end{itemize}
\end{proof}


\begin{trthm}[Type Safety for small step semantics.] \label{thm:sstypesafte}
If $\emptyset\vdash e : \sigma$ then either $e \ \val$ or $e \mapsto^* e'$ and $\emptyset\vdash e' : \sigma$.
\end{trthm}
\begin{proof}
Follows directly from progress and preservation.
\end{proof}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BEGIN THE SEMANTIC CORRESPONDENCE ARGUMENT FOR LAMBDA_RS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Semantic Correspondence between Big and Small Step Semantics for $\lambdas$}

Before extending the previous theorem to the big step semantics, we first establish a correspondence between
the big step semantics in Figure~\ref{fig:sdlambdas} and the small step semantics in Figure~\ref{fig:dlambdas}.

\begin{trthm}[Semantic Correspondence for $\lambdas$ (Part I)]
If $e \sreduces v$ then $e \mapsto^* v$.  
\end{trthm}
\begin{proof}
We proceed by structural induction on $e$.

\begin{itemize}[label=$ $,itemsep=1ex]

% Abstraction case.
\item \textbf{Case $e = \lambda x . e_1$}. 
The only applicable rule is S-E-Abs, so $v = \lambda x . e_1$.
Note that $\lambda x . e_1 \mapsto^* \lambda x . e_1$ by RT-Refl.

% Application case.
\item \textbf{Case $e=e_1(e_2)$}.
The only applicable rule is S-E-App. By inversion, we establish that the following:
\begin{align*}
  e_1 &\sreduces \lambda x.e_1' \\
  e_2 &\sreduces v_2 \\
  [v_2/x]e_1' &\sreduces v
\end{align*}

From which it follows by induction that:
\begin{align*}
  e_1 &\mapsto^* \lambda x.e_1'  \\
  e_2 &\mapsto^* v_2 \\
  [v_2/x]e_1' &\mapsto^* v
\end{align*}

Note that the following rule is derivable by repeating applications of the left and right compatibility rules for application:
\begin{mathpar}
\inferrule[L*-App]
{ e_1 \mapsto^* e_1' \\ e_2 \mapsto^* e_2'  }
{ e_1(e_2) \mapsto^* e_1'(e_2') }
\end{mathpar}

From these facts and L-AppAbs, we may establish that $e_1(e_2) \mapsto^* ( \lambda x.e_2 )(v_2) \mapsto [v_2/x]e_2$.
Note that $[v_2/x]e_2 \mapsto^* v$, so by RT-Trans it follows that $e = e_1(e_2) \mapsto^* v$.

% String Values
\item \textbf{Case $e = \strin{s}$}. The only applicable rule is S-E-RStr, so $v = \strin{s}$.
By RT-Refl, $\strin{s} \mapsto^* \strin{s}$.

% String Concatenation.
\item \textbf{Case $e=\rconcat{e_1}{e_2}$}. 
The only applicable rule is S-E-Concat, so $v = \rstr{s_1s_2}$.
By inversion, $e_1 \sreduces \strin{s_1}$ and $e_2 \sreduces \strin{s_2}$.
By induction, $e_1 \mapsto^* \strin{s_1}$ and $e_2 \mapsto^* \strin{s_2}$.
Note that the rule following is derivable:
\begin{mathpar}
\inferrule[SS-E-Concat-LR*]
{ e_1 \mapsto^* e_1' \\ e_2 \mapsto^* e_2'  }
{ \rconcat{e_1}{e_2} \mapsto^* \rconcat{e_1'}{e_2'} }
\end{mathpar}

From these facts, it follows that $\rconcat{e_1}{e_2} \mapsto^* \rconcat{\strin{s_1}}{\strin{s_2}}$.
Finally, $\rconcat{\strin{s_1}}{\strin{s_2}} \mapsto \strin{s_1s_2}$ by SS-E-Concat.
By RT-Step, it follows that $\rconcat{e_1}{e_2} \mapsto^* \strin{s_1s_2}$.

%Strcase Case.
\item \textbf{Case $e=\strcase{e_1}{e_2}{x,y.e_3}$}.

There are two subcases. For the first, suppose $\strcase{e_1}{e_2}{x,y.e_3} \sreduces v$ was finally derived by S-E-Case-$\epsilon$.
By inversion: 
\begin{align*}
e_1 &\sreduces \strin{\epsilon} \\
e_2 &\sreduces v
\end{align*}
from which it follows by induction that:
\begin{align*}
e_1 &\mapsto^* \strin{\epsilon} \\
e_2 &\mapsto^* v
\end{align*}

Note that the following rule is derivable:

\begin{mathpar}
\inferrule[SS-E-Case-LR*]
{ e_1 \mapsto^* e_1' \\ e_2 \mapsto^* e_2'  }
{ \strcase{e_1}{e_2}{x,y.e_3} \mapsto^* \strcase{e_1'}{e_2'}{x,y.e_3} }
\end{mathpar}

From these facts is follows that $e \mapsto^* \strcase{\strin{\epsilon}}{v}{x,y.e_3}$.
By S-E-Case-$\epsilon$-Val and RT-Step it follows that $e \mapsto^* v$.

Now consider the other case where $\strcase{e_1}{e_2}{x,y.e_3} \sreduces v$ was finally derived by S-E-Case-Concat.
By inversion, 
$e_1 \sreduces \strin{as}$ and $[\strin{a}, \strin{s} / x, y]e_3 \sreduces v$. 
From these facts it follows by induction that 
$e_1 \mapsto^* \strin{as}$ and
$[\strin{a}, \strin{s} / x, y]e_3 \mapsto^* v$.

By the first of these facts, it is derivable via SS-E-Case-LR* that 
$e \mapsto^* \strcase{e_1'}{\strin{as}}{x,y.e_3}$.
SE-E-Case-Concat applies to this form, so by RT-Step we know $e \mapsto^* [\strin{a}, \strin{s} / x, y]e_3$.
Recall that $[\strin{a}, \strin{s} / x, y]e_3 \mapsto^* v$, so by RT-Trans we finally derive $e \mapsto^* v$.

% String Replacement.
\item \textbf{Case $e=\rreplace{r}{e_1}{e_2}$}.
There is only one applicable rule, so $v = \rstr{s}$ and by inversion it follows that:
\begin{align*}
e_1 &\sreduces \rstr{s_1} \\
e_2 &\sreduces \rstr{s_2}
\end{align*}

From which it follows by induction that:
\begin{align*}
e_1 &\mapsto^* \rstr{s_1} \\
e_2 &\mapsto^* \rstr{s_2}
\end{align*}

Furthermore, $\lsubst{r}{s_1}{s_2} = s$ by induction.
Note that the following rule is derivable:

\begin{mathpar}
\inferrule[SS-E-Replace-LR*]
{ e_1 \mapsto^* e_1' \\ e_2 \mapsto^* e_2'  }
{ \rreplace{r}{e_1}{e_2} \mapsto^* \rreplace{r}{e_1'}{e_2'} }
\end{mathpar}

From these facts, $\rreplace{r}{e_1}{e_2} \mapsto^* \rreplace{r}{\rstr{s_1}}{\rstr{s_2}}$.

Finally, $\rreplace{r}{\rstr{s_1}}{\rstr{s_2}} \mapsto \lsubst{r}{s_1}{s_2}$.

From these two facts we know via RT-Step that $\rreplace{r}{e_1}{e_2} \mapsto^* \rreplace{r}{e_1}{e_2}$.
Recall that $\lsubst{r}{s_1}{s_2} = s$, from which the conclusion follows.

\item \textbf{Case $e = \rcoerce{r}{e_1}$}.
In this case $e \sreduces v$ is only finally derivable via S-E-SafeCoerce.
Therefore, $v = \strin{s}$ and by inversion $e_1 \sreduces \strin{s}$.
By induction, $e_1 \mapsto^* \strin{s}$.

The following rule is derivable:

\begin{mathpar}
\inferrule[SS-E-SafeCoerce-Step]
{ e \mapsto^* e' }
{ \rcoerce{r}{e} \mapsto^* \rcoerce{r}{e'} }
\end{mathpar}

Applying this rule at $e_1 \mapsto^* \strin{s}$ derives $\rcoerce{r}{e_1} \mapsto^* \rcoerce{r}{\strin{s}}$.
In the final step, $\rcoerce{r}{\strin{s}} \mapsto \strin{s}$ by SS-E-SafeCoerce.
From this fact, we may derive via RT-Trans that $e \mapsto^* \strin{s}$ as required.

\item \textbf{Case $e = \rcheck{r}{e_1}{x.e_2}{e_3}$}.

Note that the rule following is derivable:

\begin{mathpar}
\inferrule[SS-E-Check-Step]
{ e_1 \mapsto^* e_1' \\ e_3 \mapsto^* e_3' }
{ \rcheck{r}{e_1}{x.e_2}{e_3} \mapsto^* \rcheck{r}{e_1'}{x.e_2}{e_3'} }
\end{mathpar}

There are two ways to finally derive $e \sreduces v$.
In both cases, $e_1 \sreduces \strin{s}$ by inversion.
Therefore, in both cases, $e_1 \mapsto^* \strin{s}$ by induction
and so $e \mapsto^* \rcheck{r}{\strin{s}}{x.e_2}{e_3}$ by SS-E-Check-Step.

Suppose $e \sreduces v$ is finally derived via SS-E-Check-Ok.
By the facts mentioned above and SS-E-Check-Step, $e \mapsto^* \rcheck{r}{\strin{s}}{x.e_2}{e_2}$.
Note that by inversion $s \in \lang{r}$. Therefore, SS-E-Check-Ok applies and so by RT-Trans $e \mapsto^* [\rstr{s}/x]e_1$.
By inversion, $[\strin{s}/x]e_1 \sreduces v$. Therefore, by induction and RT-Step $e \mapsto^* v$ as required.

Suppose that $e \sreduces v$ is instead finally derived via SS-E-Check-NotOk.
By inversion, $e_3 \sreduces v$ and by induction $e_3 \mapsto^* v$.
From these facts at SS-E-Check-Step, it is derivable that $e \mapsto^* \rcheck{r}{\strin{s}}{x.e_2}{v}$.

Also by inversion, $s \not \in \lang{r}$ and so SS-E-Check-NotOk applies.
Therefore, $\rcheck{r}{\strin{s}}{x.e_2}{v} \mapsto v$. 

The conclusion $e \mapsto^* v$ follows from these facts by RT-Step.
\end{itemize}
\end{proof}
%% Abstraction case.
%\item \textbf{Case $e = \lambda x . e_1$}. 
%% String Values
%\item \textbf{Case $e = \strin{s}$}. 
%% String Concatenation.
%\item \textbf{Case $e=\rconcat{e_1}{e_2}$}. 
%%Strcase Case.
%\item \textbf{Case $e=\strcase{e_1}{e_1}{x,y.e_3}$}.
%% String Replacement.
%\item \textbf{Case $e=\rreplace{r}{e_1}{e_2}$}.
%% Coercion
%\item \textbf{Case $e = \rcoerce{r}{e_1}$}.
%% Replacement
%\item \textbf{Case $e = \rcheck{r}{e_1}{x.e_2}{e_3}$}.


%Establishing the other direction requires a minor lemma about the relationship between values and reflexivity in the big step semantics.
%
%\begin{trthm}[Small Step Values are Reflexive in the Big Step Semantics]
%If $v \ \val$ in the small step semantics then $v \sreduces v$.
%\end{trthm}
%\begin{proof}
%If $v \ \val$ is derived from SS-E-RStr then S-E-RStr establishes the result.
%Otherwise $v \ \val$ is derived from SS-E-Abs and so S-E-Abs establishes the result.
%\end{proof}

\begin{trthm}[Semantic Correspondence for $\lambdas$ (Part II)]
If $\emptyset\vdash e : \sigma$, $e \mapsto^* v$ and $v \ \val$ then $e \sreduces v$.  
\end{trthm}
\begin{proof}
The proof proceeds by structural induction on $e$.

\begin{itemize}[label=$ $,itemsep=1ex]

\item \textbf{Case $e = \concat{e_1}{e_2}$}.
By inversion, $\emptyset\vdash e_1 : \stringin{r_1}$.
By Type Safety, Canonical Forms and Termination it follows that $e_1 \mapsto^* \rstr{s_1}$ for some $s_1$.
By induction, $e_1 \sreduces \rstr{s_1}$.

Similarly, $e_2 \mapsto^* \rstr{s_2}$ and $e_2 \sreduces \rstr{s_2}$.

Note that $\concat{e_1}{e_2} \mapsto^* \concat{\rstr{s_1}}{\rstr{s_2}} \mapsto \rstr{s_1s_2}$ by SS-E-Concat-LR* and S-E-Concat.
Therefore, $e \mapsto^* \rstr{s_1s_2}$ by RT-Step. So it suffices to show that $e \sreduces \rstr{s_1s_2}$.

Finally, $e \sreduces \rstr{s_1s_2}$ follows via S-E-Concat from the facts that $e_1 \sreduces \rstr{s_1}$ and $e_2 \sreduces \rstr{s_2}$.
This completes the case. 

\item \textbf{Case $e = \rreplace{r}{e_1}{e_2}$}.
By inversion of S-T-Replace, $\emptyset\vdash e_1 : \stringin{r_1}$ for some $r_1$.
It follows by Type Safety, Termination and Canonical Forms that $e_1 \mapsto^* \rstr{s_1}$.
By induction, $e_1 \sreduces \rstr{s_1}$.

Similarly, $e_2 \mapsto^* \rstr{s_2}$ and $e_2 \sreduces \rstr{s_2}$.

Note that $e \mapsto^* \rreplace{r}{\rstr{s_1}}{\rstr{s_2}} \mapsto \rstr{\lsubst{r}{s_1}{s_2}}$ by SS-Replace-LR* and SS-E-Replace.
Therefore $e \mapsto^* \rstr{\lsubst{r}{s_1}{s_2}}$ by RT-Step. 

It suffices to show $e \sreduces \rstr{\lsubst{r}{s_1}{s_2}}$, which follows by S-E-Replace from the facts that $e_1 \sreduces \rstr{s_1}$ and
$e_2 \sreduces \rstr{s_2}$.


\item \textbf{Case $e = \strcase{e_1}{e_2}{x.y.e_3}$}.
By inversion, $\emptyset\vdash e_1 : \stringin{r}$ and $e_2 : \sigma$.
By Type Safety, Canonical Forms and Termination $e_1 \mapsto^* \stringin{s_1}$ and by induction $e_1 \sreduces \stringin{s_1}$.
Similarly, $e_2 \mapsto^* v_2$ and $\emptyset\vdash e_2 \sreduces v_2$.

By SS-E-Case-LR*, $\strcase{e_1}{e_2}{x,y.e_3} \mapsto^* \strcase{v_1}{v_2}{x,y.e_3}$.

Note that either $s_1 = \epsilon$ or $s_1 = as$ because we define strings as either empty or finite sequences of characters.
We proceed by cases.

If $s_1 = \epsilon$ then $\strcase{v}{v_2}{x,y.e_3} \mapsto v_2$ by SS-E-Case-$\epsilon$.
Therefore, by RT-Step, $e \mapsto^* v_2$.
Recall $e_1 \sreduces \strin{\epsilon}$ and $e_2 \sreduces v_2$, which is enough to establish by S-E-Case-$\epsilon$ that $e \sreduces v_2$.

If $s_1 = as$ instead, then $\strcase{\strin{s_1}}{v_2}{x,y.e_3} \mapsto [\strin{a},\strin{s} / x,y ] e_3$ by SS-E-Case-Concat.
Inversion of the typing relation satisfies the assumptions necessary to appeal to termination.
Therefore,

%\todo{Note that this substitution does not modify the syntactic structure of $e_3$ except by replacing free variables wit strings, and so} by induction,
\[ [\strin{a},\strin{s} / x,y ] e_3 \mapsto^* v \text{ for } v \ \val. \]

It follows by RT-Step that $e \mapsto^* v$.

Note that the substitution does not change the structure of $e_3$.
So by induction, $[\strin{a},\strin{s} / x,y ] e_3 \sreduces v$.
Recall that $e_1 \sreduces \strin{s_1}$ and so by S-E-Case it follows that $e \sreduces [a,s / x,y] e_3 \sreduces v$.
\end{itemize}

\todo{The cases for coercion and checking are straightforward.}
\end{proof}


\subsection{Extension of Safety for Small Step Semantics}

\begin{thm}[Type Safety] \label{thm:typesafety}
  If $\emptyset \vdash e : \sigma$ 
  and $e \sreduces e'$ then $\emptyset \vdash e' : \sigma$.
\end{thm}
\begin{proof}
If $\emptyset \vdash e : \sigma$ then $e \mapsto^* e'$.
Therefore, $e \sreduces e'$ by part 2 of the semantic correspondence theorem.

Since $\emptyset \vdash e : \sigma$ and $e \mapsto^* e'$, it follows that $\emptyset \vdash e' : \sigma$ by type safety for the small step semantics.
\end{proof}



\subsubsection{The Security Theorem}\label{sec:securitythm}

\begin{thm}[Correctness of Input Sanitation for $\lambdas$]\label{thm:scorrect}
  If  $\emptyset \vdash e : \stringin{r}$ and $e \sreduces \rstr{s}$ then $s \in \lang{r}$.
\end{thm}
\begin{proof}
If $\emptyset \vdash e : \stringin{r}$ and $e \sreduces \rstr{s}$ then $\emptyset \vdash \rstr{s} : \stringin{r}$ by Type Safety.
By Caonical Forms, $s \in \lang{r}$.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Proofs of Lemmas and Theorems About $\lambdap$}


\begin{thm}[Safety for $\lambdap$] If $\emptyset \vdash \iota : \tau$ 
  then $\iota \sreduces \dot v$ and $\emptyset \vdash \dot v : \tau$.
\end{thm}

We can also define canonical forms for regular expressions and strings in the usual way:


\begin{lem}[Canonical Forms for Target Language]
~
\begin{itemize}
\item 
If $\emptyset \vdash \iota : \regex$ then $\iota \treduces \rx{r}$ such that $r$ is a well-formed regular expression. 
\item 
If $\emptyset \vdash \iota : \str$ then $\iota \treduces \tstr{s}$.
\end{itemize}
\end{lem}


\section{Proofs and Lemmas and Theorems About Translation}


\begin{thm}[Translation Correctness]\label{thm:trcorrect}
  If $\tctx \vdash e : \sigma$ then 
  there exists an $\iota$ such that $\trden{e} = \iota$
  and $\trden{\tctx} \vdash \iota : \trden{\sigma}$.
  Furthermore, $e \sreduces v$ and
  $\iota \treduces \dot{v}$ such that
  $\trden{v} = \dot{v}$.
\end{thm}
\begin{proof}
We present a proof by induction on the derivation that $\tctx \vdash e : \sigma$.
we write $e \leadsto \iota$ as shorthand for the final property.

\begin{itemize}[label=$ $, itemsep=1ex]
\item \textbf{Case $e = \rstr{s}$}. Suppose $\tctx \vdash \rstr{s} : \sigma$.

By examination the syntactic structure of conclusions in the relation S-T, 
we know this is true just in case $\sigma = \stringin{r}$ for some $r$ such that
$s \in \lang{r}$; and of course, there is always such an $r$.

There are no free variables in $\rstr{s}$, so we might as well proceed from the
fact that $\emptyset \vdash \rstr{s} : \stringin{r}$.

By definition of the translation ($\trden{\cdot}$) the following statements hold:
\begin{align}
\trden{\rstr{s}} &= \str{s} \\
\trden{\stringin{r}} &= \str \\
\trden{\emptyset} &= \emptyset
\end{align}
Note that $\emptyset \vdash \str{s} : \str$ by P-T-Str.
Recall that contexts are standard and, in particular, can be weakened.
So since $\trden{\tctx}$ is either a weakening of $\emptyset$ or $\emptyset$ itself,
$\trden{\tctx} \vdash \tstr{s} : \str$ by weakening.

Summarily, $\str{s}$ is a term of $\lambdap$ such that $\trden{\tctx} \vdash \str{s} : \trden{\sigma}$

It remains to be shown that there exist $v, \dot{v}$ such that $\rstr{s} \sreduces v$,
$\str{s} \treduces \dot{v}$, and $\trden{v} = \dot{v}$. But this is immediate because
each term evaluates to itself and we have already established the equality.

\item \textbf{Case $e = \rconcat{e_1}{e_2}$}. This case is an obvious appeal to induction.

\item \textbf{Case $e = \strcase{e_1}{e_2}{x,y.e_3}$}. This case relies on our definition
of context translation.

Suppose $\sctx \vdash \strcase{e_1}{e_2}{x,y.e_3} : \sigma$.
By inversion of the typing relation it follows that
$\sctx \vdash e_1 : \stringin{r}$, $\sctx \vdash e_2 : \sigma$ and $\sctx, x : \stringin{\lhead{r}}, y : \stringin{\ltail{r}} \vdash e_3 : \sigma$.

By induction, there exists an $\iota_1$ such that $\trden{e_1} = \iota_1$,
$\trden{\sctx} \vdash \iota_1 : \trden{\sigma}$, and $e_1 \leadsto \iota_1$.
Similarly for $e_2$ and some $\iota_2$.

By canonical forms, $e_1 \sreduces \rstr{s}$ and so $\iota_1 \treduces \tstr{s}$ by $\leadsto$.

Choose $\iota = \tconcat{\iota_1}{\iota_2}{x,y.\iota_3}$ and note that by the properties established via induction,
$\trden{e} = \iota$ and $\trden{\sctx} \vdash \iota : \trden{\sigma}$.

Suppose $s = \epsilon$. Then $e \sreduces v$ where $e_2 \sreduces v$
and $\iota \treduces \dot{v}$ where $\iota_2 \treduces \dot{v}$.
But recall that $e_2 \leadsto v_2$ and so $\trden{v} = \dot{v}$.

Suppose otherwise that $s = at$ for some character $a$ and string $t$.
Then $e \sreduces v$ where $[a, t / x, y] e_3 \sreduces v$.
Similarly, $\iota \treduces \dot{v}$ where $[a, t / x, y] \iota_3 \treduces \dot{v}$

\end{itemize}
\end{proof}

\begin{thm}[Correctness of Input Sanitation for Translated Terms]\label{thm:main}
  If $\trden{e} = \iota$ and $\emptyset \vdash e : \stringin{r}$ then $\iota \sreduces \tstr{s}$
  for $s \in \lang{r}$.
\end{thm}
\begin{proof}
  By Theorem \ref{thm:trcorrect} and the rules given, $\iota \sreduces \tstr{s}$ implies that $e \sreduces \strin{s}$.
  Theorem \ref{thm:scorrect} together with the assumption that $e$ is well-typed implies that $s \in \lang{r}$.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\renewcommand{\grammarlabel}[2]{#1\hfill#2}
\begin{figure}[b]
\small
  \begin{grammar}
<$r$> ::= $\epsilon$ | $.$ | $a$ | $r \cdot r$ | $r + r$ | $r*$ \hfill $a \in \Sigma$

\caption{Regular expressions over the alphabet $\Sigma$.}
\label{fig:regex}
\end{grammar}
\end{figure}
\begin{figure}[t]
\small
  \begin{grammar}
<$\sigma$> ::=  $\sigma \rightarrow \sigma$ | $\stringin{r}$    \hfill  source types

<$e$> ::= 
      $x$ | $v$ \hfill source terms \alt 
      $\rsconcat{e}{e}$ | $\strcase{e}{e}{x,y.e}$ \hfill $s \in \Sigma^{*}$ \alt
      $\sisubst{r}{e}{e}$ | $\rcoerce{r}{e}$ | $\rcheck{r}{e}{x.e}{e}$

<$v$> ::= $\lambda x . e$ | $\strin{s}$ \hfill source values 
\caption{Syntax of $\lambda_{RS}$.}
\label{fig:glambdas}
\end{grammar}
\end{figure}


\renewcommand{\grammarlabel}[2]{#1\hfill#2}

\begin{figure}[t]
\small
  \begin{grammar}

<$\tau$> ::= $\tau \rightarrow \tau$ | $\str$ | $\regex$ \hfill target types

<$\iota$> ::= $x$ | $\dot{v}$ \hfill target terms \alt
$\tconcat{\iota}{\iota}$ | $\pstrcase{\iota}{\iota}{x,y.\iota}$ \alt
  $\rx{r}$ | $\preplace{\iota}{\iota}{\iota}$ | $\tcheck{\iota}{\iota}{\iota}{\iota}$ 

  <$\dot{v}$> ::= $\lambda x . \iota$ | $\tstr{s}$ | $\rx{r}$ \hfill target values

\end{grammar}
\caption{Syntax for the target language, $\lambdap$, containing strings and statically constructed regular expressions.}
\label{fig:lcsSyntax}
\end{figure}


\begin{figure}[t]
\small
$\fbox{\inferrule{}{\sctx \vdash e : \sigma}}$
~~~~$\sctx ::= \emptyset \pipe \sctx, x : \sigma$
\begin{mathpar}
\inferrule[S-T-Var]
{ x:\sigma \in \sctx }
{ \sctx \vdash x:\sigma}

\inferrule[S-T-Abs]
{\sctx, x : \sigma_1 \vdash e : \sigma_2}
{\sctx \vdash \lambda x.e : \sigma_1 \rightarrow \sigma_2}

\inferrule[S-T-App]
{\sctx \vdash e_1 : \sigma_2 \rightarrow \sigma \\ \sctx \vdash e_2 : \sigma_2}
{\sctx \vdash e_1(e_2) : \sigma}
  
\inferrule[S-T-Stringin-I]
{s \in \lang{r}}
{\sctx \vdash \strin{s} : \stringin{r}}

\inferrule[S-T-Concat]
{\sctx \vdash e_1 : \stringin{r_1} \\ \sctx \vdash e_2 : \stringin{r_2}}
{\sctx \vdash \rsconcat{e_1}{e_2} : \stringin{r_1 \cdot r_2}}

\inferrule[S-T-Case]
{ \sctx \vdash e_1 : \stringin{r} \\
  \sctx \vdash e_2 : \sigma \\
  \sctx, x : \stringin{\lhead{r}}, y : \stringin{\ltail{r}} \vdash e_3 : \sigma
}
{
  \sctx \vdash \strcase{e_1}{e_2}{x,y.e_3} : \sigma
}

\inferrule[S-T-Replace]
{\sctx \vdash e_1 : \stringin{r_1} \\ \sctx \vdash e_2 : \stringin{r_2} }
{\sctx \vdash \sisubst{r}{e_1}{e_2} : \stringin{\lreplace{r}{r_1}{r_2}}}

\inferrule[S-T-SafeCoerce]
{\sctx \vdash e : \stringin{r'} \\ \lang{r'} \subseteq \lang{r}}
{\sctx \vdash \coerce{r}{e} : \stringin{r}}

\inferrule[S-T-Check]
{\sctx \vdash e_0 : \stringin{r_0} \\ \sctx, x:\stringin{r} \vdash e_1 : \sigma \\ \sctx \vdash e_2 : \sigma}
{\sctx \vdash \rcheck{r}{e_0}{x.e_1}{e_2} : \sigma}
\end{mathpar}

\caption{Typing rules for $\lambdas$. 
The typing context $\sctx$ is standard.}
\label{fig:slambdas}
\end{figure}


\begin{figure}
  \small
$\fbox{\inferrule{}{e \sreduces v}}$
\begin{mathpar}
\inferrule[S-E-Abs]                                                             
{ \ }                                                                           
{\lambda x.e \sreduces \lambda x.e}                                             

\inferrule[S-E-App]
{ e_1 \sreduces \lambda x . e_3 \\ e_2 \sreduces v_2 \\ [ v_2 / x ] e_3 \sreduces v }
{ e_1(e_2) \sreduces v }

\inferrule[S-E-RStr]
{ \ }
{\strin{s} \sreduces \strin{s}}

\inferrule[S-E-Concat]
{e_1 \sreduces \strin{s_1} \\ e_2 \sreduces \strin{s_2}} 
{\rsconcat{e_1}{e_2} \sreduces \strin{s_1 s_2}} % ???

\inferrule[S-E-Case-$\epsilon$]
{
  e_1 \sreduces \strin{\epsilon} \\
  e_2 \sreduces v_2
}
{
  \strcase{e_1}{e_2}{x,y.e_3} \sreduces v_2
}

\inferrule[S-E-Case-Concat]
{
  e_1 \sreduces \strin{a s} \\
  [\rstr{a},\rstr{s} / x,y]e_3 \sreduces v_3
}
{
  \strcase{e_1}{e_2}{x,y.e_3} \sreduces v_3
}

\inferrule[S-E-Replace]
{e_1 \sreduces \strin{s_1} \\ e_2 \sreduces \strin{s_2} \\ \lsubst{r}{s_1}{s_2} = s} 
{\sisubst{r}{e_1}{e_2} \sreduces \sistr{s}}

\inferrule[S-E-SafeCoerce]
{e \sreduces \strin{s}}
{\coerce{r}{e} \sreduces \strin{s}}

\inferrule[S-E-Check-Ok]
{e \sreduces \strin{s} \\ s \in \lang{r} \\ [\strin{s} / x]e_1 \sreduces v}
{
  \rcheck{r}{e}{x.e_1}{e_2} \sreduces v
}

\inferrule[S-E-Check-NotOk]
{
  e \sreduces \strin{s} \\ s \not \in \lang{r} \\
  e_2 \sreduces v
}
{
  \rcheck{r}{e}{x.e_1}{e_2} \sreduces v
}
\end{mathpar}
\caption{Big step semantics for $\lambdas$.}
\label{fig:dlambdas}
\end{figure}


\begin{figure}
  \small
$\fbox{\inferrule{}{e \mapsto e}}$

\begin{mathpar}

\inferrule[L-E-AppLeft]
{e_1 \mapsto e_1'}
{e_1(e_2) \mapsto e_1'(e_2)}

\inferrule[L-E-AppRight]
{e_2 \mapsto e_2'}
{v_1 \mapsto v_1}

\inferrule[L-E-AppAbs]
{ \ }
{(\lambda x : \tau_{11} . t_{12}) v_2 \mapsto [v_2 / x]t_{12}}

\end{mathpar}

\fbox{\inferrule{}{e \mapsto^* e}}

\begin{mathpar}

\inferrule[RT-Refl]
{ \ }
{e \mapsto^* e}

\inferrule[RT-Trans]
{ e \mapsto^* e' \\ e' \mapsto e'' }
{ e \mapsto^* e'' }

\end{mathpar}

\label{fig:lambda}
\caption{Call-by-name small step Semantics for $\lambda$ and its reflexive, transitive closure.} \label{fig:lambda}
\end{figure}

\begin{figure}
  \small
$\fbox{\inferrule{}{e \mapsto e}}$ (Contiues figure 6)
%$\fbox{\inferrule{}{e \mapsto e}} \  \fbox{ \inferrule{}{v \ \val}}$
\begin{mathpar}
\inferrule[SS-E-Concat-Left]
{e_1 \mapsto e_1'}
{\rsconcat{e_1}{e_2} \mapsto \rsconcat{e_1'}{e_2}}

\inferrule[SS-E-Concat-Right]
{e_2 \mapsto e_2'}
{\rsconcat{v_1}{e_2} \mapsto \rsconcat{v_1}{e_2'}}

\inferrule[SS-E-Concat]
{ \ }
{\rsconcat{\strin{s_1}}{\strin{s_2}} \mapsto \strin{s_1 s_2}} % ???

\inferrule[SS-E-Case-Left]
{
  e_1 \mapsto e_1'
}
{
  \strcase{e_1}{e_2}{x,y.e_3} \mapsto \strcase{e_1'}{e_2}{x,y.e_3}
}

\inferrule[SS-E-Case-$\epsilon$-val]
{
  \ 
}
{
  \strcase{\strin{\epsilon}}{e_2}{x.y.e_3} \mapsto e_2
}

\inferrule[SS-E-Case-Concat]
{
  \ 
}
{
  \strcase{\strin{a s}}{e_2}{x,y.e_3} \mapsto [\rstr{a},\rstr{s} / x,y]e_3 
}

\inferrule[SS-E-Replace-Left]
{e_1 \mapsto e_1'}
{ \sisubst{r}{v_1}{e_2} \mapsto \sisubst{r}{v_1'}{e_2}}

\inferrule[SS-E-Replace-Right]
{e_2 \mapsto e_2'}
{ \sisubst{r}{e_1}{e_2} \mapsto \sisubst{r}{e_1}{e_2'}}

\inferrule[SS-E-Replace]
{ \ }
{\sisubst{r}{\strin{s_1}}{\strin{s_2}} \mapsto \sistr{\lsubst{r}{s_1}{s_2}}}

\inferrule[SS-E-SafeCoerce-Step]
{e \mapsto e'}
{\coerce{r}{e} \mapsto \coerce{r}{e'}}

\inferrule[SS-E-SafeCoerce]
{ \ }
{ \coerce{r}{\rstr{s}} \mapsto \rstr{s}}

%%% NRF-bookmark1
\inferrule[SS-E-Check-StepLeft]
{e \mapsto e'}
{\rcheck{r}{e}{x.e_1}{e_2} \mapsto \rcheck{r}{e'}{x.e_1}{e_2}}

\inferrule[SS-E-Check-Ok]
{s \in \lang{r}}
{\rcheck{r}{\strin{s}}{x.e_1}{e_2} \mapsto [\rstr{s} / x]e_1}

\inferrule[SS-E-Check-NotOk]
{s \not \in \lang{r}}
{\rcheck{r}{\strin{s}}{x.e_1}{e_2} \mapsto e_2} 

\end{mathpar}
\caption{Small step semantics for $\lambdas$. Extends \ref{fig:lambda}.}
\label{fig:sdlambdas}
\end{figure}




\begin{figure}[t]\label{fig:lambdap}
\small
$\fbox{\inferrule{}{\tctx \vdash \iota : \tau}}$
~~~~$\tctx ::= \emptyset \pipe \tctx, x : \tau$

\begin{mathpar}
\inferrule[P-T-Var]
{ x:\tau \in \tctx }
{ \tctx \vdash x:\tau }

\inferrule[P-T-Abs]
{\tctx, x : \tau_1 \vdash \iota_2 : \tau_2}
{\tctx \vdash \lambda x.\iota_2 : \tau_1 \rightarrow \tau_2}

\inferrule[P-T-App]
{\tctx \vdash \iota_1 : \tau_2 \rightarrow \tau \\ \tctx \vdash \iota_2 : \tau_2}
{\tctx \vdash \iota_1(\iota_2) : \iota}

\inferrule[P-T-String]
{ \ }
{\tctx \vdash \tstr{s} : \str}

\inferrule[P-T-Regex]
{ \ }
{\tctx \vdash \rx{r} : \regex}

\inferrule[P-T-Concat]
{\tctx \vdash \iota_1 : \str \\ \tctx \vdash \iota_2 : \str}
{\tctx \vdash \tconcat{\iota_1}{\iota_2} : \str}

\inferrule[P-T-Case]
{\tctx \vdash \iota_1 : \str \\ \tctx \vdash \iota_2 : \tau \\ \tctx, x:\str, y:\str \vdash \iota_3:\tau}
{\tctx \vdash \pstrcase{\iota_1}{\iota_2}{x,y.\iota_3} : \tau}

\inferrule[P-T-Replace]
{\tctx \vdash \iota_1 : \regex \\ \tctx \vdash \iota_2 : \str \\ \tctx \vdash \iota_3 : \str }
{\tctx \vdash \preplace{\iota_1}{\iota_2}{\iota_3} : \str}

\inferrule[P-T-Check]
{\tctx \vdash \iota_r : \regex \\ \tctx \vdash \iota_1 : \str \\ \tctx \vdash \iota_2 : \sigma \\ \tctx \vdash \iota_3 : \sigma}
{\tctx \vdash \tcheck{\iota_r}{\iota_1}{\iota_2}{\iota_3} : \sigma}
\end{mathpar}
\caption{Typing rules for $\lambdap$.
The typing context $\tctx$ is standard.}
\label{fig:slambdap}
\end{figure}

\begin{figure}[t]
\small
$\fbox{\inferrule{}{\iota \treduces \dot{v}}}$

\begin{mathpar}
\inferrule[P-E-Abs]
{ \ }
{\lambda x.e \sreduces \lambda x.e}

\inferrule[P-E-App]
{ \iota_1 \sreduces \lambda x . \iota_3 \\  \iota_2 \sreduces \dot{v}_2 \\ [\dot{v}_2 / x] \iota_3 \sreduces \dot{v}_3}
{ \iota_1(\iota_2) \sreduces \dot{v}_3}

\inferrule[P-E-Str]
{ \ }
{\tstr{s} \treduces \tstr{s}}

\inferrule[P-E-Rx]
{ \ }
{\rx{r} \treduces \rx{r}}

\inferrule[P-E-Concat]
{\iota_1 \treduces \tstr{s_1} \\ \iota_2 \treduces \tstr{s_2}} 
{\tconcat{\iota_1}{\iota_2} \treduces \tstr{s_1 s_2}} % ???

\inferrule[P-E-Case-$\epsilon$]
{
  \iota_1 \treduces \tstr{ \epsilon } \\
  \iota_2 \treduces \dot{v_2} \\
}
{
  \pstrcase{\iota_1}{\iota_2}{x,y.\iota_3} \treduces \dot{v_2}
}

\inferrule[P-E-Case-Concat]
{
  \iota_1 \treduces \tstr{as} \\
  [\tstr{a},\tstr{s}/x,y] \iota_3 \treduces \dot{v} 
}
{
  \pstrcase{\iota_1}{\iota_2}{x,y.\iota_3} \treduces \dot{v}
}

\inferrule[P-E-Replace]
{\iota_1 \treduces \rx{r} \\ \iota_2 \treduces \tstr{s_2} \\ \iota_3 \treduces \tstr{s_3} } 
{\preplace{\iota_1}{\iota_2}{\iota_3} \treduces \tstr{\lsubst{r}{s_2}{s_3} }}

\inferrule[P-E-Check-OK]
{
  \iota_x \treduces \rx{r} \\
  \iota \treduces \tstr{s} \\ 
s \in \lang{r} \\ 
\iota_1 \treduces \dot{v_1} 
}
{
  \tcheck{\iota_x}{\iota}{\iota_1}{\iota_2} \treduces \dot{v_1}
}

\inferrule[P-E-Check-NotOK]
{\iota_x \treduces \rx{r} \\ \iota \treduces \tstr{s} \\ s \not \in \lang{r} \\ \iota_2 \treduces \dot{v_2}}
{\tcheck{\iota_x}{\iota}{\iota_1}{\iota_2} \treduces \dot{v_2}}
\end{mathpar}
\caption{Big step semantics for $\lambdap$}.
\label{fig:dlambdap}
\end{figure}



\begin{figure}[t]
\small
$\fbox{\inferrule{}{\iota \treduces \dot{v}}}$

\begin{mathpar}
\inferrule[SP-E-Abs]
{ \ }
{\lambda x.e \sreduces \lambda x.e}

\inferrule[SP-E-App]
{ \iota_1 \sreduces \lambda x . \iota_3 \\  \iota_2 \sreduces \dot{v}_2 \\ [\dot{v}_2 / x] \iota_3 \sreduces \dot{v}_3}
{ \iota_1(\iota_2) \sreduces \dot{v}_3}

\inferrule[SP-E-Str]
{ \ }
{\tstr{s} \treduces \tstr{s}}

\inferrule[SP-E-Rx]
{ \ }
{\rx{r} \treduces \rx{r}}

\inferrule[SP-E-Concat]
{\iota_1 \treduces \tstr{s_1} \\ \iota_2 \treduces \tstr{s_2}} 
{\tconcat{\iota_1}{\iota_2} \treduces \tstr{s_1 s_2}} % ???

\inferrule[SP-E-Case-$\epsilon$]
{
  \iota_1 \treduces \tstr{ \epsilon } \\
  \iota_2 \treduces \dot{v_2} \\
}
{
  \pstrcase{\iota_1}{\iota_2}{x,y.\iota_3} \treduces \dot{v_2}
}

\inferrule[SP-E-Case-Concat]
{
  \iota_1 \treduces \tstr{as} \\
  [\tstr{a},\tstr{s}/x,y] \iota_3 \treduces \dot{v} 
}
{
  \pstrcase{\iota_1}{\iota_2}{x,y.\iota_3} \treduces \dot{v}
}

\inferrule[SP-E-Replace]
{\iota_1 \treduces \rx{r} \\ \iota_2 \treduces \tstr{s_2} \\ \iota_3 \treduces \tstr{s_3} \\ \lsubst{r}{s_2}{s_3} = s} 
{\preplace{\iota_1}{\iota_2}{\iota_3} \treduces \tstr{s}}

\inferrule[SP-E-Check-OK]
{
  \iota_r \treduces \rx{r} \\
  \iota \treduces \tstr{s} \\ 
s \in \lang{r} \\ 
\iota_1 \treduces \dot{v_1} 
}
{
  \tcheck{\iota_r}{\iota}{\iota_1}{\iota_2} \treduces \dot{v_1}
}

\inferrule[SP-E-Check-NotOK]
{\iota_r \treduces \rx{r} \\ \iota \treduces \tstr{s} \\ s \not \in \lang{r} \\ \iota_2 \treduces \dot{v_2}}
{\tcheck{\iota_r}{\iota}{\iota_1}{\iota_2} \treduces \dot{v_2}}
\end{mathpar}
\caption{Small step semantics for $\lambdap$}.
\label{fig:sdlambdap}
\end{figure}

\begin{figure}[h]
\small
$\fbox{\inferrule{}{\trden{\sigma}=\tau}}$
\begin{mathpar}
\inferrule[Tr-T-String]
{ }
{ \trden{\stringin{r}} = \str }

\inferrule[Tr-T-Arrow]
{ \trden{\sigma_1} = \tau_1 \\ \trden{\sigma_2} = \tau_2 }
{ \trden{\sigma_1 \rightarrow \sigma_2} = \tau_1 \rightarrow \tau_2 }
\end{mathpar}
$\fbox{\inferrule{}{\trden{\Psi}=\Theta}}$
\begin{mathpar}
\inferrule[Tr-T-Context-Emp]
{ }{\trden{\emptyset} = \emptyset}

\inferrule[Tr-T-Context-Ext]
{\trden{\Psi}=\Theta\\ \trden{\sigma} = \tau}
{\trden{\Psi, x : \sigma} = \Theta, x : \tau}
\end{mathpar}
  $\fbox{\inferrule{}{ \trden{e} = \iota }}$
\begin{mathpar}
\inferrule[Tr-Var]
{ }
{ \trden{x} = x}

\inferrule[Tr-Abs]
{  \trden{e} = \iota }
{ \trden{ \lambda x.e } = \lambda x . \iota}

\inferrule[Tr-App]
{ \trden{e_1} = \iota_1 \\  \trden{e_2} = \iota_2}
{ \trden{e_1(e_2)} = \iota_1(\iota_2)}

\inferrule[Tr-Case]
{ \trden{e_1} = \iota_1 \\
   \trden{e_2} = \iota_2 \\
   \trden{e_3} = \iota_3
}
{ \trden{ \strcase{e_1}{e_2}{x,y.e_3} } = \pstrcase{\iota_1}{\iota_2}{x,y.\iota_3} }

\inferrule[Tr-string]
{ \ }
{   \trden{\strin{s}} = \tstr{s}}

\inferrule[Tr-Concat]
{  \trden{e_1} = \iota_1 \\  \trden{e_2} = \iota_2}
{  \trden{\rsconcat{e_1}{e_2}} = \tconcat{\iota_1}{\iota_2} }

\inferrule[Tr-Subst]
{   \trden{e_1} = \iota_1 \\   \trden{e_2} = \iota_2 }
{   \trden{ \sisubst{r}{e_1}{e_2} } = \tsubst{\rx{r}}{\iota_1}{\iota_2} }

\inferrule[Tr-SafeCoerce]
{  \trden{e} = \iota }
{   \trden{ \coerce{r'}{e} } = \iota }

\inferrule[Tr-Check]
{  
  \trden{e} = \iota \\  
   \trden{e_1} = \iota_1 \\  
   \trden{e_2} = \iota_2
} 
{ 
  \trden{ \rcheck{r}{e}{x.e_1}{e_2} } = \tcheck{\rx{r}}{\iota}{(\lambda x . \iota_1)(\iota)}{\iota_2} 
} 
\end{mathpar}
\caption{Translation from source terms ($e$) to target terms ($\iota$).}
\label{fig:tr}
\end{figure}



\bibliographystyle{abbrv}
\bibliography{research}
\end{document}
