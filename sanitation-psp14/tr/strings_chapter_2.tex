\documentclass[11pt,leqno]{article}
\usepackage{cmu-titlepage2}
\usepackage{fullpage}
\usepackage[small,bf]{caption2}
\usepackage{times}
\usepackage{helvet}
\usepackage{courier}

\usepackage{amsmath}
\usepackage{amssymb} 
\usepackage{amsthm}
\usepackage{ stmaryrd }
\usepackage{mathpartir}
\usepackage{enumerate}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tabularx}
\usepackage{morefloats}
\usepackage{bussproofs}    % Gentzen-style deduction trees *with aligned sequents!*
\usepackage{mathpartir}    % For type-settting type checking rule figures
\usepackage{syntax}        % For type-setting formal grammars.
\usepackage{hyperref}       % For links in citations
\usepackage{enumerate}
\usepackage{enumitem}

\input{../../att-icfp14/macros-atlam}

\usepackage{todonotes}

\newtheorem{tr}{TR Item}
\renewcommand{\thetr}{\Alph{tr}} % "letter-numbered" theorems
\newtheorem{trexam}[tr]{Example}
\newtheorem{trthm}[tr]{Theorem}
\newtheorem{trlem}[tr]{Lemma}
\newtheorem{trdef}[tr]{Definition}
\newtheorem{trconj}[tr]{Conjecture}
\newtheorem{ass}[tr]{Assumption}
\newtheorem{condition}[tr]{Condition}

\newtheorem{thm}{Theorem}                                                       
\newtheorem{cor}[thm]{Corollary}                                                
\newtheorem{lem}[thm]{Lemma}                                                    
\newtheorem{prop}[thm]{Proposition}                                             
\newtheorem{ax}[thm]{Axiom}                                                     
\theoremstyle{definition}                                                       
\newtheorem{defn}[thm]{Definition}                                              
\newtheorem{exam}[thm]{Example}                                                 
\newtheorem{rem}[thm]{Remark} 
%\renewcommand*{\proofname}{Proof Sketch}

%
% For type setting inference rules with labels.
%
\newcommand{\inferlbl}[3]
            {\inferrule{#3}{#2}{\textsf{\footnotesize{\sc #1}}}}
\newcommand{\inferline}[3]
            {\inferrule{#3}{#2} & {\textsf{\footnotesize{\sc #1}}} \\ \\}

\newcommand{\Lagr}{\mathcal{L}}
\newcommand{\lang}[1]{\Lagr\{#1\}}
\newcommand{\stru}[2]{ {\tt string\_union}(#1,#2)}


\newcommand{\dconvert}[2]{ {\tt dconvert}(#1,#2) }
\newcommand{\filter}[2]{ {\tt filter}(#1,#2) }
\newcommand{\ifilter}[2]{ {\tt ifilter}(#1,#2) }

\newcommand{\reduces}{ \Rightarrow }
\newcommand{\gvd}{\Gamma \vdash }
\newcommand{\ovd}{\Omega \vdash }

\newcommand{\trep}{{\tt rep}}

\newcommand{\tstrf}[1]{`#1\textrm'} %??
\newcommand{\strf}[1]{``#1"}


\newcommand{\iso}{\cong}
%%
%% Source and Target language definitions.
%%
\newcommand{\lambdas}{\lambda_{RS}}
\newcommand{\lambdap}{\lambda_P}

% Source language terms.
\newcommand{\sisubst}[3]{{\sf rreplace}[#1](#2;#3)} \newcommand{\rreplace}[3]{{\sf rreplace}[#1](#2;#3)} % lots of legacy naming around these parts...

\newcommand{\rssreplace}[3]{\sisubst{#1}{#2}{#2}} % TODO-nrf fix this.

\newcommand{\coerce}[2]{ {\sf rcoerce}[#1](#2)}
\newcommand{\rcoerce}[2]{{\sf rcoerce}[#1](#2)}
\newcommand{\sistr}[1]{{\sf rstr}[#1]}   \newcommand{\rstr}[1]{{\sf rstr}[#1]} % Lots of legacy naming around these parts...

\newcommand{\val}{{\sf val}}

\newcommand{\rcheck}[4]{ {\sf rcheck}[#1](#2;#3;#4) }


\newcommand{\strin}[1]{\sistr{#1}}
\newcommand{\rsconcat}[2]{{\sf rconcat}(#1;#2)} \newcommand{\rconcat}[2]{{\sf rconcat}(#1;#2)} % lots of legact naming around these parts..

% Source language types.
\newcommand{\stringin}[1]{{\sf stringin}[#1]}

% target language terms.
\newcommand{\tsubst}[3]{{\sf replace}(#1;#2;#3)} \newcommand{\metareplace}[3]{{\sf replace}(#1;#2;#3)} % TODO-nrf rename the commands. Lots of legacy naming around these parts...

\newcommand{\tcheck}[4]{{\sf pcheck}(#1; #2; #3; #4)}
\renewcommand{\tstr}[1]{{{\sf str}[#1]}}
\newcommand{\preplace}[3]{{\sf preplace}(#1;#2;#3)}
\newcommand{\treplace}[3]{{\sf preplace}(#1;#2;#3)}
\newcommand{\pconcat}[2]{{\sf pconcat}(#1;#2)} 
\newcommand{\tconcat}[2]{{\sf pconcat}(#1;#2)} % lots of legacy naming around these parts...

\newcommand{\regext}[1]{ {\sf rx}[#1] } % TODO-nrf remove
\newcommand{\rx}[1]{ {\sf rx}[#1] }

% Target language types
\newcommand{\str}{{\sf string}}
\newcommand{\regex}{{\sf regex}}

% Meta-theoretic functions
\newcommand{\lsubst}[3]{{\sf replace}(#1;#2;#3)} % This used to renderlreplace(...) so there're probably mistkes wherever this command was used now.
\newcommand{\lreplace}[3]{{\sf lreplace}(#1; #2; #3)}

\newcommand{\sctx}{\Psi} % Context for external typing
\newcommand{\tctx}{\Theta} % Context for internal typing
\newcommand{\ereduces}{\Downarrow}


\newcommand{\strcase}[3]{ {\sf rstrcase}(#1; #2; #3)}
\newcommand{\pstrcase}[3]{ {\sf pstrcase}(#1; #2; #3)}

\newcommand{\lhead}[1]{ {\sf lhead}(#1) }
\newcommand{\ltail}[1]{ {\sf ltail}(#1) }


% Judgements
\newcommand{\trden}[1]{\llbracket #1 \rrbracket} % = Translation Denotation.
% Relations
\newcommand{\treduces}{ \Downarrow }
\newcommand{\sreduces}{ \Downarrow }

%%
%% Constrain the size of full-page diagrams and rule lists
%%
%%\newcommand{\pagewidth}{5in}
%%\newcommand{\rulelistwidth}{3in}

% Names of type systems presented in paper
\newcommand{\lcs}{\lambda_{S}}

\setlength{\grammarindent}{3em}

% Arguments to lreplace are as follows:
% lreplace(pattern to replace, target, replacement).
% 
% ie lreplace(a,b,c) reads "replace all instances of a in b with c" and
% correspondes to Python's b.replace(a,c). 
\renewcommand{\lreplace}[3]{{\sf lreplace}(#1, #2, #3)}
\newcommand{\freplace}[3]{{\tt freplace}(#1, #2, #3)}
\newcommand{\freplacep}[4]{{\tt freplace}(#1,#2,#3,#4)}

\newcommand{\eps}{\epsilon}

\title{Statically Typed String Sanitation Inside a Python (Technical Report)}
\author{Nathan Fulton \and Cyrus Omar \and Jonathan Aldrich}
\date{December 2014}
\trnumber{CMU-ISR-14-112}
\keywords{type systems; regular languages; input sanitation; string sanitation}
\support{This work was supported by the National Security Agency lablet contract \#H98230-14-C-0140.}
\abstract{This report contains supporting evidence for claims put forth and explained in the paper ``Statically Typed String Sanitation Inside a Python'' \cite{fulton2014}, including proofs of lemmas
and theorems asserted in the paper, examples, additional discussion of the paper's technical content, and errata.}
\begin{document}
\maketitle

\tableofcontents
\listoffigures
\clearpage


\section{Terminology and Notation}
Theorems and lemmas appearing in \cite{fulton2014} are numbered correspondingly, while supporting facts appearing only in the Technical Report are lettered.
Throughout this technical report, we use a small step semantics corresponding to the big step semantics given in \cite{fulton2014}.

\section{Regular Expressions}
The syntax of regular expressions over some alphabet $\Sigma$ is shown in Figure \ref{fig:regex}. 

\begin{ass}[Regular Expression Congruences]
We assume regular expressions are implicitly identified up to the following congruences:
\begin{align*}
\epsilon\cdot r & \equiv r\\
r \cdot \epsilon & \equiv r\\
(r_1\cdot r_2) \cdot r_3 & \equiv r_1 \cdot (r_2 \cdot r_3)\\
r_1 + r_2 &\equiv r_2 + r_1\\
(r_1 + r_2) + r_3 &\equiv r_1 + (r_2 + r_3)\\
\epsilon^* & \equiv \epsilon
\end{align*}
\end{ass}

\begin{ass}[Properties of Regular Languages] \label{thm:regexprops}
We assume the following properties:
\begin{enumerate}

\item If $s_1 \in \lang{r_1}$ and $s_2 \in \lang{r_2}$ then $s_1s_2 \in \lang{r_1\cdot r_2}$.
\item For all strings $s$ and regular expressions $r$, either $s \in \lang{r}$ or $s \not \in \lang{r}$.
\item Regular languages are closed under reversal.
\end{enumerate}
\end{ass}

\section{$\lambdas$}
The syntax of $\lambdas$ is specified in Figure \ref{fig:glambdas}.

\subsection{Static Semantics}
The static semantics of $\lambdas$ is specified in Figure \ref{fig:slambdas}.  The typing context obeys the standard structural properties of weakening, exchange and contraction. 

\subsubsection{Case Analysis}
The following correctness conditions must hold for any definition of $\lhead{r}$ and $\ltail{r}$.

\begin{condition}[Correctness of Head] \label{trlemmax}
If $c_1  s' \in \lang{r}$, then
$c_1 \in \lang{\lhead{r}}$.
\end{condition}

\begin{condition}[Correctness of Tail] \label{trlemma:tail-correctness}
If $c_1 s' \in \lang{r}$ then $s' \in \lang{\ltail{r}}$.
\end{condition}

For example, we conjecture (but do not here prove) that the definitions below satisfy these conditions. Note that these are slightly amended relative to the published paper.

\begin{defn}[Definition of $\lhead{r}$]\label{def:lhead}
We first define an auxiliary relation that determines the set of characters that the head might be, tracking the remainder of any sequences that appear:
\begin{align*}
\lhead{\epsilon, \epsilon} &= \emptyset\\
\lhead{\epsilon, r'}      &= \lhead{r', \epsilon} \\
\lhead{a, r'}             &= \{a\} \\
\lhead{r_1\cdot r_2, r'}  &= \lhead{r_1, r_2 \cdot r'} \\
\lhead{r_1 + r_2, r'}     &= \lhead{r_1, r'} \cup \lhead{r_2, r'} \\
\lhead{r^*, r'}           &= \lhead{r, \epsilon} \cup \lhead{r', \epsilon}
\end{align*}
We define $\lhead{r} = a_1 + a_2 + ... + a_i$ iff $\lhead{r, \epsilon} = \{a_1, a_2, ..., a_i\}$.
\end{defn}

\begin{defn}[Brzozowski's Derivative]\label{def:derivative}
  The \emph{derivative of $r$ with respect to $s$} is denoted by $\delta_s(r)$
  and is $\delta_s(r) = \{t | st \in \lang{r}\}$.
\end{defn}

\begin{defn}[Definition of $\ltail{r}$]
If $\lhead{r, \epsilon} = \{a_1, a_2, ..., a_i\}$, then  
we define $\ltail{r} = \delta_{a_1}(r) + \delta_{a_2}(r) + ... + \delta_{a_i}(r)$.
\end{defn}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % Correctness.
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{trthm}[Correctness of \textsf{ltail}]
% If $s \in \lang{r}$ then $s \in \lang{\lhead{r} \cdot \ltail{r}}$.
% \end{trthm}
% \begin{proof}
% The proof proceeds by structural induction on $r$.
% In each case, we identify sublanguages of the head and tail of $r$ such that 
% $s$ is in the concatenation of the the sublanguages.
% Throughout the proof, we use the fact that $\lang{r'} \subseteq \lang{r}$ and $\lang{q'} \subseteq \lang{q}$
% implies $\lang{r' \cdot q'} \subseteq \lang{r \cdot q}$.

% \begin{itemize}[label=$ $,itemsep=1ex]

% \item \textbf{Case $r = c$ for $c \in Sigma$}.
% By definition, if $s \in \lang{c}$ then $s = c$.
% By definition of lhead and ltail, $\lhead{c} = \lhead{c, \epsilon} = c$
% and $\lang{\epsilon} \subseteq \lang{\ltail{r}}$.
% Therefore, $c \in \lang{c \cdot \epsilon} \subseteq \lang{\lhead{r} + \ltail{r}}$.

% \item \textbf{Case $r = r_1 \cdot r_2$}.
% Suppose $s \in \lang{r}$.
% We may decompose $s$ as $s_1  \cdots s_n$ such that $s_1 = c_1 s_1' \in \lang{r_1}$.
% Note that $c_1 \in \lhead{r_1}$ by \ref{trlemmax}.
% Therefore, $c_1 \in \lhead{r_1 \cdot r_2}$ by definition of lhead.
% It suffices to show that $s_1' s_2 \in \lang{\delta_{c_1}(r)}$.
% Since $s = c_1 s_1' s_2\in \lang{r}$, it follows by the definition of derivative that $s_1' s_2 \in \delta_{c_1}(r)$.
% Therefore, $s = c_1 s_1' s_2 \in \lang{ c_1 \cdot \delta_{c_1} } \subseteq \lang{ \lhead{r} \cdot \ltail{r}}$.


% \item \textbf{Case $r = r_1 + r_2$}.
% Suppose $s \in \lang{r_1 + r_2}$
% so that $s \in \lang{r_1}$ or $s \in \lang{r_2}$.
% Consider without loss of generality the case where $s \in \lang{r_1}$.
% By induction, $s \in \lang{\lhead{r_1} \cdot \ltail{r_1}}$
% Note that $\lhead{r_1} \subseteq \lhead{r}$
% and $\ltail{r_1} \subseteq \ltail{r}$.
% Therefore, $\lhead{r_1} \cdot \ltail{r_2} \subseteq \lhead{r_1} \cdot \ltail{r_1}$.


% \item \textbf{Case $r = q^*$}.
% Either $s$ is the empty string or else the $k^{th}$ unwinding (i.e., $s = s_1 \cdots s_k$ where $k > 0$ and $s_i \in \lang{q}$).

% Suppose $s = \epsilon$.
% By definition of lhead, $\lhead{r} = \lhead{q^*} = \lhead{q^*, \epsilon} = \lhead{\epsilon, \epsilon} + \cdots = \epsilon + \cdots$.
% By definition of ltail, $\ltail{r} = \epsilon \cdots$.
% From these facts we conclude that $s = \epsilon \in \lang{\epsilon \cdot \epsilon} \subseteq \lang{\lhead{r} \cdot \ltail{r}}$.

% Suppose instead that $s = s_1 \cdots s_k$ for $k < 0$ where $s_i \in \lang{q}$.
% If $q = \epsilon$ then $s = \epsilon$ and the conclusion follows for the same reason as the epsilon subcase of the character case.
% Otherwise, $s$ is not the empty string and so $s = c_1 s_1 s_2$ where $s_1$ and $s_2$ might be empty.
% By the lemma above, $c_1 \in \lhead{s}$.
% By the definition of derivative, $s_1s_2 \in \delta_{c_1}(s)$.
% Therefore, $s \in \lang{\lhead{s} \cdot \delta_{c_1}(s)} \subseteq \lang{\lhead{r} \cdot \ltail{r}}$, where the set inclusion follows by the definition
% of lhead and ltail.
% \end{itemize}
% \end{proof}


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % Substitution.
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Replacement}
The following correctness condition must hold for any definition of $\lreplace{r}{r_1}{r_2}$.

\begin{condition}[Replacement Correctness] \label{thm:substcorrespondence}
  If $s_1 \in \lang{r_1}$ and $s_2 \in \lang{r_2}$ then $$\lsubst{r}{s_1}{s_2} \in \lang{\lreplace{r}{r_1}{r_2}}$$
\end{condition}

We do not give a particular definition for $\lreplace{r}{r_1}{r_2}$ here.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Type Safety and Security.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Dynamic Semantics}
Figure~\ref{fig:sdlambdas} specifies a small-step operational semantics for $\lambdas$. 

\subsubsection{Canonical Forms}
\begin{trlem}[Canonical Forms]\label{cfgen}
If $\emptyset \vdash v : \sigma$ then:
\begin{enumerate}
\item If $\sigma = \stringin{r}$ then $v = \rstr{s}$ and $s \in \lang{r}$.
\item If $\sigma = \sigma_1 \rightarrow \sigma_2$ then $v = \lambda x . e'$.
\end{enumerate}

\end{trlem}
\begin{proof}
By inspection of the static and dynamic semantics.
\end{proof}

\subsubsection{Type Safety}
\begin{trlem}[Progress]
If $\emptyset\vdash e : \sigma$ either $e = v$ or $e \mapsto e'$.
\end{trlem}
\begin{proof}
The proof proceeds by rule induction on the derivation of $\emptyset\vdash e : \sigma$.
\begin{itemize}[label=$ $,itemsep=1ex]
\item \textbf{$\lambda$ fragment}. Cases SS-T-Var, SS-T-Abs, and SS-T-App are exactly as in a proof of progress for
the simply typed lambda calculus.

\item \textbf{S-T-Stringin-I}. Suppose $\emptyset\vdash \rstr{s} : \stringin{s}$.
Then $e=\rstr{s}$.

\item \textbf{S-T-Concat}. Suppose $\emptyset\vdash \rconcat{e_1}{e_2} : \stringin{r_1 \cdot r_2}$ and $\emptyset \vdash e_1 : \stringin{r_1}$ and $\emptyset \vdash e_2 : \stringin{r_2}$.
By induction, $e_1 \mapsto e_1'$ or $e_1 = v_1$ and similarly, $e_2 \mapsto e_2'$ or $e_2 = v_2$. 
If $e_1$ steps, then SS-E-Concat-Left applies and so
$\rconcat{e_1}{e_2} \mapsto \rconcat{e_1'}{e_2}$. Similarly, if $e_2$ steps
then $e$ steps by SS-E-Concat-Right.

In the remaining case, $e_1 =v_1$ and $e_2 =v_2$.
But then it follows by Canonical Forms that $e_1 = \rstr{s_1}$
and $e_2 = \rstr{s_2}$.
Finally, by SS-E-Concat, $\rconcat{\rstr{s_1}}{\rstr{s_2}} \mapsto \rstr{s_1s_2}$.

\def\mline#1{\par\hspace*{-\leftmargin}\parbox{\textwidth}{\[#1\]}}
\item \textbf{S-T-Case}.
Suppose $e = \strcase{e_1}{e_2}{x,y.e_3}$ and $\emptyset\vdash e_1 : \stringin{r}$.
%\begin{align}
%&\vdash e_1 : \stringin{r} \\
%&\vdash e_2 : \sigma \\
%x:\stringin{\lhead{r}}, y : \stringin{\ltail{r}} &\vdash e_3 : \sigma
%\end{align}
%Actually this isn't even necessary...
%By (2), $e_2 \mapsto e_2'$ or $e_2 \val$. 
%In the former case, $e \mapsto \strcase{e_1}{e_2'}{x,y.e_3}$.
By induction and Canonical Forms it follows that $e_1 \mapsto e_1'$ or $e_1 = \rstr{s}$.
In the former case, $e$ steps by S-E-Case-Left.
In the latter case, note that $s = \epsilon$ or $s = at$ for some string $t$.
If $s = \epsilon$ then $e$ steps by S-E-Case-$\epsilon$-Val,
and if $s = at$ the $e$ steps by S-E-Case-Concat.

\item \textbf{S-T-Replace}.
Suppose $e = \rreplace{r}{e_1}{e_2}$, $\emptyset\vdash e : \stringin{\lreplace{r}{r_1}{r_2}}$ and:
\begin{align}
&\emptyset\vdash e_1 : \stringin{r_1} \\
&\emptyset\vdash e_2 : \stringin{r_2}
\end{align}

By induction on (1), $e_1 \mapsto e_1'$ or $e_1 = v_1$  for some $e_1'$.
If $e_1 \mapsto e_1'$ then $e$ steps by SS-E-Replace-Left.
Similarly, if $e_2$ steps then $e$ steps by SS-E-Replace-Right.
The only remaining case is where $e_1 = v_1$ and also $e_2 = v_2$.
By Canonical Forms, $e_1 = \strin{s_1}$ and $e_2 = \strin{s_2}$.
Therefore, $e \mapsto \rstr{\lsubst{r}{s_1}{s_2}}$ by SS-E-Replace.

\item \textbf{S-T-SafeCoerce}.
Suppose that $\emptyset\vdash \rcoerce{r}{e_1} : \stringin{r}$.
and
%\begin{align}
$\emptyset\vdash e_1 : \stringin{r'}$ for $\lang{r'} \subseteq \lang{r}$. % \\
%&\lang{r'} \subseteq \lang{r}
%\end{align}
By induction, $e_1 =v_1$ or $e_1 \mapsto e_1'$ for some $e_1'$.
If $e_1 \mapsto e_1'$ then $e$ steps by SS-E-SafeCoerce-Step.
Otherwise, $e_1 =v$ and by Canonical Forms $e_1 = \rstr{s}$.
In this case, $e = \rcoerce{r}{\rstr{s}} \mapsto \rstr{s}$ by SS-E-SafeCoerce.

\item \textbf{S-T-Check}
Suppose that $\emptyset\vdash \rcheck{r}{e_0}{x.e_1}{e_2} : \stringin{r}$ and:
\begin{align}
\emptyset &\vdash e_0 : \stringin{r_0}  \\
\emptyset, x:\stringin{r} &\vdash e_1 : \sigma \\
\emptyset &\vdash e_2 : \sigma \label{align6}
\end{align}

By induction,  $e_0 \mapsto e_0'$ or $e_0 = v$.
In the former case $e$ steps by SS-E-Check-StepLeft.
Otherwise, $e_0 = \rstr{s}$ by Canonical Forms.
By Lemma~\ref{thm:regexprops} part 2, either $s \in \lang{r_0}$ or $s \not\in\lang{r_0}$.
In the former case $e$ takes a step by SS-E-Check-Ok.
In the latter case $e$ takes a step by SS-E-Check-NotOk.

\end{itemize}

\end{proof}

\begin{ass}[Substitution] \label{lem:subst}
If $\Psi, x : \sigma' \vdash e : \sigma$ and $\Psi \vdash e' : \sigma'$, then
$\Psi \vdash [e' / x] e : \sigma$.
\end{ass}

\begin{trlem}[Preservation for Small Step Semantics]
If $\emptyset \vdash e : \sigma$ and $e \mapsto e'$ then $\emptyset \vdash e' : \sigma$.
\end{trlem}
\begin{proof}

By induction on the derivation of $e \mapsto e'$ and $\emptyset \vdash e : \sigma$.

\begin{itemize}[label=$ $,itemsep=1ex]
\item \textbf{$\lambda$ fragment}. Cases SS-E-AppLeft, SS-E-AppRight, and SS-E-AppAbs are exactly as in a proof of type safety for
the simply typed lambda calculus.

\item \textbf{S-E-Concat-Left}.
Suppose $e = \rconcat{e_1}{e_2} \mapsto \rconcat{e_1'}{e_2}$ and $e_1 \mapsto e_1'$.
The only rule that applies is S-T-Concat, so $\emptyset\vdash e_1 : \stringin{r_1}$ and $\emptyset\vdash e_2 : \stringin{r_2}$.
By induction, $\emptyset\vdash e_1' : \stringin{r_1}$.
Therefore, by S-T-Concat, $\emptyset\vdash \rconcat{e_1'}{e_2} : \stringin{r_1r_2}$.

\item {\textbf{S-E-Concat-Right}}. 
Suppose $e = \rconcat{e_1}{e_2} \mapsto \rconcat{e_1}{e_2'}$ and $e_2 \mapsto e_2'$.
The only rule that applies is S-T-Concat, so $\emptyset\vdash e_1 : \stringin{r_1}$ and $\emptyset\vdash e_2 : \stringin{r_2}$.
By induction, $\emptyset\vdash e_2' : \stringin{r_2}$.
Therefore, by S-T-Concat, $\emptyset\vdash \rconcat{e_1}{e_2'} : \stringin{r_1r_2}$.


\item \textbf{S-E-Concat}. 
Suppose $\rconcat{\rstr{s_1}}{\rstr{s_2}} \mapsto \rstr{s_1s_2}$.
The only applicable rule is S-T-Concat, so 
$\emptyset\vdash\rstr{s_1} : \stringin{r_1}$ 
and
$\emptyset\vdash\rstr{s_2} : \stringin{r_2}$ and $\emptyset \vdash \rconcat{\rstr{s_1}}{\rstr{s_2}} : \stringin{r_1 \cdot r_2}$. 
By Canonical Forms, $s_1 \in \lang{r_1}$ and $s_2 \in  \lang{r_2}$ from which it follows by Lemma~\ref{thm:regexprops}
that $s_1s_2 \in \lang{r_1\cdot r_2}$. Therefore, $\emptyset\vdash \rstr{s_1s_2} : \stringin{r_1\cdot r_2}$ by S-T-Rstr.

\item \textbf{S-E-Case-Left}.
Suppose 
$e \mapsto \strcase{e_1'}{e_2}{x,y.e_3}$
and $\emptyset \vdash e : \sigma$ and $e_1 \mapsto e_1'$.
The only rule that applies is S-T-Case, so:
\begin{align}
\emptyset&\vdash e_1 : \stringin{r} \label{align7} \\
\emptyset&\vdash e_2 : \sigma \label{align8} \\ 
\emptyset, x:\stringin{\lhead{r}}, y : \stringin{\ltail{r}} &\vdash e_3 : \sigma \label{align9}
\end{align}
By (\ref{align7}) and the assumption that $e_1 \mapsto e_1'$, it follows by induction that $\emptyset\vdash e_1' : \stringin{r}$.
This fact together with (\ref{align8}) and (\ref{align9}) implies by S-T-Case that
$\emptyset\vdash\strcase{e_1'}{e_2}{x,y.e_3} : \sigma$.

%\item \textbf{SS-E-Case-Right}. 
%We have that $e = \strcase{e_1}{e_2}{x,y.e_3}$, Suppose $e \mapsto \strcase{e_1}{e_2'}{x,y.e_3}$
%and $\emptyset \vdash e : \stringin{r}$.
%By inversion of S-T-Case:
%\begin{align}
%\emptyset&\vdash e_1 : \stringin{r} \label{align10}\\
%\emptyset&\vdash e_2 : \sigma \label{align11} \\ 
%x:\stringin{\lhead{r}}, y : \stringin{\ltail{r}} &\vdash e_3 : \sigma \label{align12}
%\end{align}
%By (\ref{align11}) and the assumption that $e_2 \mapsto e_2'$, it follows by induction that $\emptyset\vdash e_2' : \stringin{r}$.
%This fact together with (\ref{align10}) and (\ref{align12}) implies by S-T-Case that 
%$\emptyset\vdash\strcase{e_1}{e_2'}{x,y.e_3} : \sigma$.

\item \textbf{S-E-Case-$\epsilon$-Val}.
Suppose $\strcase{e_0}{e_2}{x,y.e_3} \mapsto e_2$. 
The only rule that applies is S-T-Case, so $\emptyset \vdash e_2 : \sigma$. 

\item \textbf{S-E-Case-Concat}.
Suppose that $e = \strcase{\rstr{as}}{e_2}{x,y.e_3} \mapsto [\rstr{a}, \rstr{s} / x,y] e_3$
and that $\emptyset\vdash e : \sigma$.
The only rule that applies is S-T-Case so:
\begin{align}
\emptyset&\vdash \rstr{as} : \stringin{r} \label{align13}\\
\emptyset&\vdash e_2 : \sigma \label{align14} \\ 
\emptyset, x:\stringin{\lhead{r}}, y : \stringin{\ltail{r}} &\vdash e_3 : \sigma \label{align15}
\end{align}

We know that $as \in \lang{r}$ by Canonical Forms on (\ref{align13}) 
Therefore, $a \in \lang{\lhead{r}}$ by Condition \ref{trlemmax} and $s \in \lang{\ltail{r}}$ by Condition \ref{trlemma:tail-correctness}. 

From these facts about $a$ and $s$ we know by S-T-Rstr that $\emptyset\vdash \rstr{a} : \stringin{\lhead{r}}$
and $\emptyset\vdash \rstr{s} : \stringin{\ltail{r}}$.
It follows by Assumption \ref{lem:subst} that  $\emptyset\vdash [\rstr{a}, \rstr{s} / x,y] e_3 : \sigma$.

\item \textbf{Case S-E-Replace-Left}.
Suppose that $e = \rreplace{r}{e_1}{e_2} \mapsto \rreplace{r}{e_1'}{e_2}$ when $e_1 \mapsto e_1'$.
The only rule that applies is S-T-Replace, so
$\emptyset \vdash e : \stringin{\lreplace{r}{r_1}{r_2}}$ where:
\begin{align*}
\emptyset &\vdash e_1 : \stringin{r_1} \\
\emptyset &\vdash e_2 : \stringin{r_2}
\end{align*}
By induction, $\emptyset \vdash e_1' : \stringin{r_1}$.
Therefore, $\emptyset \vdash \rreplace{r}{e_1'}{e_2} : \stringin{\lreplace{r}{r_1}{r_2}}$ by S-T-Replace.

\item \textbf{Case S-E-Replace-Right}.
Suppose that $e = \rreplace{r}{e_1}{e_2} \mapsto \rreplace{r}{e_1'}{e_2}$ when $e_1 \mapsto e_1'$.
The only rule that applies is S-T-Replace, so
$\emptyset \vdash e : \stringin{\lreplace{r}{r_1}{r_2}}$ where:
\begin{align*}
\emptyset &\vdash e_1 : \stringin{r_1} \\
\emptyset &\vdash e_2 : \stringin{r_2}
\end{align*}
By induction, $\emptyset \vdash e_1' : \stringin{r_1}$.
Therefore, $\emptyset \vdash \rreplace{r}{r_1'}{r_2} : \stringin{\lreplace{r}{r_1}{r_2}}$ by S-T-Replace.

%\item \textbf{SS-E-Replace}
%Suppose that $e = \rreplace{r}{\rstr{s_1}}{\rstr{s_2}} \mapsto \rstr{\lsubst{r}{s_1}{s_2}}$ 
%The only rule that applies is S-T-Replace, so
%$\emptyset \vdash e : \stringin{\lreplace{r}{r_1}{r_2}}$ where:
%\begin{align*}
%\emptyset &\vdash \rstr{s_1} : \stringin{r_1} \\
%\emptyset &\vdash \rstr{s_2} : \stringin{r_2}
%\end{align*}
%
%Therefore, it suffices to show that $\emptyset \vdash \rstr{\lsubst{r}{s_1}{s_2}} : \stringin{\lreplace{r}{r_1}{r_2}}$
%or, equivalently, that $\lsubst{r}{s_1}{s_2} \in \lang{\lreplace{r}{r_1}{r_2}}$.
%This follows from the fact that $s_1 \in \lang{r_1}$ and $s_2 \in \lang{r_2}$.
%%The only rule that applies is S-T-Replace, so
%%$\emptyset \vdash e : \stringin{\lreplace{r}{r_1}{r_2}}$ where:
%%\begin{align*}
%%\emptyset &\vdash \rstr{s_1} : \stringin{r_1} \\
%%\emptyset &\vdash e_2 : \stringin{r_2}
%%\end{align*}
%%By induction, $\emptyset \vdash e_2' : \stringin{r_2}$.
%%Therefore, $\emptyset \vdash \rreplace{r}{\rstr{s_1}}{e_2'} : \stringin{\lreplace{r}{r_1}{r_2}}$ by S-T-Replace.
%
%\item \textbf{SS-E-Check-StepLeft}.
%Suppose that $e = \rcheck{r}{e_0}{x.e_1}{e_2} \mapsto \rcheck{r}{e_0'}{x.e_1}{e_2}$.
%The only applicable typing rule is S-T-Check. 
%Therefore, $\emptyset \vdash e : \sigma$ where:
%\begin{align*}
%\emptyset &\vdash e_0 : \stringin{r} \\
%\emptyset, x:\stringin{r} &\vdash e_1 : \sigma \\
%\emptyset &\vdash e_2 : \sigma 
%\end{align*}
%By induction, $\emptyset \vdash e_0' : \stringin{r}$.
%Therefore, the result follows by P-T-Check.
%
%\item \textbf{SS-E-Check-Ok}.
%Suppose that $e = \rcheck{r}{\rstr{s}}{x.e_1}{e_2} \mapsto \replace{\rstr{s}}{x}{e_1}$
%where $s \in \lang{r}$. The only applicable typing rule is S-T-Check. 
%Therefore, $\emptyset \vdash e : \sigma$ where:
%\begin{align*}
%\emptyset &\vdash e_0 : \stringin{r} \\
%\emptyset, x:\stringin{r} &\vdash e_1 : \sigma \\
%\emptyset &\vdash e_2 : \sigma 
%\end{align*}
%By substitution, $\emptyset \vdash \replace{\rstr{s}}{x}{e_1} : \sigma$.
%
%\item \textbf{SS-E-Check-NotOk}.
%Suppose that $e = \rcheck{r}{\rstr{s}}{x.e_1}{e_2} \mapsto e_2$
%where $s \not \in \lang{r}$. The only applicable typing rule is S-T-Check. 
%Therefore, $\emptyset \vdash e : \sigma$ where $\emptyset \vdash e_2 : \sigma$. 


\item \textbf{Case S-E-Replace}.

Suppose $e = \rreplace{r}{\rstr{s_1}}{\rstr{s_2}} \mapsto \rstr{\lsubst{r}{s_1}{s_2}}$.
The only applicable rule is 
S-T-Replace, so
\begin{align*}
\emptyset &\vdash \rstr{s_1} : \stringin{r_1} \\
\emptyset &\vdash \rstr{s_2} : \stringin{r_2}
\end{align*}
By conanical forms,
$s_1 \in \lang{r_1}$ and $s_2 \in \lang{r_2}$.
Therefore, $$\lsubst{r}{s_1}{s_2} \in \lang{\lreplace{r}{r_1}{r_2}}$$ by Condition~\ref{thm:substcorrespondence}.
It is finally derivable by S-T-Rstr that:

$\emptyset \vdash \rstr{\lsubst{r}{s_1}{s_2}} : \stringin{\lreplace{r}{r_1}{r_2}}$.


\item \textbf{Case S-E-SafeCoerce}.
Suppose that $\rcoerce{r}{\rstr{s_1}} \mapsto \rstr{s_1}$.
The only applicable rule is S-T-SafeCoerce, so 
$\emptyset\vdash \rcoerce{r}{s_1} : \stringin{r}$ and $\emptyset \vdash \rstr{s_1} : \stringin{r'}$ and $\lang{r'} \subset \lang{r}$. 
By Canonical Forms, $s' \in \lang{r'}$. By the definition of subset, $s' \in \lang{r}$. Therefore, by S-T-Rstr, we have that $\emptyset\vdash \rstr{s'} : \stringin{r}$.

\item \textbf{Case S-E-Check-Ok}.
Suppose $\rcheck{r}{\rstr{s}}{x.e_1}{e_2} \mapsto \subst{\rstr{s}}{x}{e_1}$ and 
$s \in \lang{r}$, and $\emptyset \vdash \rcheck{r}{\rstr{s}}{x.e_1}{e_2} : \sigma$.
The only rule that applies is S-T-Check, so $\emptyset, x : \stringin{r} \vdash e_1 : \sigma$.
By S-T-Rstr, we have that $\emptyset \vdash \rstr{s} : \stringin{r}$. By Substitution, we have that $\emptyset \vdash \subst{\rstr{s}}{x}{e_1} : \sigma$.

\item \textbf{Case S-E-Check-NotOk}.
Suppose $\rcheck{r}{\rstr{s}}{x.e_1}{e_2} \mapsto e_2$ and 
$s \not \in \lang{r}$ and \\$\emptyset \vdash \rcheck{r}{\rstr{s}}{x.e_1}{e_2} : \sigma$.
The only applicable rule is S-T-Check, so $\emptyset \vdash e_2 : \sigma$.

\end{itemize}
\end{proof}


\begin{trthm}[Type Safety for small step semantics.] \label{thm:sstypesafte}
If $\emptyset\vdash e : \sigma$ then either $e \ \val$ or $e \mapsto^* e'$ and $\emptyset\vdash e' : \sigma$.
\end{trthm}
\begin{proof}
Follows from applying progress and preservation transitively over the multistep judgement.
\end{proof}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BEGIN THE SEMANTIC CORRESPONDENCE ARGUMENT FOR LAMBDA_RS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Semantic Correspondence between Big and Small Step Semantics for $\lambdas$}
%
%Before extending the previous theorem to the big step semantics, we first establish a correspondence between
%the big step semantics in Figure~\ref{fig:sdlambdas} and the small step semantics in Figure~\ref{fig:dlambdas}.
%
%
%% bookmark1
%\begin{trlem} \label{lem:inductive}
%If $e \sreduces v$ and $e \mapsto e'$ then $e' \sreduces v$. 
%\end{trlem}
%\begin{proof}
%By induction on the structure of $e$.
%
%\begin{itemize}[label=$ $,itemsep=1ex]
%
%
%\item \textbf{Case $e = e_1(e_2)$}.
%The only applicable rule is S-E-App, so $e_1 \sreduces \lambda x . e_3$
%and $e_2 \sreduces v_2$ such that $[v_2/x] e_3 \sreduces v$.
%
%The term $e = e_1(e_2)$ may step by three rules.
%
%First, if $e$ steps by L-E-AppLeft then $e_1(e_2) \mapsto e_1'(e_2)$.
%By induction, $e_1' \sreduces \lambda x . e_3$.
%By S-E-App, $e_1'(e_2) \sreduces \lambda x . e_3$.
%
%Second, if $e$ steps by L-E-AppRight then $e_1(e_2) \mapsto e_1(e_2')$.
%By induction, $e_2' \sreduces v_2$.
%By S-E-App, $e_1(e_2') \sreduces \lambda x . e_3$.
%
%Third, if $e$ steps by L-E-AppAbs then $e = (\lambda x . e_3)(v_2) \mapsto [v_2 / x]e_3$.
%By induction, $e = (\lambda x . e')v_2 \sreduces v$.
%
%\item \todo{Other lambda cases}
%
%\item \textbf{$s = \concat{e_1}{e_2}$}.
%The only big-step rule that applies is S-E-Concat,
%so $e \sreduces v$ where $v = \rstr{s_1s_2}$,
%$e_1 \sreduces \rstr{s_1}$, and $e_2 \sreduces \rstr{s_2}$.
%
%If $e_1 = \rstr{e_1}$ and $e_2 = \rstr{e_2}$ then $e \mapsto v$.
%Otherwise either $e_1 \mapsto e_1'$ or else $e_2 \mapsto e_2'$.
%
%In the former case, $e \mapsto \concat{e_1'}{e_2}$ by S-E-Concat-Left.
%By induction, $e_1' \sreduces \rstr{s_1}$ and so 
%$\concat{e_1'}{e_2} \sreduces v$. 
%
%In the latter case, $e \mapsto \concat{e_1}{e_2'}$ by S-E-Concat-Right.
%By induction, $e_2 \sreduces e_2'$ form which it follows by S-E-Concat
%that $\concat{e_1}{e_2'} \sreduces v$.
%
%\item \textbf{$s = \strcase{e_1}{e_2}{x,y.e_3}$}.
%\todo{finish...}
%
%
%\end{itemize}
%\end{proof}
%
%\begin{trthm}[Semantic Correspondence for $\lambdas$ (Part I)]
%If $e \sreduces v$ then $e \mapsto^* v$.  
%\end{trthm}
%\begin{proof}
%We proceed by structural induction on $e$.
%
%\begin{itemize}[label=$ $,itemsep=1ex]
%
%% Abstraction case.
%\item \textbf{Case $e = \lambda x . e_1$}. 
%The only applicable rule is S-E-Abs, so $v = \lambda x . e_1$.
%Note that $\lambda x . e_1 \mapsto^* \lambda x . e_1$ by RT-Refl.
%
%% bookmark2
%% Application case.
%\item \textbf{Case $e=e_1(e_2)$}.
%The only applicable rule is S-E-App. By inversion:
%\begin{align*}
%  e_1 &\sreduces \lambda x.e_1' \\
%  e_2 &\sreduces v_2 \\
%  [v_2/x]e_1' &\sreduces v
%\end{align*}
%
%From which it follows by induction that:
%\begin{align*}
%  e_1 &\mapsto^* \lambda x.e_1'  \\
%  e_2 &\mapsto^* v_2 \\
%  [v_2/x]e_1' &\mapsto^* v
%\end{align*}
%
%If $e_1 = \lambda x . e_1'$ and $e_2 = v_2$ (henceforth the reflexive case)
%then $e \mapsto [v_2 / x] e_1'$ and the conclusion follows by RT-Trans.
%
%If $e_1 \mapsto \lambda x . e_1'$ then $e_1(e_2) \mapsto (\lambda x . e_1')(e_2) \mapsto [e_2/x]e_1'$ and the conclusion follows by two applications
%of RT-Trans.
%
%If $e_1 \mapsto^k \lambda x . e_2'$ then $e_1 \mapsto e'$ so $e_1(e_2) \mapsto e'(e_2)$ and by Lemma~\ref{lem:inductive} $e'(e_2) \mapsto^* v$.
%So $e_1(e_2) \mapsto e'(e_2) \mapsto^* v$; it follows by RT-Trans that $e_1(e_2) \mapsto v$.
%
%\todo{not modified below this line...}
%
%Note that the following rule is derivable by repeating applications of the left and right compatibility rules for application:
%\begin{mathpar}
%\inferrule[L*-App]
%{ e_1 \mapsto^* e_1' \\ e_2 \mapsto^* e_2'  }
%{ e_1(e_2) \mapsto^* e_1'(e_2') }
%\end{mathpar}
%
%From these facts and L-AppAbs, we may establish that $e_1(e_2) \mapsto^* ( \lambda x.e_2 )(v_2) \mapsto [v_2/x]e_2$.
%Note that $[v_2/x]e_2 \mapsto^* v$, so by RT-Trans it follows that $e = e_1(e_2) \mapsto^* v$.
%
%% String Values
%\item \textbf{Case $e = \strin{s}$}. The only applicable rule is S-E-RStr, so $v = \strin{s}$.
%By RT-Refl, $\strin{s} \mapsto^* \strin{s}$.
%
%% String Concatenation.
%\item \textbf{Case $e=\rconcat{e_1}{e_2}$}. 
%The only applicable rule is S-E-Concat, so $v = \rstr{s_1s_2}$.
%By inversion, $e_1 \sreduces \strin{s_1}$ and $e_2 \sreduces \strin{s_2}$.
%By induction, $e_1 \mapsto^* \strin{s_1}$ and $e_2 \mapsto^* \strin{s_2}$.
%Note that the rule following is derivable:
%\begin{mathpar}
%\inferrule[SS-E-Concat-LR*]
%{ e_1 \mapsto^* e_1' \\ e_2 \mapsto^* e_2'  }
%{ \rconcat{e_1}{e_2} \mapsto^* \rconcat{e_1'}{e_2'} }
%\end{mathpar}
%
%From these facts, it follows that $\rconcat{e_1}{e_2} \mapsto^* \rconcat{\strin{s_1}}{\strin{s_2}}$.
%Finally, $\rconcat{\strin{s_1}}{\strin{s_2}} \mapsto \strin{s_1s_2}$ by SS-E-Concat.
%By RT-Step, it follows that $\rconcat{e_1}{e_2} \mapsto^* \strin{s_1s_2}$.
%
%%Strcase Case.
%\item \textbf{Case $e=\strcase{e_1}{e_2}{x,y.e_3}$}.
%
%There are two subcases. For the first, suppose $\strcase{e_1}{e_2}{x,y.e_3} \sreduces v$ was finally derived by S-E-Case-$\epsilon$.
%By inversion: 
%\begin{align*}
%e_1 &\sreduces \strin{\epsilon} \\
%e_2 &\sreduces v
%\end{align*}
%from which it follows by induction that:
%\begin{align*}
%e_1 &\mapsto^* \strin{\epsilon} \\
%e_2 &\mapsto^* v
%\end{align*}
%
%Note that the following rule is derivable:
%
%\begin{mathpar}
%\inferrule[SS-E-Case-LR*]
%{ e_1 \mapsto^* e_1' \\ e_2 \mapsto^* e_2'  }
%{ \strcase{e_1}{e_2}{x,y.e_3} \mapsto^* \strcase{e_1'}{e_2'}{x,y.e_3} }
%\end{mathpar}
%
%From these facts is follows that $e \mapsto^* \strcase{\strin{\epsilon}}{v}{x,y.e_3}$.
%By S-E-Case-$\epsilon$-Val and RT-Step it follows that $e \mapsto^* v$.
%
%Now consider the other case where $\strcase{e_1}{e_2}{x,y.e_3} \sreduces v$ was finally derived by S-E-Case-Concat.
%By inversion, 
%$e_1 \sreduces \strin{as}$ and $[\strin{a}, \strin{s} / x, y]e_3 \sreduces v$. 
%From these facts it follows by induction that 
%$e_1 \mapsto^* \strin{as}$ and
%$[\strin{a}, \strin{s} / x, y]e_3 \mapsto^* v$.
%
%By the first of these facts, it is derivable via SS-E-Case-LR* that 
%$e \mapsto^* \strcase{e_1'}{\strin{as}}{x,y.e_3}$.
%SE-E-Case-Concat applies to this form, so by RT-Step we know $e \mapsto^* [\strin{a}, \strin{s} / x, y]e_3$.
%Recall that $[\strin{a}, \strin{s} / x, y]e_3 \mapsto^* v$, so by RT-Trans we finally derive $e \mapsto^* v$.
%
%% String Replacement.
%\item \textbf{Case $e=\rreplace{r}{e_1}{e_2}$}.
%There is only one applicable rule, so $v = \rstr{s}$ and by inversion it follows that:
%\begin{align*}
%e_1 &\sreduces \rstr{s_1} \\
%e_2 &\sreduces \rstr{s_2}
%\end{align*}
%
%From which it follows by induction that:
%\begin{align*}
%e_1 &\mapsto^* \rstr{s_1} \\
%e_2 &\mapsto^* \rstr{s_2}
%\end{align*}
%
%Furthermore, $\lsubst{r}{s_1}{s_2} = s$ by induction.
%Note that the following rule is derivable:
%
%\begin{mathpar}
%\inferrule[SS-E-Replace-LR*]
%{ e_1 \mapsto^* e_1' \\ e_2 \mapsto^* e_2'  }
%{ \rreplace{r}{e_1}{e_2} \mapsto^* \rreplace{r}{e_1'}{e_2'} }
%\end{mathpar}
%
%From these facts, $\rreplace{r}{e_1}{e_2} \mapsto^* \rreplace{r}{\rstr{s_1}}{\rstr{s_2}}$.
%
%Finally, $\rreplace{r}{\rstr{s_1}}{\rstr{s_2}} \mapsto \lsubst{r}{s_1}{s_2}$.
%
%From these two facts we know via RT-Step that $\rreplace{r}{e_1}{e_2} \mapsto^* \rreplace{r}{e_1}{e_2}$.
%Recall that $\lsubst{r}{s_1}{s_2} = s$, from which the conclusion follows.
%
%\item \textbf{Case $e = \rcoerce{r}{e_1}$}.
%In this case $e \sreduces v$ is only finally derivable via S-E-SafeCoerce.
%Therefore, $v = \strin{s}$ and by inversion $e_1 \sreduces \strin{s}$.
%By induction, $e_1 \mapsto^* \strin{s}$.
%
%The following rule is derivable:
%
%\begin{mathpar}
%\inferrule[SS-E-SafeCoerce-Step]
%{ e \mapsto^* e' }
%{ \rcoerce{r}{e} \mapsto^* \rcoerce{r}{e'} }
%\end{mathpar}
%
%Applying this rule at $e_1 \mapsto^* \strin{s}$ derives $\rcoerce{r}{e_1} \mapsto^* \rcoerce{r}{\strin{s}}$.
%In the final step, $\rcoerce{r}{\strin{s}} \mapsto \strin{s}$ by SS-E-SafeCoerce.
%From this fact, we may derive via RT-Trans that $e \mapsto^* \strin{s}$ as required.
%
%\item \textbf{Case $e = \rcheck{r}{e_1}{x.e_2}{e_3}$}.
%
%Note that the rule following is derivable:
%
%\begin{mathpar}
%\inferrule[SS-E-Check-Step]
%{ e_1 \mapsto^* e_1' \\ e_3 \mapsto^* e_3' }
%{ \rcheck{r}{e_1}{x.e_2}{e_3} \mapsto^* \rcheck{r}{e_1'}{x.e_2}{e_3'} }
%\end{mathpar}
%
%There are two ways to finally derive $e \sreduces v$.
%In both cases, $e_1 \sreduces \strin{s}$ by inversion.
%Therefore, in both cases, $e_1 \mapsto^* \strin{s}$ by induction
%and so $e \mapsto^* \rcheck{r}{\strin{s}}{x.e_2}{e_3}$ by SS-E-Check-Step.
%
%Suppose $e \sreduces v$ is finally derived via SS-E-Check-Ok.
%By the facts mentioned above and SS-E-Check-Step, $e \mapsto^* \rcheck{r}{\strin{s}}{x.e_2}{e_2}$.
%Note that by inversion $s \in \lang{r}$. Therefore, SS-E-Check-Ok applies and so by RT-Trans $e \mapsto^* [\rstr{s}/x]e_1$.
%By inversion, $[\strin{s}/x]e_1 \sreduces v$. Therefore, by induction and RT-Step $e \mapsto^* v$ as required.
%
%Suppose that $e \sreduces v$ is instead finally derived via SS-E-Check-NotOk.
%By inversion, $e_3 \sreduces v$ and by induction $e_3 \mapsto^* v$.
%From these facts at SS-E-Check-Step, it is derivable that $e \mapsto^* \rcheck{r}{\strin{s}}{x.e_2}{v}$.
%
%Also by inversion, $s \not \in \lang{r}$ and so SS-E-Check-NotOk applies.
%Therefore, $\rcheck{r}{\strin{s}}{x.e_2}{v} \mapsto v$. 
%
%The conclusion $e \mapsto^* v$ follows from these facts by RT-Step.
%\end{itemize}
%\end{proof}
%%% Abstraction case.
%%\item \textbf{Case $e = \lambda x . e_1$}. 
%%% String Values
%%\item \textbf{Case $e = \strin{s}$}. 
%%% String Concatenation.
%%\item \textbf{Case $e=\rconcat{e_1}{e_2}$}. 
%%%Strcase Case.
%%\item \textbf{Case $e=\strcase{e_1}{e_1}{x,y.e_3}$}.
%%% String Replacement.
%%\item \textbf{Case $e=\rreplace{r}{e_1}{e_2}$}.
%%% Coercion
%%\item \textbf{Case $e = \rcoerce{r}{e_1}$}.
%%% Replacement
%%\item \textbf{Case $e = \rcheck{r}{e_1}{x.e_2}{e_3}$}.
%
%
%%Establishing the other direction requires a minor lemma about the relationship between values and reflexivity in the big step semantics.
%%
%%\begin{trthm}[Small Step Values are Reflexive in the Big Step Semantics]
%%If $v \ \val$ in the small step semantics then $v \sreduces v$.
%%\end{trthm}
%%\begin{proof}
%%If $v \ \val$ is derived from SS-E-RStr then S-E-RStr establishes the result.
%%Otherwise $v \ \val$ is derived from SS-E-Abs and so S-E-Abs establishes the result.
%%\end{proof}
%
%\begin{trthm}[Semantic Correspondence for $\lambdas$ (Part II)]
%If $\emptyset\vdash e : \sigma$, $e \mapsto^* v$ and $v \ \val$ then $e \sreduces v$.  
%\end{trthm}
%\begin{proof}
%The proof proceeds by structural induction on $e$.
%
%\begin{itemize}[label=$ $,itemsep=1ex]
%
%\item \textbf{Case $e = \concat{e_1}{e_2}$}.
%By inversion, $\emptyset\vdash e_1 : \stringin{r_1}$.
%By Type Safety, Canonical Forms and Termination it follows that $e_1 \mapsto^* \rstr{s_1}$ for some $s_1$.
%By induction, $e_1 \sreduces \rstr{s_1}$.
%
%Similarly, $e_2 \mapsto^* \rstr{s_2}$ and $e_2 \sreduces \rstr{s_2}$.
%
%Note that $\concat{e_1}{e_2} \mapsto^* \concat{\rstr{s_1}}{\rstr{s_2}} \mapsto \rstr{s_1s_2}$ by SS-E-Concat-LR* and S-E-Concat.
%Therefore, $e \mapsto^* \rstr{s_1s_2}$ by RT-Step. So it suffices to show that $e \sreduces \rstr{s_1s_2}$.
%
%Finally, $e \sreduces \rstr{s_1s_2}$ follows via S-E-Concat from the facts that $e_1 \sreduces \rstr{s_1}$ and $e_2 \sreduces \rstr{s_2}$.
%This completes the case. 
%
%\item \textbf{Case $e = \rreplace{r}{e_1}{e_2}$}.
%By inversion of S-T-Replace, $\emptyset\vdash e_1 : \stringin{r_1}$ for some $r_1$.
%It follows by Type Safety, Termination and Canonical Forms that $e_1 \mapsto^* \rstr{s_1}$.
%By induction, $e_1 \sreduces \rstr{s_1}$.
%
%Similarly, $e_2 \mapsto^* \rstr{s_2}$ and $e_2 \sreduces \rstr{s_2}$.
%
%Note that $e \mapsto^* \rreplace{r}{\rstr{s_1}}{\rstr{s_2}} \mapsto \rstr{\lsubst{r}{s_1}{s_2}}$ by SS-Replace-LR* and SS-E-Replace.
%Therefore $e \mapsto^* \rstr{\lsubst{r}{s_1}{s_2}}$ by RT-Step. 
%
%It suffices to show $e \sreduces \rstr{\lsubst{r}{s_1}{s_2}}$, which follows by S-E-Replace from the facts that $e_1 \sreduces \rstr{s_1}$ and
%$e_2 \sreduces \rstr{s_2}$.
%
%
%\item \textbf{Case $e = \strcase{e_1}{e_2}{x.y.e_3}$}.
%By inversion, $\emptyset\vdash e_1 : \stringin{r}$ and $e_2 : \sigma$.
%By Type Safety, Canonical Forms and Termination $e_1 \mapsto^* \stringin{s_1}$ and by induction $e_1 \sreduces \stringin{s_1}$.
%Similarly, $e_2 \mapsto^* v_2$ and $\emptyset\vdash e_2 \sreduces v_2$.
%
%By SS-E-Case-LR*, $\strcase{e_1}{e_2}{x,y.e_3} \mapsto^* \strcase{v_1}{v_2}{x,y.e_3}$.
%
%Note that either $s_1 = \epsilon$ or $s_1 = as$ because we define strings as either empty or finite sequences of characters.
%We proceed by cases.
%
%If $s_1 = \epsilon$ then $\strcase{v}{v_2}{x,y.e_3} \mapsto v_2$ by SS-E-Case-$\epsilon$.
%Therefore, by RT-Step, $e \mapsto^* v_2$.
%Recall $e_1 \sreduces \strin{\epsilon}$ and $e_2 \sreduces v_2$, which is enough to establish by S-E-Case-$\epsilon$ that $e \sreduces v_2$.
%
%If $s_1 = as$ instead, then $\strcase{\strin{s_1}}{v_2}{x,y.e_3} \mapsto [\strin{a},\strin{s} / x,y ] e_3$ by SS-E-Case-Concat.
%Inversion of the typing relation satisfies the assumptions necessary to appeal to termination.
%Therefore,
%
%%\todo{Note that this substitution does not modify the syntactic structure of $e_3$ except by replacing free variables wit strings, and so} by induction,
%\[ [\strin{a},\strin{s} / x,y ] e_3 \mapsto^* v \text{ for } v \ \val. \]
%
%It follows by RT-Step that $e \mapsto^* v$.
%
%Note that the substitution does not change the structure of $e_3$.
%So by induction, $[\strin{a},\strin{s} / x,y ] e_3 \sreduces v$.
%Recall that $e_1 \sreduces \strin{s_1}$ and so by S-E-Case it follows that $e \sreduces [a,s / x,y] e_3 \sreduces v$.
%\end{itemize}
%
%\todo{The cases for coercion and checking are straightforward.}
%\end{proof}
%
%
%\subsection{Extension of Safety for Small Step Semantics}
%
%\begin{thm}[Type Safety] \label{thm:typesafety}
%  If $\emptyset \vdash e : \sigma$ 
%  and $e \sreduces e'$ then $\emptyset \vdash e' : \sigma$.
%\end{thm}
%\begin{proof}
%If $\emptyset \vdash e : \sigma$ then $e \mapsto^* e'$.
%Therefore, $e \sreduces e'$ by part 2 of the semantic correspondence theorem.
%
%Since $\emptyset \vdash e : \sigma$ and $e \mapsto^* e'$, it follows that $\emptyset \vdash e' : \sigma$ by type safety for the small step semantics.
%\end{proof}
%


\subsubsection{The Security Theorem}\label{sec:securitythm}

\begin{thm}[Correctness of Input Sanitation for $\lambdas$]\label{thm:scorrect}
  If  $\emptyset \vdash e : \stringin{r}$ and $e \mapsto^* \rstr{s}$ then $s \in \lang{r}$.
\end{thm}
\begin{proof}
By type safety, $\emptyset \vdash \rstr{s} : \stringin{r}$. By canonical forms, $s \in \lang{r}$.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LAMBDAP SECTION

\section{$\lambdap$}
We will define a translation to a language with only standard strings and regular expressions. The syntax of $\lambdap$ is shown in Figure \ref{fig:lcsSyntax}.


\subsection{Static Semantics}
The static semantics of $\lambdap$ is shown in Figure \ref{fig:slambdap}. The typing context of $\lambdap$ obeys the standard structural properties of weakening, exchange and contraction.

\subsection{Dynamic Semantics}
The dynamic semantics of $\lambdap$ is shown in Figure \ref{fig:sdlambdap}.

\subsubsection{Canonical Forms}
\begin{lem}[Canonical Forms]
If $\emptyset \vdash \dot{v} : \tau$ then:
\begin{itemize}
\item If $\tau=\tau_1 \rightarrow \tau_2$ then $\dot{v}=\lambda x : \tau.\iota$.
\item If $\tau = \regex$ then $\dot{v}=\rx{r}$.
\item If $\tau = \str$ then $\dot{v}=\tstr{s}$.
\end{itemize}
\end{lem}
\begin{proof} By inspection of the static and dynamic semantics. \end{proof}

\subsubsection{Type Safety}
\begin{thm}[Progress]
If $\emptyset\vdash \iota : \tau$ either $\iota = \dot{v}$ or $\iota \mapsto \iota'$.
\end{thm}
\begin{proof}
The proof proceeds by induction on the typing assumption. 
\begin{itemize}[label=$ $,itemsep=1ex]
\item \textbf{$\lambda$ fragment}. Cases P-T-Var, P-T-Abs, and P-T-App are exactly as in a proof of progress for
the simply typed lambda calculus.

\item \textbf{P-T-String}. In this case, $\iota = \tstr{s}$, which is a value.

\item \textbf{P-T-Regex}. In this case, $\iota = \rx{r}$, which is a value.

\item \textbf{P-T-Concat}. In this case, we have that $\emptyset \vdash \tconcat{\iota_1}{\iota_2} : \str$ and $\emptyset \vdash \iota_1 : \str$ and $\emptyset \vdash \iota_2 : \str$. By the IH, we have that either $\iota_1 \leadsto \iota_1'$ or $\iota_1 = \dot{v}_1$, and similarly $\iota_2 \leadsto \iota_2'$ or $\iota_2 = \dot{v}_2$. If $\iota_1$ steps, then we can make progress via PS-E-ConcatLeft. If $\iota_2$ steps, then we can make progress via PS-E-ConcatRight. If both are values, then by canonical forms $\iota_1 = \tstr{s_1}$ and $\iota_2 = \tstr{s_2}$ so we can make progress by PS-E-Concat.

\item \textbf{P-T-Case}.
Suppose $\emptyset \vdash \pstrcase{\iota_1}{\iota_2}{x,y.\iota_3} : \tau$ and $\emptyset \vdash \iota_1 : \str$. By induction and canonical forms, either $\iota_1 \mapsto \iota_1'$
or $\iota_1 = \tstr{s_1}$. 
If $\iota_1$ steps then we can make progress by PS-E-CaseLeft. If it is a value, then by the definition of strings, either $s_1 = \epsilon$ or $s_1 = as$ for some string $s$. If $s_1$ is empty, then we can make progress by PS-E-Case-Epsilon. Otherwise, we can make progress by PS-E-Case-Cons.

\item \textbf{P-T-Replace}.
Suppose $\emptyset \vdash \preplace{\iota_1}{\iota_2}{\iota_3} : \str$ and $\emptyset \vdash \iota_1 : \regex$ and $\emptyset \vdash \iota_2 : \str$ and $\emptyset \vdash \iota_3 : \str$. By induction and canonical forms, either $\iota_1 \mapsto \iota_1'$ or $\iota_1 = \rx{r}$. Similarly, $\iota_2 \mapsto \iota_2'$ or $\iota_2 = \tstr{s_2}$, and $\iota_3 \mapsto \iota_3'$ or $\iota_3 = \tstr{s_3}$. If $\iota_1$ steps, then we can make progress by PS-E-ReplaceLeft. If $\iota_2$ steps then we can make progress by PS-E-ReplaceMid. If $\iota_3$ steps, then we can make progress by PS-E-ReplaceRight. If all three are values, we can make progress by PS-E-Replace.

\item \textbf{P-T-Check}.
Suppose $\emptyset \vdash \tcheck{\iota_1}{\iota_2}{\iota_3}{\iota_4}$ and $\emptyset \vdash \iota_1 : \regex$ and $\emptyset \vdash \iota_2 : \str$. By induction and canonical forms, either $\iota_1 \mapsto \iota_1'$ or $\iota_1 = \rx{r}$. Similarly, $\iota_2 \mapsto \iota_2'$ or $\iota_2 = \tstr{s}$. If $\iota_1$ steps, then we can make progress by PS-E-CheckLeft. If $\iota_2$ steps, then we can make progress by PS-E-CheckRight. If both are values, then by Assumption \ref{thm:regexprops}.2, either $s \in \lang{r}$ or $s\notin\lang{r}$. In the former case, we can make progress by PS-E-Check-OK. In the latter case, we can make progress by PS-E-Check-NotOK.
\end{itemize}
\end{proof}

\begin{ass}[Substitution] \label{lem:psubst}
If $\Theta, x : \tau' \vdash \iota : \tau$ and $\Theta \vdash \iota' : \tau'$
then $\Theta \vdash [\iota' / x]\iota : \tau$.
\end{ass}

\begin{thm}[Preservation]
If $\emptyset \vdash \iota : \tau$ and $\iota \mapsto \iota'$ then $\emptyset \vdash \iota' : \tau$.
\end{thm}
\begin{proof}

The proof proceeds by rule induction on $\iota \mapsto \iota'$ and $\emptyset \vdash \iota : \tau$.

\begin{itemize}[label=$ $,itemsep=1ex]
\item \textbf{$\lambda$ fragment}. Cases PS-E-AppLeft, PS-E-AppRight, and PS-E-AppAbs are exactly as in a proof of type safety for
the simply typed lambda calculus.

\item \textbf{Case PS-E-ConcatLeft}.
Suppose $\tconcat{\iota_1}{\iota_2} \mapsto \tconcat{\iota_1'}{\iota_2}$ and $\iota_1 \mapsto \iota_1'$. The only applicable typing rule is P-T-Concat, so $\emptyset \vdash \iota_1 : \str$
and $\emptyset \vdash \iota_2 : \str$. 
By induction, $\emptyset \vdash \iota_1' : \str$,
so $\emptyset \vdash \rconcat{\iota_1'}{\iota_2} : \str$ by P-T-Concat.

\item \textbf{Case PS-E-ConcatRight}. Suppose $\tconcat{\tstr{s_1}}{\iota_2} \mapsto \tconcat{\tstr{s_1}}{\iota_2'}$ and $\iota_2 \mapsto \iota_2'$. The only applicable typing rule is P-T-Concat, so $\emptyset \vdash \tstr{s_1} : \str$
and $\emptyset \vdash \iota_2 : \str$. 
By induction, $\emptyset \vdash \iota_2' : \str$,
so $\emptyset \vdash \rconcat{\tstr{s_1}}{\iota_2'} : \str$ by P-T-Concat.

\item \textbf{Case PS-E-Concat}. Suppose $\tconcat{\tstr{s_1}}{\tstr{s_2}} \mapsto \tstr{s_1s_2}$. By P-T-String, $\emptyset \vdash \tstr{s_1s_2} : \str$.

\item \textbf{Case PS-E-CaseLeft}. Suppose $\pstrcase{\iota_1}{\iota_2}{x,y.\iota_3} \mapsto \strcase{\iota_1'}{\iota_2}{x,y.\iota_3}$ and $\iota_1 \mapsto \iota_1'$.
The only rule that applies is P-T-Case, so:
\begin{align*}
  \emptyset &\vdash \iota_1 : \str  \\
  \emptyset &\vdash \iota_2 : \tau \\
  \emptyset, x : \str, y : \str &\vdash \iota_3 : \tau 
\end{align*}
By induction, $\emptyset \vdash \iota_1' : \str$.
By P-T-Case, $\emptyset \vdash \pstrcase{\iota_1'}{\iota_2}{x,y.\iota_3} : \tau$.

\item \textbf{Case PS-E-CaseEpsilon}. 
Suppose $\pstrcase{\tstr{\epsilon}}{\iota_2}{x,y.\iota_3} \mapsto \iota_2$.
The only rule that applies is P-T-Case, so $\emptyset \vdash \iota_2 : \tau$.

\item \textbf{Case PS-E-Case-Cons}.
Suppose $\pstrcase{\tstr{as}}{\iota_2}{x,y.\iota_3} \mapsto [\tstr{a}, \tstr{s} / x,y] \iota_3$
The only rule that applies is P-T-Case, so:
\begin{align*}
  \emptyset &\vdash \iota_1 : \str \\
  \emptyset &\vdash \iota_2 : \tau \\
  \emptyset, x : \str, y : \str &\vdash \iota_3 : \tau
\end{align*}
By P-T-String, we have that $\emptyset \vdash \tstr{a} : \str$ and $\emptyset \vdash \tstr{s} : \str$. By weakening and Substitution applied twice, we have that $\emptyset \vdash [\tstr{a}, \tstr{s} / x,y] \iota_3 : \tau$.

\item \textbf{Case PS-E-ReplaceLeft}. 
Suppose $\preplace{\iota_1}{\iota_2}{\iota_3} \mapsto \preplace{\iota_1'}{\iota_2}{\iota_3}$
and $\iota_1 \mapsto \iota_1'$.
The only rule that applies is P-T-Replace, so $\tau=\str$ and:
\begin{align*}
  \emptyset &\vdash \iota_1 : \regex \\
  \emptyset &\vdash \iota_2 : \str \\
  \emptyset &\vdash \iota_3 : \str
\end{align*}

By induction, $\emptyset \vdash \iota_1' : \regex$.
Therefore, by P-T-Replace $\emptyset \vdash \preplace{\iota_1'}{\iota_2}{\iota_3}$.

\item \textbf{Case PS-E-ReplaceMid}. 
Suppose $\preplace{\rx{r}}{\iota_2}{\iota_3} \mapsto \preplace{\rx{r}}{\iota_2'}{\iota_3}$
and $\iota_2 \mapsto \iota_2'$.
The only rule that applies is P-T-Replace, so $\tau=\str$ and:
\begin{align*}
  \emptyset &\vdash \rx{r} : \regex \\
  \emptyset &\vdash \iota_2 : \str \\
  \emptyset &\vdash \iota_3 : \str
\end{align*}

By induction, $\emptyset \vdash \iota_2' : \str$.
Therefore, by P-T-Replace $\emptyset \vdash \preplace{\rx{r}}{\iota_2'}{\iota_3}$.

\item \textbf{Case PS-E-ReplaceRight}. 
Suppose $\preplace{\rx{r}}{\tstr{s}}{\iota_3} \mapsto \preplace{\rx{r}}{\tstr{s}}{\iota_3'}$
and $\iota_3 \mapsto \iota_3'$.
The only rule that applies is P-T-Replace, so $\tau=\str$ and:
\begin{align*}
  \emptyset &\vdash \rx{r} : \regex \\
  \emptyset &\vdash \tstr{s} : \str \\
  \emptyset &\vdash \iota_3 : \str
\end{align*}

By induction, $\emptyset \vdash \iota_3' : \str$.
Therefore, by P-T-Replace $\emptyset \vdash \preplace{\rx{r}}{\tstr{s}}{\iota_3'}$.

\item \textbf{Case PS-E-Replace}. 
Suppose $\preplace{\rx{r}}{\tstr{s_2}}{\tstr{s_3}} \mapsto \tstr{\lsubst{r}{s_2}{s_3}}$. The only applicalbe rule is P-T-Replace, so $\tau=\str$. By P-T-String, $\emptyset \vdash \tstr{\lsubst{r}{s_2}{s_3}} : \str$.

\item \textbf{Case PS-E-CheckLeft}. 
Suppose $\tcheck{\iota_1}{\iota_2}{\iota_3}{\iota_4} \mapsto \tcheck{\iota_1'}{\iota_2}{\iota_3}{\iota_4}$ and $\iota_1\mapsto\iota_1'$.
The only applicable typing rule is P-T-Check, so:
\begin{align*}
  \emptyset &\vdash \iota_1 : \regex \\
  \emptyset &\vdash \iota_2 : \str \\
  \emptyset &\vdash \iota_3 : \tau \\
  \emptyset &\vdash \iota_4 : \tau
\end{align*}
By induction, $\emptyset \vdash \iota_1' : \regex$. Therefore, by P-T-Check 
$\emptyset \vdash \tcheck{\iota_1'}{\iota_2}{\iota_3}{\iota_4} : \tau$.


\item \textbf{Case PS-E-CheckRight}. 
Suppose $\tcheck{\rx{r}}{\iota_2}{\iota_3}{\iota_4} \mapsto \tcheck{\rx{r}}{\iota_2'}{\iota_3}{\iota_4}$ and $\iota_2\mapsto\iota_2'$.
The only applicable typing rule is P-T-Check, so:
\begin{align*}
  \emptyset &\vdash \rx{r} : \regex \\
  \emptyset &\vdash \iota_2 : \str \\
  \emptyset &\vdash \iota_3 : \tau \\
  \emptyset &\vdash \iota_4 : \tau
\end{align*}
By induction, $\emptyset \vdash \iota_2' : \str$. Therefore, by P-T-Check 
$\emptyset \vdash \tcheck{\rx{r}}{\iota_2'}{\iota_3}{\iota_4} : \tau$.

\item \textbf{Case PS-E-Check-Ok}.
Suppose $\tcheck{\rx{r}}{\tstr{s}}{\iota_3}{\iota_4} \mapsto \iota_3$. 
The only applicable typing rule is P-T-Check, so $\emptyset \vdash \iota_3 : \tau$.

\item \textbf{Case PS-E-Check-Ok}.
Suppose $\tcheck{\rx{r}}{\tstr{s}}{\iota_3}{\iota_4} \mapsto \iota_4$. 
The only applicable typing rule is P-T-Check, so $\emptyset \vdash \iota_4 : \tau$.

\end{itemize}



\end{proof}



\section{Translation from $\lambdas$ to $\lambdap$}
The translation from $\lambdas$ to $\lambdap$ is defined in Figure \ref{fig:tr}.

\begin{thm}[Type-Preserving Translation]\label{thm:tpc}
If $\sctx \vdash e: \sigma$ then 
$\trden{\sctx} \vdash \trden{\iota} : \trden{\sigma}$
\end{thm}
\begin{proof}
By induction on the typing relation.

\begin{itemize}[label=$ $,itemsep=1ex]
\item \textbf{Case S-T-Var}. Suppose $\sctx \vdash x : \sigma$ and $x : \sigma \in \sctx$. We have by definition that $x : \trden{\sigma} \in \trden{\sctx}$ and $\trden{x} = x$. By P-T-Var, we have that $\trden{\sctx} \vdash x : \trden{\sigma}$.

\item \textbf{Case S-T-Abs}. 
Suppose $\sctx \vdash \lambda x : \sigma_1. e' : \sigma_1 \rightarrow \sigma_2$ and $\Psi, x : \sigma_1 \vdash e' : \sigma_2$. We have by definition:
\begin{align*}
\trden{\lambda x : \sigma_1.e'} &=\lambda x : \trden{\sigma_1}.\trden{e'}\\
\trden{\sigma_1 \rightarrow \sigma_2} &= \trden{\sigma_1} \rightarrow \trden{\sigma_2}\\
\trden{\Psi, x : \sigma_1} &= \trden{\Psi}, x : \trden{\sigma_1}
\end{align*}

By induction, we have that $\trden{\sctx}, x : \trden{\sigma_1} \vdash \trden{e'} : \trden{\sigma_2}$.

By P-T-Abs, we have that $\trden{\sctx} \vdash \lambda x : \trden{\sigma_1}. \trden{e'} : \trden{\sigma_1} \rightarrow \trden{\sigma_2}$.

\item \textbf{Case S-T-App}. 
Suppose $\sctx \vdash e_1(e_2) : \sigma$ and $\sctx \vdash e_1 : \sigma_2 \rightarrow \sigma$ and $\sctx \vdash e_2 : \sigma_2$. We have by definition:
\begin{align*}
\trden{e_1(e_2)} &= \trden{e_1}(\trden{e_2})\\
\trden{\sigma_2 \rightarrow \sigma} &= \trden{\sigma_2} \rightarrow \trden{\sigma}
\end{align*}

By induction, $\trden{\sctx} \vdash \trden{e_1} : \trden{\sigma_2} \rightarrow \trden{\sigma}$ and
$\trden{\sctx} \vdash \trden{e_2} : \trden{\sigma_2}$. 
Therefore, $\trden{\sctx} \vdash \trden{e_1}(\trden{e_2}) : \trden{\sigma}$ by P-T-App.

\item \textbf{Case S-T-StringIn-I}.
Suppose $\sctx \vdash \rstr{s} : \stringin{r}$.
By definition, $\trden{\rstr{s}} = \tstr{s}$ and $\trden{\stringin{r}} = \str$.
By P-T-String, $\tctx \vdash \tstr{s} : \str$.

\item \textbf{Case S-T-Concat}.
Suppose $\sctx \vdash \rconcat{e_1}{e_2} : \stringin{r_1 \cdot r_2}$ and $\sctx \vdash e_1 : \stringin{r_1}$ and $\sctx \vdash e_2 : \stringin{r_2}$. We have by definition:
\begin{align*}
\trden{\rconcat{e_1}{e_2}} &= \tconcat{\trden{e_1}}{\trden{e_2}}\\
\trden{\stringin{r_1}} &= \str\\
\trden{\stringin{r_2}} &= \str\\
\trden{\stringin{r_1 \cdot r_2}} &= \str
\end{align*}
By induction, $\trden{\sctx} \vdash \trden{e_1} : \str$ and $\trden{\sctx} \vdash \trden{e_2} : \str$.
Thus, $\trden{\sctx} \vdash \tconcat{\trden{e_1}}{\trden{e_2}} : \str$ by P-T-Concat.

\item \textbf{Case S-T-Case}.
Suppose $\sctx \vdash \strcase{e_1}{e_2}{x,y.e_3} : \sigma$ and $\sctx \vdash e_1 : \stringin{r}$ and $\sctx \vdash e_2 : \sigma$ and $\sctx, x : \stringin{\lhead{r}}, y : \stringin{\ltail{r}} \vdash e_3 : \sigma$. We have by definition:
\begin{align*}
\trden{\strcase{e_1}{e_2}{x, y.e_3}} &= \pstrcase{\trden{e_1}}{\trden{e_2}}{x, y.\trden{e_3}}\\
\trden{\stringin{r}} &= \str\\
\trden{\stringin{\lhead{r}}} &= \str\\
\trden{\stringin{\ltail{r}}} &= \str\\
\trden{\sctx, x : \stringin{\lhead{r}}, y : \stringin{\ltail{r}}} &= \trden{\sctx}, x : \str, y : \str
\end{align*}

By induction, $\trden{\sctx} \vdash \trden{e_1} : \str$ and 
$\trden{\sctx} \vdash \trden{e_2} : \trden{\sigma}$, and
$\trden{\sctx}, x : \str, y : \str \vdash \trden{e_3} : \trden{\sigma}$.
By P-T-Case, we have that $\trden{\sctx} \vdash \pstrcase{\trden{e_1}}{\trden{e_2}}{x, y.\trden{e_3}} : \trden{\sigma}$.

\item \textbf{Case S-T-Replace}.
Suppose $\sctx \vdash \rreplace{r}{e_1}{e_2} : \stringin{\lreplace{r}{r_1}{r_2}}$ and $\sctx \vdash e_1 : \stringin{r_1}$ and $\sctx \vdash e_2 : \stringin{r_2}$. We have by definition:
\begin{align*}
\trden{\rreplace{r}{e_1}{e_2}} &= \preplace{\rx{r}}{\trden{e_1}}{\trden{e_2}}\\
\trden{\stringin{r_1}} &= \str\\
\trden{\stringin{r_2}} &= \str\\
\trden{\stringin{\lreplace{r}{r_1}{r_2}}} &= \str
\end{align*}

By induction, we have that $\trden{\sctx} \vdash \trden{e_1} : \str$ and $\trden{\sctx} \vdash \trden{e_2} : \str$. By P-T-Regex, we have that $\trden{\sctx} \vdash \rx{r} : \regex$. By P-T-Replace, we have that $\trden{\sctx} \vdash \preplace{\rx{r}}{\trden{e_1}}{\trden{e_2}} : \str$.

\item \textbf{Case S-T-SafeCoerce}.
Suppose $\sctx \vdash \rcoerce{r}{e} : \stringin{r}$ and $\sctx \vdash e : \stringin{r'}$. By definition, $\trden{ \rcoerce{r}{e} } = \trden{e}$.
By induction, $\trden{\sctx} \vdash \trden{e} : \trden{\stringin{r'}}$.

\item \textbf{Case S-T-Check}.
Suppose $\sctx \vdash \rcheck{r}{e_0}{x.e_1}{e_2} : \sigma$ where
$\sctx \vdash e_0 : \stringin{r'}$ and 
$\sctx, x : \stringin{r} \vdash e_1 : \sigma$ and
$\sctx \vdash e_2 : \sigma$. We have by definition:
\begin{align*}
\trden{\rcheck{r}{e_0}{x.e_1}{e_2}} &= \tcheck{\rx{r}}{\trden{e_0}}{(\lambda x : \str.\trden{e_1}) \trden{e_0}}{\trden{e_2}}\\
\trden{\stringin{r'}} &= \str\\
\trden{\stringin{r}} &= \str\\
\trden{\sctx, x : \stringin{r}} &= \trden{\sctx}, x : \str
\end{align*}

By induction, we have that $\trden{\sctx} \vdash \trden{e_0} : \str$ and $\trden{\sctx}, x : \str \vdash \trden{e_1} : \trden{\sigma}$ and $\trden{\sctx} \vdash \trden{e_2} : \trden{\sigma}$.

By P-T-Regex, we have that $\trden{\sctx} \vdash \rx{r} : \regex$.

By P-T-Abs and P-T-App, we have that $\trden{\sctx} \vdash (\lambda x : \str.\trden{e_1})(\trden{e_0}) : \trden{\sigma}$.

By P-T-Check, we have that $\trden{\sctx} \vdash \tcheck{\rx{r}}{\trden{e_0}}{(\lambda x : \str.\trden{e_1})(\trden{e_0})}{\trden{e_2}} : \trden{\sigma}$.

\end{itemize}
\end{proof}

\begin{ass}[Multistep Closure]\label{ass:closure} The following closure properties hold:
\begin{enumerate}
\item If $\iota_1 \mapsto^{*} \iota_1'$ then $\iota_1(\iota_2) \mapsto^{*} \iota_1'(\iota_2)$.
\item If $\iota_2 \mapsto^{*} \iota_2'$ then $\dot{v}_1(\iota_2) \mapsto^{*} \dot{v}_1(\iota_2')$.
\item \todo{remaining cases}
\end{enumerate}
\end{ass}

\begin{thm}[Translation Correctness]
If $\emptyset \vdash e : \sigma$ and $e \mapsto e'$ then $\trden{e} \mapsto^* \trden{e'}$.
\end{thm}
\begin{proof}
By induction on evaluation and typing.

\begin{itemize}[label=$ $,itemsep=1ex]

\item \textbf{Case SS-E-AppLeft}. 
Suppose $e_1(e_2) \mapsto e_1'(e_2)$ and $e_1 \mapsto e_1'$. We have by definition that
\begin{align*}
    \trden{e_1(e_2)} &= \trden{e_1}(\trden{e_2})\\
    \trden{e_1'(e_2)} &= \trden{e_1'}(\trden{e_2})
\end{align*}

The only typing rule that applies is S-T--App, so $\emptyset \vdash e_1 : \sigma_2 \rightarrow \sigma$.

Inductively, we have that $\trden{e_1} \mapsto^{*} \trden{e_1'}$.

By Assumption \ref{ass:closure}.1, we have that $\trden{e_1}(\trden{e_2}) \mapsto^{*} \trden{e_1'}(\trden{e_2})$.
\end{itemize}
\end{proof}

\begin{thm}[Translation Correctness]\label{thm:trcorrect}
  If $\sctx \vdash e : \sigma$ then 
  there exists an $\iota$ such that $\trden{e} = \iota$
  and $\trden{\sctx} \vdash \iota : \trden{\sigma}$.
  Furthermore, if $e \mapsto^* v$ then
  $\iota \mapsto^* \dot{v}$ such that
  $\trden{v} = \dot{v}$.
\end{thm}
\begin{proof}
\todo{This proof needs to be changed to use only the small-step semantics.}
We present a proof by induction on the structure of $e$.
We write $e \leadsto \iota$ as shorthand for the final property.

\begin{itemize}[label=$ $, itemsep=1ex]
\item \textbf{Case $e = \rstr{s}$}. Suppose $\tctx \vdash \rstr{s} : \sigma$.

By examination the syntactic structure of conclusions in the relation S-T, 
we know this is true just in case $\sigma = \stringin{r}$ for some $r$ such that
$s \in \lang{r}$; and of course, there is always such an $r$.

There are no free variables in $\rstr{s}$, so we might as well proceed from the
fact that $\emptyset \vdash \rstr{s} : \stringin{r}$.

By definition of the translation ($\trden{\cdot}$) the following statements hold:
\begin{align}
\trden{\rstr{s}} &= \tstr{s} \\
\trden{\stringin{r}} &= \str \\
\trden{\emptyset} &= \emptyset
\end{align}
Note that $\emptyset \vdash \tstr{s} : \str$ by P-T-Str.
Recall that contexts are standard and, in particular, can be weakened.
So since $\trden{\tctx}$ is either a weakening of $\emptyset$ or $\emptyset$ itself,
$\trden{\tctx} \vdash \tstr{s} : \str$ by weakening.

Summarily, $\tstr{s}$ is a term of $\lambdap$ such that $\trden{\tctx} \vdash \tstr{s} : \trden{\sigma}$

It remains to be shown that there exist $v, \dot{v}$ such that $\rstr{s} \mapsto^* v$,
$\tstr{s} \mapsto^* \dot{v}$, and $\trden{v} = \dot{v}$. But this is immediate because
each term is already a value and $s=s$.

\item \textbf{Case $e = \rconcat{e_1}{e_2}$}.
The applicable typing rule is S-T-Concat, so $\sctx \vdash \rconcat{e_1}{e_2} : \stringin{r_1\cdot r_2}$
where $\sctx \vdash e_1 : \stringin{r_1}$ and $\sctx \vdash e_2 : \stringin{r_2}$.

By induction, $e_1 \leadsto \iota_1$ and $e_2 \leadsto \iota_2$.
Therefore, $\trden{\sctx} \vdash \tconcat{\iota_1}{\iota_2}$ by P-T-Concat.

By canonical forms, $e_1 \mapsto^* \rstr{s_1}$ where by induction $\iota_1 \mapsto^* \tstr{s_1}$.
Similarly, $e_2 \mapsto^* \rstr{s_2}$ and $\iota_2 \mapsto^* \tstr{s_2}$.
Therefore, $e \mapsto^* \rstr{s_1s_2}$ by S-E-Concat at last, and $\tconcat{\iota_1}{\iota_2} \mapsto^* \tstr{s_1s_2}$ by P-E-Concat at last.
Note that $\trden{\rstr{s_1s_2}} = \tstr{s_1s_2}$.

\item \textbf{Case $e = \strcase{e_1}{e_2}{x,y.e_3}$}. This case relies on our definition
of context translation.

Suppose $\sctx \vdash \strcase{e_1}{e_2}{x,y.e_3} : \sigma$.
By inversion of the typing relation it follows that
$\sctx \vdash e_1 : \stringin{r}$, $\sctx \vdash e_2 : \sigma$ and $\sctx, x : \stringin{\lhead{r}}, y : \stringin{\ltail{r}} \vdash e_3 : \sigma$.

By induction, there exists an $\iota_1$ 
such that $e_1 \mapsto \iota_1$.
%such that $\trden{e_1} = \iota_1$ and
%$\trden{\sctx} \vdash \iota_1 : \trden{\sigma}$.
%, and $e_1 \leadsto \iota_1$. Similarly for $e_2$ and some $\iota_2$.

By canonical forms, $e_1 \mapsto^* \rstr{s}$. Therefore, $\iota_1 \mapsto* \tstr{s}$ because $e_1 \leadsto \iota_1$.

Choose $\iota = \pstrcase{\iota_1}{\iota_2}{x,y.\iota_3}$ and note that by the properties established via induction,
$\trden{e} = \iota$ and $\trden{\sctx} \vdash \iota : \trden{\sigma}$.

To prove the evaluation correspondence, we consider two cases for the value of $s$.

Suppose $s = \epsilon$. Then $e \mapsto^* v$ where $e_2 \mapsto^* v$,
from which it follows that 
$\iota \mapsto^* \dot{v}$ where $\iota_2 \mapsto^* \dot{v}$.
But recall that $e_2 \leadsto v_2$ and so $\trden{v} = \dot{v}$.

Suppose otherwise that $s = at$ for some character $a$ and string $t$.
Then $e \mapsto^* v$ where $[a, t / x, y] e_3 \mapsto^* v$.
Similarly, $\iota \mapsto^* \dot{v}$ where $[a, t / x, y] \iota_3 \mapsto^* \dot{v}$

\item \textbf{Case $e = \rreplace{r}{e_1}{e_2}$}.
There is only one applicable typing rule, so suppose
$\sctx \vdash \rreplace{r}{e_1}{e_2} : \stringin{\lreplace{r}{e_1}{e_2}}$.
Let $\tctx = \trden{\sctx}$.
Note that $\trden{\rreplace{r}{e_1}{e_2}} = \treplace{\rx{r}}{\iota_1}{\iota_2}$
where by induction $\trden{e_1} = \iota_1$ and $\trden{e_2} = \iota_2$
such that $\tctx \vdash \iota_1$ and $\tctx \vdash \iota_2$.
It follows by P-T-Replace that $\tctx \vdash \treplace{\rx{r}}{\iota_1}{\iota_2} : \str$.
Finally, note that $\trden{\stringin{\lreplace{r}{e_1}{e_2}}} = \str$.

For evaluation correspondence, note that $\trden{ \rstr{\lreplace{r}{s_1}{s_2}} } = \rstr{ \lreplace{r}{s_1}{s_2} }$ and
so it suffices to show that $\treplace{\rx{r}}{\iota_1}{\iota_2} \mapsto^* \rstr{r}{s_1}{s_2}$.
Note that $\lreplace{r}{e_1}{e_2} \mapsto^* \rstr{\lreplace{r}{s_1}{s_2}}$ 
where $e_1 \mapsto^* \rstr{s_1}$, $e_2 \mapsto^* \rstr{s_2}$, $r \mapsto^* r$.
By induction, $\iota_1 \mapsto^* \rstr{s_1}, \iota_2 \mapsto^* \rstr{s_2}$, and $\rx{r} \mapsto^* \rx{r}$.
So by S-E-Replace, the sufficient condition holds.

\item \textbf{Case $e = \rcoerce{r}{e'}$}.
The only applicable tpying rule is S-T-SafeCoerce, so suppose
$\sctx \vdash \rcoerce{r}{e'} : \stringin{r}$ where
$\sctx \vdash e' : \stringin{r'}$ and $\lang{r'} \subseteq \lang{r}$.
By induction, $e' \leadsto \iota$ for some $\iota$.
Therefore, $\trden{\coerce{r}{e'}} = \iota$ by Tr-SafeCoerce.

For evaluation correspondence, note that $e \mapsto^* v$ where
$e' \mapsto^* v$. The result follows by induction because $e' \leadsto \iota$. 

\item \textbf{Case $e = \rcheck{r}{e_1}{x.e_2}{e_3}$}.
The applicable typing rule is S-T-Check,
so $\sctx \vdash e : \sigma$ where 
$\sctx \vdash e_1 : \stringin{r}$,
$\sctx, x : \stringin{r} \vdash e_2 : \sigma$,
and $\sctx \vdash e_3 : \sigma$.
By induction and a corresponding substitution principle there exists $\iota_1, \iota_2, \iota_3$ such that
$e_1 \leadsto \iota_1$, 
$e_2 \leadsto \iota_2$ in context $\sctx, s : \stringin{r}$, and
$e_3 \leadsto \iota_3$.
Choose $\iota = \tcheck{\rx{r}}{\iota_1}{\lambda x . \iota_2}{\iota_3}$.
The result follows by induction.

\end{itemize}
\end{proof}

\begin{thm}[Correctness of Input Sanitation for Translated Terms]\label{thm:main}
  If $\trden{e} = \iota$ and $\emptyset \vdash e : \stringin{r}$ then $\iota \mapsto^* \tstr{s}$
  for $s \in \lang{r}$.
\end{thm}
\begin{proof}
  By \ref{thm:scorrect}, $e \mapsto^* \rstr{s}$ where $\emptyset \vdash \rstr{s} : \stringin{r}$. 
  Therefore, $s \in \lang{r}$.
  Note that $\trden{\cdot}$ is a function and $\trden{\rstr{s}} = \tstr{s}$; 
  therefore, by theorem \ref{thm:trcorrect}, $\iota \mapsto^* \tstr{s}$.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\bibliographystyle{abbrv}
\bibliography{research}



\clearpage
\renewcommand{\grammarlabel}[2]{#1\hfill#2}
\begin{figure}[b]
\small
  \begin{grammar}
<$r$> ::= $\epsilon$ | $a$ | $r \cdot r$ | $r + r$ | $r*$ \hfill $a \in \Sigma$

\caption[Syntax of Regular Expressions]{Syntax of regular expressions over the alphabet $\Sigma$.}
\label{fig:regex}
\end{grammar}
\end{figure}
\begin{figure}[t]
\small
  \begin{grammar}
<$\sigma$> ::=  $\sigma \rightarrow \sigma$ | $\stringin{r}$    \hfill  source types

<$e$> ::= 
      $x$ | $v$ | $e(e)$ \hfill source terms \alt 
      $\rsconcat{e}{e}$ | $\strcase{e}{e}{x,y.e}$ \hfill $s \in \Sigma^{*}$ \alt
      $\sisubst{r}{e}{e}$ | $\rcoerce{r}{e}$ | $\rcheck{r}{e}{x.e}{e}$

<$v$> ::= $\lambda x . e$ | $\strin{s}$ \hfill source values 
\caption{Syntax of $\lambda_{RS}$}
\label{fig:glambdas}
\end{grammar}
\end{figure}


\renewcommand{\grammarlabel}[2]{#1\hfill#2}

\begin{figure}[t]
\small
  \begin{grammar}

<$\tau$> ::= $\tau \rightarrow \tau$ | $\str$ | $\regex$ \hfill target types

<$\iota$> ::= $x$ | $\dot{v}$ | $\iota(\iota)$ \hfill target terms \alt
$\tconcat{\iota}{\iota}$ | $\pstrcase{\iota}{\iota}{x,y.\iota}$ \alt
  $\preplace{\iota}{\iota}{\iota}$ | $\tcheck{\iota}{\iota}{\iota}{\iota}$ 

  <$\dot{v}$> ::= $\lambda x . \iota$ | $\tstr{s}$ | $\rx{r}$ \hfill target values

\end{grammar}
\caption{Syntax of $\lambdap$}
\label{fig:lcsSyntax}
\end{figure}


\begin{figure}[t]
\small
$\fbox{\inferrule{}{\sctx \vdash e : \sigma}}$
~~~~$\sctx ::= \emptyset \pipe \sctx, x : \sigma$
\begin{mathpar}
\inferrule[S-T-Var]
{ x:\sigma \in \sctx }
{ \sctx \vdash x:\sigma}

\inferrule[S-T-Abs]
{\sctx, x : \sigma_1 \vdash e : \sigma_2}
{\sctx \vdash \lambda x.e : \sigma_1 \rightarrow \sigma_2}

\inferrule[S-T-App]
{\sctx \vdash e_1 : \sigma_2 \rightarrow \sigma \\ \sctx \vdash e_2 : \sigma_2}
{\sctx \vdash e_1(e_2) : \sigma}
  
\inferrule[S-T-Stringin-I]
{s \in \lang{r}}
{\sctx \vdash \strin{s} : \stringin{r}}

\inferrule[S-T-Concat]
{\sctx \vdash e_1 : \stringin{r_1} \\ \sctx \vdash e_2 : \stringin{r_2}}
{\sctx \vdash \rsconcat{e_1}{e_2} : \stringin{r_1 \cdot r_2}}

\inferrule[S-T-Case]
{ \sctx \vdash e_1 : \stringin{r} \\
  \sctx \vdash e_2 : \sigma \\
  \sctx, x : \stringin{\lhead{r}}, y : \stringin{\ltail{r}} \vdash e_3 : \sigma
}
{
  \sctx \vdash \strcase{e_1}{e_2}{x,y.e_3} : \sigma
}

\inferrule[S-T-Replace]
{\sctx \vdash e_1 : \stringin{r_1} \\ \sctx \vdash e_2 : \stringin{r_2} }
{\sctx \vdash \sisubst{r}{e_1}{e_2} : \stringin{\lreplace{r}{r_1}{r_2}}}

\inferrule[S-T-SafeCoerce]
{\sctx \vdash e : \stringin{r'} \\ \lang{r'} \subseteq \lang{r}}
{\sctx \vdash \coerce{r}{e} : \stringin{r}}

\inferrule[S-T-Check]
{\sctx \vdash e_0 : \stringin{r} \\ \sctx, x:\stringin{r} \vdash e_1 : \sigma \\ \sctx \vdash e_2 : \sigma}
{\sctx \vdash \rcheck{r}{e_0}{x.e_1}{e_2} : \sigma}
\end{mathpar}

\caption[Static Semantics of $\lambdas$]{Typing rules for $\lambdas$. 
The typing context $\sctx$ is standard.}
\label{fig:slambdas}
\end{figure}

%
%\begin{figure}
%  \small
%$\fbox{\inferrule{}{e \sreduces v}}$
%\begin{mathpar}
%\inferrule[S-E-Abs]                                                             
%{ \ }                                                                           
%{\lambda x.e \sreduces \lambda x.e}                                             
%
%\inferrule[S-E-App]
%{ e_1 \sreduces \lambda x . e_3 \\ e_2 \sreduces v_2 \\ [ v_2 / x ] e_3 \sreduces v }
%{ e_1(e_2) \sreduces v }
%
%\inferrule[S-E-RStr]
%{ \ }
%{\strin{s} \sreduces \strin{s}}
%
%\inferrule[S-E-Concat]
%{e_1 \sreduces \strin{s_1} \\ e_2 \sreduces \strin{s_2}} 
%{\rsconcat{e_1}{e_2} \sreduces \strin{s_1 s_2}} % ???
%
%\inferrule[S-E-Case-$\epsilon$]
%{
%  e_1 \sreduces \strin{\epsilon} \\
%  e_2 \sreduces v_2
%}
%{
%  \strcase{e_1}{e_2}{x,y.e_3} \sreduces v_2
%}
%
%\inferrule[S-E-Case-Concat]
%{
%  e_1 \sreduces \strin{a s} \\
%  [\rstr{a},\rstr{s} / x,y]e_3 \sreduces v_3
%}
%{
%  \strcase{e_1}{e_2}{x,y.e_3} \sreduces v_3
%}
%
%\inferrule[S-E-Replace]
%{e_1 \sreduces \strin{s_1} \\ e_2 \sreduces \strin{s_2} } 
%{\sisubst{r}{e_1}{e_2} \sreduces \sistr{ \lsubst{r}{s_1}{s_2}  }}
%
%\inferrule[S-E-SafeCoerce]
%{e \sreduces \strin{s}}
%{\coerce{r}{e} \sreduces \strin{s}}
%
%\inferrule[S-E-Check-Ok]
%{e \sreduces \strin{s} \\ s \in \lang{r} \\ [\strin{s} / x]e_1 \sreduces v}
%{
%  \rcheck{r}{e}{x.e_1}{e_2} \sreduces v
%}
%
%\inferrule[S-E-Check-NotOk]
%{
%  e \sreduces \strin{s} \\ s \not \in \lang{r} \\
%  e_2 \sreduces v
%}
%{
%  \rcheck{r}{e}{x.e_1}{e_2} \sreduces v
%}
%\end{mathpar}
%\caption{Big step semantics for $\lambdas$.}
%\label{fig:dlambdas}
%\end{figure}


% \begin{figure}
%   \small
% $\fbox{\inferrule{}{e \mapsto e}}$

% \begin{mathpar}

% \inferrule[SS-E-AppLeft]
% {e_1 \mapsto e_1'}
% {e_1(e_2) \mapsto e_1'(e_2)}

% \inferrule[SS-E-AppRight]
% {e_2 \mapsto e_2'}
% {v_1(e_2) \mapsto v_1(e_2')}

% \inferrule[SS-E-AppAbs]
% { \ }
% {(\lambda x : \tau . e) v_2 \mapsto [v_2 / x]e}

% \end{mathpar}

% \fbox{\inferrule{}{e \mapsto^* e}}

% \begin{mathpar}

% \inferrule[RT-Refl]
% { \ }
% {e \mapsto^* e}

% \inferrule[RT-Trans]
% { e \mapsto^* e' \\ e' \mapsto e'' }
% { e \mapsto^* e'' }

% \end{mathpar}

% \label{fig:lambda}
% \caption[Dynamic Semantics of $\lambdas$ (1 of 2)]{Call-by-name small step semantics for $\lambdas$ and its reflexive, transitive closure.} \label{fig:lambda}
% \end{figure}

\begin{figure}
  \small
$\fbox{\inferrule{}{e \mapsto e}}$ 
%$\fbox{\inferrule{}{e \mapsto e}} \  \fbox{ \inferrule{}{v \ \val}}$
\begin{mathpar}
\inferrule[SS-E-AppLeft]
{e_1 \mapsto e_1'}
{e_1(e_2) \mapsto e_1'(e_2)}

\inferrule[SS-E-AppRight]
{e_2 \mapsto e_2'}
{v_1(e_2) \mapsto v_1(e_2')}

\inferrule[SS-E-AppAbs]
{ \ }
{(\lambda x : \sigma . e) v_2 \mapsto [v_2 / x]e}

\inferrule[SS-E-Concat-Left]
{e_1 \mapsto e_1'}
{\rsconcat{e_1}{e_2} \mapsto \rsconcat{e_1'}{e_2}}

\inferrule[SS-E-Concat-Right]
{e_2 \mapsto e_2'}
{\rsconcat{v_1}{e_2} \mapsto \rsconcat{v_1}{e_2'}}

\inferrule[SS-E-Concat]
{ \ }
{\rsconcat{\strin{s_1}}{\strin{s_2}} \mapsto \strin{s_1 s_2}} % ???

\inferrule[SS-E-Case-Left]
{
  e_1 \mapsto e_1'
}
{
  \strcase{e_1}{e_2}{x,y.e_3} \mapsto \strcase{e_1'}{e_2}{x,y.e_3}
}

\inferrule[SS-E-Case-$\epsilon$-val]
{
  \ 
}
{
  \strcase{\strin{\epsilon}}{e_2}{x.y.e_3} \mapsto e_2
}

\inferrule[SS-E-Case-Concat]
{
  \ 
}
{
  \strcase{\strin{a s}}{e_2}{x,y.e_3} \mapsto [\rstr{a},\rstr{s} / x,y]e_3 
}

\inferrule[SS-E-Replace-Left]
{e_1 \mapsto e_1'}
{ \sisubst{r}{v_1}{e_2} \mapsto \sisubst{r}{v_1'}{e_2}}

\inferrule[SS-E-Replace-Right]
{e_2 \mapsto e_2'}
{ \sisubst{r}{e_1}{e_2} \mapsto \sisubst{r}{e_1}{e_2'}}

\inferrule[SS-E-Replace]
{ \ }
{\sisubst{r}{\strin{s_1}}{\strin{s_2}} \mapsto \sistr{\lsubst{r}{s_1}{s_2}}}

\inferrule[SS-E-SafeCoerce-Step]
{e \mapsto e'}
{\coerce{r}{e} \mapsto \coerce{r}{e'}}

\inferrule[SS-E-SafeCoerce]
{ \ }
{ \coerce{r}{\rstr{s}} \mapsto \rstr{s}}

%%% NRF-bookmark1
\inferrule[SS-E-Check-StepLeft]
{e \mapsto e'}
{\rcheck{r}{e}{x.e_1}{e_2} \mapsto \rcheck{r}{e'}{x.e_1}{e_2}}

\inferrule[SS-E-Check-Ok]
{s \in \lang{r}}
{\rcheck{r}{\strin{s}}{x.e_1}{e_2} \mapsto [\rstr{s} / x]e_1}

\inferrule[SS-E-Check-NotOk]
{s \not \in \lang{r}}
{\rcheck{r}{\strin{s}}{x.e_1}{e_2} \mapsto e_2} 

\end{mathpar}
\caption[Dynamic Semantics of $\lambdas$]{Small step semantics for $\lambdas$.}
\label{fig:sdlambdas}
\end{figure}




\begin{figure}[t]\label{fig:lambdap}
\small
$\fbox{\inferrule{}{\tctx \vdash \iota : \tau}}$
~~~~$\tctx ::= \emptyset \pipe \tctx, x : \tau$

\begin{mathpar}
\inferrule[P-T-Var]
{ x:\tau \in \tctx }
{ \tctx \vdash x:\tau }

\inferrule[P-T-Abs]
{\tctx, x : \tau_1 \vdash \iota_2 : \tau_2}
{\tctx \vdash \lambda x.\iota_2 : \tau_1 \rightarrow \tau_2}

\inferrule[P-T-App]
{\tctx \vdash \iota_1 : \tau_2 \rightarrow \tau \\ \tctx \vdash \iota_2 : \tau_2}
{\tctx \vdash \iota_1(\iota_2) : \iota}

\inferrule[P-T-String]
{ \ }
{\tctx \vdash \tstr{s} : \str}

\inferrule[P-T-Regex]
{ \ }
{\tctx \vdash \rx{r} : \regex}

\inferrule[P-T-Concat]
{\tctx \vdash \iota_1 : \str \\ \tctx \vdash \iota_2 : \str}
{\tctx \vdash \tconcat{\iota_1}{\iota_2} : \str}

\inferrule[P-T-Case]
{\tctx \vdash \iota_1 : \str \\ \tctx \vdash \iota_2 : \tau \\ \tctx, x:\str, y:\str \vdash \iota_3:\tau}
{\tctx \vdash \pstrcase{\iota_1}{\iota_2}{x,y.\iota_3} : \tau}

\inferrule[P-T-Replace]
{\tctx \vdash \iota_1 : \regex \\ \tctx \vdash \iota_2 : \str \\ \tctx \vdash \iota_3 : \str }
{\tctx \vdash \preplace{\iota_1}{\iota_2}{\iota_3} : \str}

\inferrule[P-T-Check]
{\tctx \vdash \iota_1 : \regex \\ \tctx \vdash \iota_2 : \str \\ \tctx \vdash \iota_3 : \tau \\ \tctx \vdash \iota_4 : \tau}
{\tctx \vdash \tcheck{\iota_1}{\iota_2}{\iota_3}{\iota_4} : \tau}
\end{mathpar}
\caption[Static Semantics of $\lambdap$]{Typing rules for $\lambdap$.
The typing context $\tctx$ is standard.}
\label{fig:slambdap}
\end{figure}
%
%\begin{figure}[t]
%\small
%$\fbox{\inferrule{}{\iota \treduces \dot{v}}}$
%
%\begin{mathpar}
%\inferrule[P-E-Abs]
%{ \ }
%{\lambda x.e \sreduces \lambda x.e}
%
%\inferrule[P-E-App]
%{ \iota_1 \sreduces \lambda x . \iota_3 \\  \iota_2 \sreduces \dot{v}_2 \\ [\dot{v}_2 / x] \iota_3 \sreduces \dot{v}_3}
%{ \iota_1(\iota_2) \sreduces \dot{v}_3}
%
%\inferrule[P-E-Str]
%{ \ }
%{\tstr{s} \treduces \tstr{s}}
%
%\inferrule[P-E-Rx]
%{ \ }
%{\rx{r} \treduces \rx{r}}
%
%\inferrule[P-E-Concat]
%{\iota_1 \treduces \tstr{s_1} \\ \iota_2 \treduces \tstr{s_2}} 
%{\tconcat{\iota_1}{\iota_2} \treduces \tstr{s_1 s_2}} % ???
%
%\inferrule[P-E-Case-$\epsilon$]
%{
%  \iota_1 \treduces \tstr{ \epsilon } \\
%  \iota_2 \treduces \dot{v_2} \\
%}
%{
%  \pstrcase{\iota_1}{\iota_2}{x,y.\iota_3} \treduces \dot{v_2}
%}
%
%\inferrule[P-E-Case-Concat]
%{
%  \iota_1 \treduces \tstr{as} \\
%  [\tstr{a},\tstr{s}/x,y] \iota_3 \treduces \dot{v} 
%}
%{
%  \pstrcase{\iota_1}{\iota_2}{x,y.\iota_3} \treduces \dot{v}
%}
%
%\inferrule[P-E-Replace]
%{\iota_1 \treduces \rx{r} \\ \iota_2 \treduces \tstr{s_2} \\ \iota_3 \treduces \tstr{s_3} } 
%{\preplace{\iota_1}{\iota_2}{\iota_3} \treduces \tstr{\lsubst{r}{s_2}{s_3} }}
%
%\inferrule[P-E-Check-OK]
%{
%  \iota_x \treduces \rx{r} \\
%  \iota \treduces \tstr{s} \\ 
%s \in \lang{r} \\ 
%\iota_1 \treduces \dot{v_1} 
%}
%{
%  \tcheck{\iota_x}{\iota}{\iota_1}{\iota_2} \treduces \dot{v_1}
%}
%
%\inferrule[P-E-Check-NotOK]
%{\iota_x \treduces \rx{r} \\ \iota \treduces \tstr{s} \\ s \not \in \lang{r} \\ \iota_2 \treduces \dot{v_2}}
%{\tcheck{\iota_x}{\iota}{\iota_1}{\iota_2} \treduces \dot{v_2}}
%\end{mathpar}
%\caption{Big step semantics for $\lambdap$}.
%\label{fig:dlambdap}
%\end{figure}
%


\begin{figure}[t]
\small
$\fbox{\inferrule{}{\iota \mapsto \iota}}$

\begin{mathpar}
\inferrule[PS-E-AppLeft]
{\iota_1 \mapsto \iota_1'}
{\iota_1(\iota_2) \mapsto \iota_1'(\iota_2)}

\inferrule[PS-E-AppRight]
{\iota_2 \mapsto \iota_2'}
{\dot{v}_1(\iota_2) \mapsto \dot{v}_1(\iota_2')}

\inferrule[PS-E-AppAbs]
{ \ }
{(\lambda x : \tau . \iota) \dot{v}_2 \mapsto [\dot{v}_2 / x]\iota}

\inferrule[PS-E-ConcatLeft]
{\iota_1 \mapsto \iota_1'}
{\tconcat{\iota_1}{\iota_2} \mapsto \tconcat{\iota_1'}{\iota_2}}

\inferrule[PS-E-ConcatRight]
{\iota_2 \mapsto \iota_2'}
{\tconcat{\tstr{s_1}}{\iota_2} \mapsto \tconcat{\tstr{s_1}}{\iota_2'}}

\inferrule[PS-E-Concat]
{\ }
{\tconcat{\tstr{s_1}}{\tstr{s_2}} \mapsto \tstr{s_1s_2}}

\inferrule[PS-E-CaseLeft]
{ \iota_1 \mapsto \iota_1' }
{ \pstrcase{\iota_1}{\iota_2}{x,y.\iota_3} \mapsto \pstrcase{\iota_1'}{\iota_2}{x,y.\iota_3} }


\inferrule[PS-E-Case-Epsilon]
{  }
{ \pstrcase{\tstr{\epsilon}}{\iota_2}{x,y.\iota_3} \mapsto \iota_2}

\inferrule[PS-E-Case-Cons]
{ }
{ \pstrcase{\tstr{as}}{\iota_2}{x,y.\iota_3} \mapsto [\tstr{a}, \tstr{s}/x, y]\iota_3}


\inferrule[PS-E-ReplaceLeft]
{\iota_1 \mapsto \iota_1'}
{ \preplace{\iota_1}{\iota_2}{\iota_3} \mapsto \preplace{\iota_1'}{\iota_2}{\iota_3} }

\inferrule[PS-E-ReplaceMid]
{\iota_2 \mapsto \iota_2'}
{ \preplace{\rx{r}}{\iota_2}{\iota_3} \mapsto \preplace{\rx{r}}{\iota_2'}{\iota_3} }

\inferrule[PS-E-ReplaceRight]
{\iota_3 \mapsto \iota_3'}
{ \preplace{\rx{r}}{\tstr{s_2}}{\iota_3} \mapsto \preplace{\rx{r}}{\tstr{s_2}}{\iota_3'} }

\inferrule[PS-E-Replace]
{\ }
{ \preplace{\rx{r}}{\tstr{s_2}}{\tstr{s_3}} \mapsto \tstr{\lsubst{r}{s_2}{s_3}} }

\inferrule[PS-E-CheckLeft]
{ \iota_1 \mapsto \iota_1' }
{ \tcheck{\iota_1}{\iota_2}{\iota_3}{\iota_4} \mapsto \tcheck{\iota_1'}{\iota_2}{\iota_3}{\iota_4} }

\inferrule[PS-E-CheckRight]
{ \iota_2 \mapsto \iota_2' }
{ \tcheck{\rx{r}}{\iota_2}{\iota_3}{\iota_4} \mapsto \tcheck{\rx{r}}{\iota_2'}{\iota_3}{\iota_4} }

\inferrule[PS-E-Check-OK]
{ s \in \lang{r} }
{ \tcheck{\rx{r}}{\tstr{s}}{\iota_3}{\iota_4} \mapsto \iota_3}

\inferrule[PS-E-Check-NotOK]
{ s \not\in \lang{r} }
{ \tcheck{\rx{r}}{\tstr{s}}{\iota_3}{\iota_4} \mapsto \iota_4}
\end{mathpar}
\caption[Dynamic Semantics of $\lambdap$]{Small step semantics for $\lambdap$}.
\label{fig:sdlambdap}
\end{figure}



\begin{figure}[h]
\small
$\fbox{\inferrule{}{\trden{\sigma}=\tau}}$
\begin{align*}
    \trden{\stringin{r}} &= \str\\
    \trden{\sigma_1 \rightarrow \sigma_2} &= \trden{\sigma_1} \rightarrow \trden{\sigma_2}
\end{align*}
$\fbox{\inferrule{}{\trden{\Psi}=\Theta}}$
\begin{align*}
    \trden{\emptyset} &= \emptyset\\
    \trden{\sctx, x : \sigma} &= \trden{\sctx}, x : \trden{\sigma}
\end{align*}
  $\fbox{\inferrule{}{ \trden{e} = \iota }}$
\begin{align*}
    \trden{x} &= x\\
    \trden{\lambda x : \sigma.e} &= \lambda x : \trden{\sigma}.\trden{e}\\
    \trden{e_1(e_2)} &= \trden{e_1}(\trden{e_2})\\
    \trden{\rstr{s}} &= \tstr{s}\\
    \trden{\strcase{e_1}{e_2}{x,y.e_3}} &= \pstrcase{\trden{e_1}}{\trden{e_2}}{x, y.\trden{e_3}}\\
    \trden{\rsconcat{e_1}{e_2}} &= \tconcat{\trden{e_1}}{\trden{e_2}}\\
    \trden{\sisubst{r}{e_1}{e_2}} &= \preplace{\rx{r}}{\trden{e_1}}{\trden{e_2}}\\
    \trden{\coerce{r}{e}} &= \trden{e}\\
    \trden{\rcheck{r}{e}{x.e_1}{e_2}} &= \tcheck{\rx{r}}{\trden{e}}{(\lambda x : \str.\trden{e_1})(\trden{e})}{\trden{e_2}}
\end{align*}
\caption{Translation from $\lambdas$ to $\lambdap$}
\label{fig:tr}
\end{figure}
\end{document}
