\documentclass[9pt]{sig-alternate}
\newcommand{\lamAce}{\lambda_{\text{Ace}}}
% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.
\usepackage{afterpage}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb} 

% Hack. Something's wrong with PLAS paper when using the ACM Proc docclass
\let\proof\relax
\let\endproof\relax
\usepackage{amsthm}

\usepackage{ stmaryrd }
\usepackage{verbatimbox}
\input{../att-icfp14/macros-atlam}
\usepackage{alltt}
\renewcommand{\ttdefault}{txtt}
\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{light-gray}{gray}{0.5}
\usepackage{listings}
\usepackage{wasysym}
    \makeatletter
\usepackage{enumitem}
\usepackage{enumerate}

% \btIfInRange{number}{range list}{TRUE}{FALSE}
%
% Test if int number <number> is element of a (comma separated) list of ranges
% (such as: {1,3-5,7,10-12,14}) and processes <TRUE> or <FALSE> respectively
%
        \newcount\bt@rangea
        \newcount\bt@rangeb

        \newcommand\btIfInRange[2]{%
            \global\let\bt@inrange\@secondoftwo%
            \edef\bt@rangelist{#2}%
            \foreach \range in \bt@rangelist {%
                \afterassignment\bt@getrangeb%
                \bt@rangea=0\range\relax%
                \pgfmathtruncatemacro\result{ ( #1 >= \bt@rangea) && (#1 <= \bt@rangeb) }%
                \ifnum\result=1\relax%
                    \breakforeach%
                    \global\let\bt@inrange\@firstoftwo%
                \fi%
            }%
            \bt@inrange%
        }

        \newcommand\bt@getrangeb{%
            \@ifnextchar\relax%
            {\bt@rangeb=\bt@rangea}%
            {\@getrangeb}%
        }

        \def\@getrangeb-#1\relax{%
            \ifx\relax#1\relax%
                \bt@rangeb=100000%   \maxdimen is too large for pgfmath
            \else%
                \bt@rangeb=#1\relax%
            \fi%
        }

%
% \btLstHL{range list}
%
        \newcommand{\btLstHL}[1]{%
            \btIfInRange{\value{lstnumber}}{#1}%
            {\color{black!10}}%
            {\def\lst@linebgrd}%
        }%

%
% \btInputEmph[listing options]{range list}{file name}
%
        \newcommand{\btLstInputEmph}[3][\empty]{%
            \lstset{%
                linebackgroundcolor=\btLstHL{#2}%
                \lstinputlisting{#3}%
            }% \only
        }


        
% Patch line number key to call line background macro
        \lst@Key{numbers}{none}{%
            \def\lst@PlaceNumber{\lst@linebgrd}%
            \lstKV@SwitchCases{#1}{%
                none&\\%
                left&\def\lst@PlaceNumber{\llap{\normalfont
                \lst@numberstyle{\thelstnumber}\kern\lst@numbersep}\lst@linebgrd}\\%
                right&\def\lst@PlaceNumber{\rlap{\normalfont
                \kern\linewidth \kern\lst@numbersep
                \lst@numberstyle{\thelstnumber}}\lst@linebgrd}%
            }{%
                \PackageError{Listings}{Numbers #1 unknown}\@ehc%
            }%
        }

% New keys
        \lst@Key{linebackgroundcolor}{}{%
            \def\lst@linebgrdcolor{#1}%
        }
        \lst@Key{linebackgroundsep}{0pt}{%
            \def\lst@linebgrdsep{#1}%
        }
        \lst@Key{linebackgroundwidth}{\linewidth}{%
            \def\lst@linebgrdwidth{#1}%
        }
        \lst@Key{linebackgroundheight}{\ht\strutbox}{%
            \def\lst@linebgrdheight{#1}%
        }
        \lst@Key{linebackgrounddepth}{\dp\strutbox}{%
            \def\lst@linebgrddepth{#1}%
        }
        \lst@Key{linebackgroundcmd}{\color@block}{%
            \def\lst@linebgrdcmd{#1}%
        }

% Line Background macro
        \newcommand{\lst@linebgrd}{%
            \ifx\lst@linebgrdcolor\empty\else
                \rlap{%
                    \lst@basicstyle
                    \color{-.}% By default use the opposite (`-`) of the current color (`.`) as background
                    \lst@linebgrdcolor{%
                        \kern-\dimexpr\lst@linebgrdsep\relax%
                        \lst@linebgrdcmd{\lst@linebgrdwidth}{\lst@linebgrdheight}{\lst@linebgrddepth}%
                    }%
                }%
            \fi
        }

 % Heather-added packages for the fancy table
 \usepackage{longtable}
 \usepackage{booktabs}
 \usepackage{pdflscape}
 \usepackage{colortbl}%
 \newcommand{\myrowcolour}{\rowcolor[gray]{0.925}}
 \usepackage{wasysym}
 
    \makeatother

\lstset{
  language=Python,
  showstringspaces=false,
  formfeed=\newpage,
  tabsize=4,
  commentstyle=\itshape\color{light-gray},
  basicstyle=\ttfamily\scriptsize,
  morekeywords={lambda, self, assert, as, cls},
  numbers=left,
  numberstyle=\scriptsize\color{light-gray}\textsf,
  xleftmargin=2em,
  stringstyle=\color{mauve}
}
\lstdefinestyle{Bash}{
    language={}, 
    numbers=left,
    numberstyle=\scriptsize\color{light-gray}\textsf,
    moredelim=**[is][\color{blue}\bf\ttfamily]{`}{`},
}
\lstdefinestyle{OpenCL}{
	language=C++,
	morekeywords={kernel, __kernel, global, __global, size_t, get_global_id, sin, printf, int2}
}

\usepackage{float}
\floatstyle{ruled}
\newfloat{codelisting}{tp}{lop}
\floatname{codelisting}{Listing}
\setlength{\floatsep}{10pt}
\setlength{\textfloatsep}{10pt}


\usepackage{url}

\usepackage{todonotes}

\usepackage{placeins}

\usepackage{textpos}

\renewcommand\topfraction{0.85}
\renewcommand\bottomfraction{0.85}
\renewcommand\textfraction{0.1}
\renewcommand\floatpagefraction{0.85}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{bussproofs}    % Gentzen-style deduction trees *with aligned sequents!*
\usepackage{mathpartir}	% For type-settting type checking rule figures
\usepackage{syntax}		% For type-setting formal grammars.


\usepackage{hyperref}		% For links in citations

\usepackage{float}			% Make figures float if [H] option is passed.

\iffalse
\usepackage{listings}		% For typesetting code listings
\usepackage{callout}
\usepackage{titlesec}
\usepackage[T1]{fontenc}
\usepackage{upquote}
\lstset{upquote=true}
\fi

\usepackage{textcomp}		% For \textquotesingle as used in introduction
\usepackage{color}			% for box colors, like in TAPL.

\usepackage{amsmath}		% Begin Carthage default packages
\usepackage{makeidx}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphics}
\usepackage{enumerate}
\usepackage{multicol}
\usepackage{epsfig}
\usepackage{csquotes}
\usepackage{enumitem}

\newtheorem{thm}{Theorem}                                                       
\newtheorem{cor}[thm]{Corollary}                                                
\newtheorem{lem}[thm]{Lemma}                                                    
\newtheorem{prop}[thm]{Proposition}                                             
\newtheorem{ax}[thm]{Axiom}                                                     
\theoremstyle{definition}                                                       
\newtheorem{defn}[thm]{Definition}                                              
\newtheorem{exam}[thm]{Example}                                                 
\newtheorem{rem}[thm]{Remark} 

%
% For type setting inference rules with labels.
%
\newcommand{\inferlbl}[3]
			{\inferrule{#3}{#2}{\textsf{\footnotesize{\sc #1}}}}
\newcommand{\inferline}[3]
			{\inferrule{#3}{#2} & {\textsf{\footnotesize{\sc #1}}} \\ \\}

\newcommand{\Lagr}{\mathcal{L}}
\newcommand{\lang}[1]{\Lagr\{#1\}}
\newcommand{\stru}[2]{ {\tt string\_union}(#1,#2)}


\newcommand{\dconvert}[2]{ {\tt dconvert}(#1,#2) }
\newcommand{\filter}[2]{ {\tt filter}(#1,#2) }
\newcommand{\ifilter}[2]{ {\tt ifilter}(#1,#2) }

\newcommand{\reduces}{ \Rightarrow }
\newcommand{\gvd}{\Gamma \vdash }
\newcommand{\ovd}{\Omega \vdash }

\newcommand{\trep}{{\tt rep}}

\newcommand{\tstrf}[1]{`#1\textrm'} %??
\newcommand{\strf}[1]{``#1"}


\newcommand{\iso}{\cong}
%%
%% Source and Target language definitions.
%%
\newcommand{\lambdas}{\lambda_S}
\newcommand{\lambdap}{\lambda_P}

% Source language terms.
\newcommand{\sisubst}[3]{{\sf rreplace}[#1](#2,#3)} \newcommand{\rreplace}[3]{{\sf rreplace}[#1](#2,#3)} % lots of legacy naming around these parts...

\newcommand{\rssreplace}[3]{\sisubst{#1}{#2}{#2}} % TODO-nrf fix this.

\newcommand{\coerce}[2]{ {\sf rcoerce}[#1](#2)}
\newcommand{\rcoerce}[2]{{\sf rcoerce}[#1](#2)}
\newcommand{\sistr}[1]{{\sf rstr}[#1]}   \newcommand{\rstr}[1]{{\sf rstr}[#1]} % Lots of legacy naming around these parts...

\newcommand{\val}{{\sf val}}


\newcommand{\strin}[1]{\sistr{#1}}
\newcommand{\rsconcat}[2]{{\sf rconcat}(#1,#2)} \newcommand{\rconcat}[2]{{\sf rconcat}(#1,#2)} % lots of legact naming around these parts..

% Source language types.
\newcommand{\stringin}[1]{{\sf stringin}[#1]}

% target language terms.
\newcommand{\tsubst}[3]{{\sf replace}(#1,#2,#3)} \newcommand{\metareplace}[3]{{\sf replace}(#1,#2,#3)} % TODO-nrf rename the commands. Lots of legacy naming around these parts...

\newcommand{\tcheck}[2]{{\sf check}(#1, #2)}
\renewcommand{\tstr}[1]{{{\sf str}[#1]}}
\newcommand{\preplace}[3]{{\sf preplace}(#1,#2,#3)}
\newcommand{\tconcat}[2]{{\sf concat}(#1,#2)} \newcommand{\concat}[2]{{\sf concat}(#1,#2)} % lots of legacy naming around these parts...

\newcommand{\regext}[1]{ {\sf rx}[#1] } % TODO-nrf remove
\newcommand{\rx}[1]{ {\sf rx}[#1] }

% Target language types
\newcommand{\str}{{\sf string}}
\newcommand{\regex}{{\sf regex}}

% Meta-theoretic functions
\newcommand{\lsubst}[3]{{\tt lsubst}(#1,#2,#3)} % This used to render lreplace(...) so there're probably mistkes wherever this command was used now.
\newcommand{\lreplace}[3]{{\tt lreplace}(#1, #2, #3)}


% Judgements
\newcommand{\err}{\ {\sf err}}
\newcommand{\trden}[1]{\llbracket #1 \rrbracket} % = Translation Denotation.

% Relations
\newcommand{\treduces}{ \Downarrow }
\newcommand{\sreduces}{ \Downarrow }

%%
%% Constrain the size of full-page diagrams and rule lists
%%
%%\newcommand{\pagewidth}{5in}
%%\newcommand{\rulelistwidth}{3in}

% Names of type systems presented in paper
\newcommand{\lcs}{\lambda_{CS}}

\setlength{\grammarindent}{3em}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

%dep_docclass\conferenceinfo{-}{-} 
%dep_docclass\copyrightyear{-} 
%dep_docclass\copyrightdata{[to be supplied]} 

%\titlebanner{{\tt \textcolor{Red}{{\small Under Review -- distribute within CMU only.}}}}        % These are ignored unless
%\preprintfooter{Distribute within CMU only.}   % 'preprint' option specified.

\newcommand{\Ace}{\textsf{Ace}}

\title{Statically Typed String Sanitation Inside a Python}
\numberofauthors{3}
\author{
  \alignauthor
  Nathan Fulton
  \alignauthor
  Cyrus Omar
  \alignauthor
  Jonathan Aldrich
  \and
  \affaddr{Carnegie Mellon University}\\
  \affaddr{Pittsburgh, PA}\\
  \email{\{nathanfu, comar, aldrich\}@cs.cmu.edu}
}
%\authorinfo{~}{~}{~}
%\authorinfo{Nathan Fulton\and Cyrus Omar\and Jonathan Aldrich}
 %          {School of Computer Science\\
  %          Carnegie Mellon University
   %        \{nathanfu, comar, aldrich\}@cs.cmu.edu}

\maketitle
\begin{abstract}
%Evidence suggests that programmers are reluctant to adopt new languages to
Web applications ultimately generate strings containing commands, which are   executed by systems like web browsers and database engines. Strings constructed from user input that has not been properly sanitized can thus cause command injection vulnerabilities. %Structured frameworks for constructing commands centralizes control over string sanitization, but verifying that the framework itself sanitizes user input correctly can still be tricky.

In this paper, we introduce \emph{regular string types}, which classify strings known statically to be in a specified regular language and support operations like concatenation, substitution and coercion. Regular string types can be used to implement, in essentially a conventional manner, the parts of a web application or application framework that construct such command strings. Straightforward type annotations at key interfaces can be used to statically verify that sanitization has been performed correctly without introducing redundant run-time checks. We specify this type system as a minimal typed lambda calculus, $\lambda_{RS}$.

To be practical, adopting a type system like this should not require adopting a new programming language. Instead, we favor extensible type systems: new static type systems like this should be distributed as libraries atop a mechanism that guarantees that they can be safely composed.  We support this by 1) specifying a  translation from $\lambda_{RS}$ to a language containing only strings and regular expressions, then, taking Python as such a language, 2) implement the type system together with the translation as a library using \texttt{atlang}, an extensible static type system for Python (being developed by the authors).% represents the most sophisticated application of this library to date.
% Security-oriented programming languages do not enjoy wide adoption. Conversely, library and framework-based approaches to security are pervasive. Unfortunately, libraries and frameworks are only effective solutions if they are implemented and used properly. In this paper, we propose that extensible programming languages provide a promising mechanism for increasing the amount of trust that can be place in libraries and frameworks. To demonstrate this approach, we present a conservative extension to the simply-typed lambda calculus for checking the correctness of input sanitation algorithms. We also demonstrate how this language's security guarantees are preserved under translation into an underlying language containing a regular expression library. We believe this approach -- complementing existing techniques with light-weight, composable type-based analyses -- constitutes a promising compromise between usability, potential for industry adoption, and theoretically grounded safety guarantees.
\end{abstract}

%\category{D.3.2}{Programming Languages}{Language Classifications}[Extensible Languages]
%\category{D.3.4}{Programming Languages}{Processors}[Compilers]
%\category{F.3.1}{Logics \& Meanings of Programs}{Specifying and Verifying and Reasoning about Programs}[Specification Techniques]
%\keywords
%type-level computation, typed compilation
\section{Introduction}\label{intro}
Command injection vulnerabilities are among the most common and severe in modern web applications \cite{OWASP}. They arise because web applications, at their boundaries, must control external systems that expose string-based command interfaces. For example, web browsers are controlled using HTML and Javascript sent from a server as a string, and database engines execute SQL queries also sent as strings. When these commands contain data derived from user input, care must be taken to ensure that the user cannot provide an input that will subvert the intended command. For example, a  SQL query constructed using string concatenation exposes a SQL injection vulnerability if \verb|name| is controlled by a user: 
\begin{lstlisting}[numbers=none]
'SELECT * FROM users WHERE name="' + name + '"'
\end{lstlisting}
If a malicious user enters the name \lstinline{'"; DROP TABLE users --'}, the entire database could be erased. 

To avoid this problem, the program must \emph{sanitize} user input. 
For example, in this case, the developer (or, more often, a framework) might define a function \verb|sanitize| that escapes any double quotes, which are necessary in order to force uesr input to be interpreted as anything other than a string literal.
%prepends double quotes and existing backslashes  with a backslash, which SQL treats safely. Note that this function is not idempotent, so it should only be called once. Guaranteeing that user input has already been sanitized before it is used to construct a command is challenging. 

We observe that most such sanitization techniques can be understood in terms of \emph{regular languages}. For example, \verb|name| should be a string in the language described by the regular expression \verb!([^"\]|(\")|(\\))*! -- a sequence consisting of characters other than quotation marks or backslashes, or escaped quotation marks or escaped backslashes. Concrete syntax like this can be understood to desugar, in a standard way, to the abstract syntax for regular expressions shown in Figure \ref{fig:regex}. We will work with this ``core'' for simplicity, and assume basic familiarity with regular expressions \cite{cinderella}.

In this paper, we present a static type system that tracks the regular language a string belongs to. We take advantage of closure and decidability properties of regular languages to support a number of useful operations on values of such \emph{regular string types}. These make it possible to implement sanitation protocols like the one just described in an essentially conventional manner. The result is a system where the fact that a string has been \emph{correctly} sanitized becomes manifest in its type. Missing calls to sanitization functions are detected statically, and, importantly, so are \emph{incorrectly implemented sanitization functions} (i.e. these functions need not be trusted). Run-time checks are only used when going from less precise to more precise types (e.g. at the edges of the system, where user input has not yet been validated) and no additional space overhead is required. %implementing and statically checking input sanitation techniques. Our solution suggests a more general approach to the integration of security concerns into programming language design. This approach is characterized by \emph{composable} type system extensions which \emph{complement} existing and well-understood solutions with compile-time checks.

TODO: need to update remainder of intro ... To demonstrate this approach, we present a simply typed lambda calculus with \emph{constrained strings}; that is, a set of string types parameterized by regular expressions. If $s : \stringin{r}$, then $s$ is a string matching the language $r$. Additionally, we include an operation $\rreplace{r}{s_1}{s_2}$ which corresponds to the replace mechanism available in most regular expression libraries; that is, any substring of $s_1$ matching $r$ is replaced with $s_2$. The type of this expression is the computed, and is likely ``smaller" or more constrained than the type of $s_1$. Libraries, frameworks or functions which construct and execute commands containing input can specify a safe subset $\stringin{r_{\sf spec}}$ of strings, and input sanitation algorithms can construct such a string using ${\sf rreplace}$ or, optionally, by coercion (in which case a runtime check is inserted). We also show how this system is translated into a host language containing a regular expression library such that the safety guarantee of the extended language is preserved.

Summarily, we present a simple type system extension which ensures the absence of input sanitation vulnerabilities by statically checking input sanitation algorithms which use an underlying regular expression library. This approach is \emph{composable} in the sense that it is a conservative extension. This approach is also \emph{complementary} to existing input sanitation techniques which use string replacement for input sanitation.

%%
% This is the paragraph which ties the paper back to the CFP.
%
% For refernce, here's a copy of the cfp:
%The importance of security and privacy in software engineering is now a pressing concern. 
%Over the last decade, many programmers have recognized the importance of including 
%security and privacy requirements at project start. This has led to efforts 
%in secure/security engineering and privacy engineering, which focus on guidelines and 
%best practices that can be used at the design stage to create safer code. 
%Unfortunately, these disciplines are not pervasive and still in their infancy.
%The goal of this workshop is to make security and privacy first class citizens in programming and programming languages. 

%This forum aims to gather research and industry professionals to further the discussion on how to:
%   codify the principles from secure and privacy engineering into programming language constructs and or tools, 
%   create programming languages that have security and privacy as foundational tenets, and 
%   create/codify constructs or tools that enables secure and privacy-preserving (business) operations.
%   All submissions connected to the goals above, and their associated topics, are encouraged.
%%

\subsection{Related Work and Alternative Approaches}

The input sanitation problem is well-understood. There exist a large number of techniques and technologies, proposed by both practitioners and researchers, for preventing injection-style attacks. In this section, we explain how our approach to the input sanitation problem differs from each of these approaches. More important than these differences, however, is our more general assertion that language extensibility is a promising approach toward consideration of security goals in programming lanugage design.

Unlike \emph{frameworks and libraries} provided by languages such as Haskell and Ruby, our type system provides a \emph{static} guarantee that input is always properly sanitized before use. Doing so requires reasoning about the operations on regular languages corresponding to standard operations on strings; we are unaware of any production system which contains this form of reasoning. Therefore, even where frameworks and libraries provide a viable interface or wrapper around input sanitation, our approach is complementary because it ensures the correctness of the framework or library itself. Furthermore, our approach is more general than database abstraction layers because our mechanism is applicable to all forms of command injection (e.g. shell injection or remote file inclusion).

A number of research languages provide static guarantees that a program is free of input sanitation vulnerabilities \cite{UrFlowOSDI10}. 
Unlike this work, our solution to the input sanitation problem has a very low barrier to adoption; for instance, our implementation conservatively extends Python -- a popular language among web developers.
We also believe our general approach is better-positioned for security, where continuously evolving threats might require frequent addition of new analyses; in these cases, the composability and generality of our approach is a substantial advantage.

%\begin{itemize}
%  \item Our system is a light-weight solution to a single class of sanitation vulnerabilities (e.g. we do not address Cross-Site Scripting).
%  \item Our system is defined as a library in terms of an extensible type system, as opposed to a stand-alone language. Instead of introducing new technologies and methodologies for addressing security problems, we provide a light-weight static analysis which complements approaches developers already understand well.
%  \item Our implementation of the translation is implemented in Python and shares its grammar. Since Python is a popular programming language among web developers, the barrier between our research and adopted technologies is lower than for greenfield security-oriented languages.
%\end{itemize}

We are also unaware of any extensible programming languages which emphasize applications to security concerns.

Incorporating regular expressions into the type system is not novel. The XDuce system \cite{HosoyaVouillonPierce2000ICFP,HosoyaPierce2002} checks XML documents against schemas using regular expressions. 
Similarly, XHaskell \cite{xhaskell} focuses on XML documents.
We differ from this and related work in at least three ways:
\begin{itemize}
  \item Our system is defined within an extensible type system.
  \item We demonstrate that regular expression types are applicable to the web security domain, whereas previous work on regular expression types focused on XML schemas.
  \item Although our static replacement operation is definable in some languages with regular expression types, we are the first to expose this operation and connect the semantics of regular language replacement with the semantics of string substitution via a type safety and compilation correctness argument.
\end{itemize}

In conclusion, our contribution is a type system, implemented within an extensible type system, for checking the correctness of input sanitation algorithms.

%\subsection{Outline}
%
%An outline of this paper follows:
%
%\begin{itemize}
%  \item In \S 2, we define the type system which is embedded in Ace. We include a type safety proof for the string
%    segment of this language and prove the correctness of a translation to an underlying langguage $P$. In our theory,
%    $P$ is a simply typed lambda calculus equipped with a minimal regular expression library; in an implementation, $P$
%    stands in for Python or another underlying general-purpose programming language.
%  \item In \S 3, we discuss our implemention of this translation as a type system extension  within the Ace programming language.
%\end{itemize}

\section{A Type System for String Sanitation}

In this section we define a language for statically checked string sanitation ($\lambdas$).
The system has regular expression types $\stringin{r}$ whre $r$ is a regular expression. 
Expressions of this type evaluate to string literals in the language described by $r$.
Operations on expressions of type $\stringin{r}$ preserve this property. 

The premier operation for manipulating strings in $\lambdas$ is string substitution, 
which is a familiar operation to any programmer who has used regular expressions.
The replacement operation replaces all instances of a pattern in one string with
another string; for instance, $\lsubst{a|b}{a}{c} = c$.
In order to computer the type resulting from aubstitution, we also need to compute
the result of replacing on language with another inside a given language.
Finally, just for convienance, we provide a coerce operation. The introduction of
coercion requires handling of runtime errors.

The underlying language $\lambdap$ has only one type for strings. We prove that whenever
a term is translated from $\lambdas$ to $\lambdap$, correctness is preserved.
The only exception is in the case of unsafe casts in $\lambdas$, which are unnecessary but
are included to demonstrate that the regex library of $\lambdap$ may be used to insert
dynamic checks whenever even when developers are not careful about using statically checked
operations.

A brief outline of this section follows:
\begin{itemize}
  \item Page 3 contains a definition of $\lambdas, \lambdap$ and the translation from $\lambdas$ to $\lambdap$.
  \item In \S 2.1 we state some properties about regular expressions which are needed in our correctness proofs.
   \item In \S 2.2 we prove type safety for $\lambdap$ as well as both type safety and correctness for $\lambdas$.
  \item In \S 2.3 we prove that translation preserves the correctness reesult about $\lambdas$.
\end{itemize}


%The $\lambdas$ language is characterized by a type of strings indexed by regular
%expressions, together with operations on such strings which correspond to common
%input sanitation patterns.
%This section presents the grammar, typing rules and operational semantics for
%$\lambdas$ as well as an underlying language $\lambdap$.
%
%The system $\lambdas$ is the simply typed lambda calculus extended with \emph{regular expression types}, which are string
%types ensuring a string belongs to a specified language. For instance, 
%$S : \stringin{r}$ reads ``$s$ is a string matching $r$".
%the system includes an operation for replacing all instances of a pattern $r$ in a string $s_1$ with another string $s_2$. 
%Input sanitation algorithms -- as implemented by developers or within popular libraries and frameworks -- are often implemented in terms of this replace operation.
%
%The language $\lambdap$ is a simple functional language extended with a minimal regular expression library.
%Any general purpose programming language could stand in for $\lambdap$; for instance, SML or Python.
%In an implementation, our correctness results are modulo the underlying language's correct implementation of regular expression matching (see P-E-Replace).
%
%Finally, we define a translation from our type system $\lambdas$ into $\lambdap$ which preserves the safety guarnatee codified in the string types of $\lambdas$. Because our extension is conservative and its guarnatees are preserved under translation to an underlying language, it is highly composable with other analyses.
%
%Unfortunately, we are unable to present full proofs in this paper due to space constraints; however, proofs are given in full in the accompanying technical report?.
%%Note that we never insert an internal check where the type of the string implies
%%that a check must succeed. Furthermore, expensive calculations (such as language
%%inclusion or ${\sf rreplace}$) all occur at compile time.
%%Since sanitation problems are generally expressible with smalle, simple expressions,
%%we believe that the compile-time overhead is not significant enough to prohibiour target usecase. Informal experimentation with our implementation seems to
%%support this assertion.

% Begin Grammar 
% Removes the < > from grammar productions.
\renewcommand{\grammarlabel}[2]{#1\hfill#2}

\begin{figure}[t]
\begin{grammar}
<r> ::= $\epsilon$ | $.$ | $a$ | $r \cdot r$ | $r + r$ | $r*$ \hfill $a \in \Sigma$

\caption{Regular expressions over the alphabet $\Sigma$.}
\label{fig:regex}
\end{grammar}
\end{figure}

\begin{figure}[h]
\begin{grammar}

<$\psi$> ::=	$\psi \rightarrow \psi$			\hfill	source types					\alt
$\stringin{r}$				 

<S> ::= 
      $\lambda x . e$ \hfill source terms \alt
      $e e$ \alt
      $\strin{s}$ \hfill $s \in \Sigma^{*}$ \alt
      $\rsconcat{S}{S}$ \alt
      $\sisubst{r}{S}{S}$ \alt
      $\coerce{r}{S}$
\caption{Syntax for the string sanitation fragment of our source language, $\lambdas$.}
\end{grammar}
\end{figure}

\begin{figure}[h]
\begin{grammar}

<$\theta$> ::= $\theta \rightarrow \theta$ \hfill target types \alt
$\str$ \alt $\regex$


<P> ::= $\lambda x . e$ \hfill target terms \alt
  $e e$ \alt
  $\tstr{s}$ \alt
  $\rx{r}$ \alt
  $\tconcat{P}{P}$ \alt
  $\preplace{P}{P}{P}$ \alt
  $\tcheck{P}{P}$ 
  \end{grammar}
\caption{Syntax for the fragment of our target language, $\lambdap$, containing strings and statically constructed regular expressions.}
\label{fig:lcsSyntax}
\end{figure}



%The $\lcs$ language gives static semantics for common regular expression library
%functions. In this treatment, we include concatenation and filtering.
%The ${\tt filter}$ function removes all instances of a regular expression in a string,
%while concatenation ($+$) concatenates two strings.
%
%\subsection{Typing}
%
%The $\strin[r]$ type is parameterized by regular expressions; if $e:\strin[r]$,
%then $e \in r$. Mapping from an arbitrary $\str$ to a $\strin[r]$ requires
%defining an algorithm -- in terms of filter -- for converting a $\strin[.*]$
%into a $\strin[r]$. The static semantics of the language defines the types of
%operations on regular expressions in terms of well-understood properties about
%regular lanugages; we recall these properties in section 3.
%
%\subsection{Dynamics}
%
%There are two evaluation judgements: $e:T \reduces e'$ and $e:T \treduces i$.
%The $\reduces$ relation is between $\lcs$ expressions, while the $\treduces$
%relation is a mapping from $\lcs$ expressions into internal language expressions
%$i$ such that $i \ival$.
%
%Safety of the evaluation relation depends upon an injective mapping from $\lcs$ types info
%internal language types. This relation, $h$, is defined below.
%
%\subsection{Type Safety}
%
%The type safety proof relies upon some assumptions about the type system and
%dynamics of the internal language, as well as some properties of regular
%languages.
%
%There must exist a translation from $\lcs$ types to the types of the internal
%language. For the remainder of this paper, we call the type translation function
%$h$.
%
%\begin{defn}[Type Translation Function $h$]
%  The type translation function $h : Type \rightarrow IType$ is defined as follows:
%  \begin{itemize}
%    \item $\forall r. h(\strin[r]) = istr$
%    \item $h(\str) = istr$
%  \end{itemize}
%\end{defn}
%
%Additionally, we assume that the internal language contains an implementation of strings,
%together with operations for concatenation and filtering by regular expression.
%
%\begin{defn}[Types of internal values]
%  Let $\tstrf{s}$ range over string literals and $r$ over regular expressions.
%  Internal values are typed as follows:
%\begin{itemize}
%  \item If $e=\tstrf{s}$ then $e:istr$.
%  \item If $e=\ifilter{r}{\tstrf{s}}$ then $e:istr$.
%  \item If $e=\tstrf{s_1}+\tstrf{s_2}$ then $e:istr$.
%\end{itemize}
%\end{defn}
%
%For simplicity, we assume a fixed translation from
%$\lcs$ regular expressions to regular expressions recognizable by the internal
%language's regex library (in practice, a fixed translation is acceptable.)
%To summarize, we assume an internal language containing 
%a string type together with operations for string concatentation and filtering. We
%expect closure over strings for both operations.
%Finally, recall that ${\tt ifilter}$ is only needed for dynamic casts, which may be removed without
%descreasing the expressivity or even usability of the language.
%Finally, the semantics of the filter function are defined in terms of ${\tt rl\_filter}$,
%which is a static version of ${\tt ifilter}$.
%


% I can't achieve the correct latout here. We should have something like:
%       Lam_S Synax         Lam_P Syntax
%       Lam_S Sematics      LAm_P Semantics
%                Translation rules
% Or, alternatively, we can flip reflect things so that the entire page
% reads top-down (Lam_S syntax Lam_S smantics horizontally aligned w/ one
% another).

% Unfortunately, I can't get that to work. So, we're settling for something
% slightly ugly, where the fitures appear in the incorrect order and the 
% translation rules are on top.

% The translations rules *just won't* go to the bottom of the page, so 
% instead I am placing them at the top. Since the figures are out of order,
% it's even more important that we get the number gith. therefore, the counter
% is modified before and after this figure.


\addtocounter{figure}{4}
\begin{figure*}\label{fig:trans}

$\fbox{\inferrule{}{\trden{S} = P}}$
\begin{mathpar}

\inferrule[Tr-string]
{ \ }
{\trden{\strin{s}} = \tstr{s}}

\inferrule[Tr-Concat]
{ \trden{S_1} = P_1 \\ \trden{S_2} = P_2}
{\trden{\rsconcat{S_1}{S_2}} = \tconcat{P_1}{P_2}}

\inferrule[Tr-Subst]
{ \trden{S_1} = P_1 \\ \trden{S_2} = P_2 }
{\trden{ \sisubst{r}{S_1}{S_2} } = \tsubst{\rx{r}}{P_1}{P_2} }

\inferrule[Tr-Coerce-Ok]
{ S : \strin{r} \\ \lang{r'} \subseteq \lang{r}}
{\trden{ \coerce{r'}{S} } = \tstr{s}}

\inferrule[Tr-Coerce-NotOk]
{\trden{S} = P \\ S : \strin{r} \\ \lang{r'} \not \subseteq \lang{r}}
{\trden{\coerce{r'}{S}} = \tcheck{\rx{r'}}{P}}

\end{mathpar}
\caption{Translation from source terms (S) to target terms (P).
The translation is type-directed in the Tr-Coerce cases.}
\end{figure*}
\addtocounter{figure}{-5}




%
% Begin typing/translation relation
%


\newcommand{\sctx}{\Psi} % Context for external typing
\newcommand{\tctx}{\Theta} % Context for internal typing

\newcommand{\ereduces}{\Downarrow}

\begin{figure}[t]\label{fig:lambdas}
\small
$\fbox{\inferrule{}{\sctx \vdash S : \psi}}$
~~~~$\sctx ::= \emptyset \pipe \sctx, x : \psi$
\begin{mathpar}
%\inferrule[S-T-Abs]
%{\sctx, x : T_1 \vdash e : T_2}
%{\sctx \vdash \lambda x.e : T_1 \rightarrow T_2}
%
%\inferrule[S-T-App]
%{\sctx \vdash e_1 : T' \\ \sctx \vdash e_2 : T' \rightarrow T}
%{\sctx \vdash e_1 e_2 : T}
%  
\inferrule[S-T-Stringin-I]
{s \in \lang{r}}
{\sctx \vdash \strin{s} : \stringin{r}}

\inferrule[S-T-Concat]
{\sctx \vdash S_1 : \stringin{r_1} \\ \sctx \vdash S_2 : \stringin{r_2}}
{\sctx \vdash \rsconcat{S_1}{S_2} : \stringin{r_1 \cdot r_2}}

\inferrule[S-T-Replace]
{\sctx \vdash S_1 : \stringin{r_1} \\ \sctx \vdash S_2 : \stringin{r_2} \\\\ \lreplace{r}{r_1}{r_2} = r'}
{\sctx \vdash \sisubst{r}{S_1}{S_2} : \stringin{r'}}

\inferrule[S-T-coerce]
{\sctx \vdash S : \stringin{r'}}
{\sctx \vdash \coerce{r}{S} : \stringin{r}}

\end{mathpar}

\caption{Typing rules for our fragment of $\lambdas$. 
The typing context $\sctx$ is standard.}
\label{fig:etyping}
\end{figure}



\begin{figure}[t]
\small
$\fbox{\inferrule{}{S \sreduces S}}$
$\fbox{\inferrule{}{S \err}}$
\begin{mathpar}
%
%\inferrule[S-E-Abs]                                                             
%{ \ }                                                                           
%{\lambda x.e \sreduces \lambda x.e}                                             
%
%\inferrule[S-E-App]
%{ e_1 \sreduces e_1' \\ e_2 \sreduces e_2' }
%{ e_1 e_2 \sreduces e_1' e_2'}
%
\inferrule[S-E-RStr]
{ \ }
{\strin{s} \sreduces \strin{s}}

\inferrule[S-E-Concat]
{S_1 \sreduces \strin{s_1} \\ S_2 \sreduces \strin{s_2}} 
{\rsconcat{S_1}{S_2} \sreduces \strin{s_1 s_2}} % ???

\inferrule[S-E-Replace]
{S_1 \sreduces \strin{s_1} \\ S_2 \sreduces \strin{s_2} \\ \lsubst{r}{s_1}{s_2} = s} 
{\sisubst{r}{S_1}{S_2} \sreduces \sistr{s}}

\inferrule[S-E-Coerce-OK]
{S \sreduces \strin{s} \\ s \in \lang{r}}
{\coerce{r}{S} \sreduces \strin{s}}

\inferrule[S-E-Coerce-Err]
{S \sreduces \strin{s} \\ s \not \in \lang{r}}
{\coerce{r}{S} \err}

\end{mathpar}
\caption{Big step semantics for our fragment of $\lambdas$.
Error propagation rules are omitted.}
\label{fig:eeval}
\end{figure}

\newpage



\begin{figure}[t]\label{fig:lambdap}
\small
$\fbox{\inferrule{}{\tctx \vdash P : \theta}}$
~~~~$\tctx ::= \emptyset \pipe \tctx, x : \theta$

\begin{mathpar}
%\inferrule[P-T-Abs]
%{\tctx, x : T_1 \vdash e : T_2}
%{\tctx \vdash \lambda x.e : T_1 \rightarrow T_2}
%
%\inferrule[P-T-App]
%{\tctx \vdash e_1 : T \\ \tctx \vdash e_2 : T' \rightarrow T}
%{\tctx \vdash e_1 e_2 : T}
%
\inferrule[P-T-String]
{ \ }
{\tctx \vdash \tstr{s} : \str}

\inferrule[P-T-Regex]
{ \ }
{\tctx \vdash \rx{r} : \regex}

\inferrule[P-T-Concat]
{\tctx \vdash P_1 : \str \\ \tctx \vdash P_2 : \str}
{\tctx \vdash \tconcat{P_1}{P_2} : \str}

\inferrule[P-T-Replace]
{\tctx \vdash P_1 : \regex \\ \tctx \vdash P_2 : \str \\ \tctx \vdash P_3 : \str }
{\tctx \vdash \preplace{P_1}{P_2}{P_3} : \str}

\inferrule[P-T-Check]
{\tctx \vdash P_1 : \regex \\ \tctx \vdash P_2 : \str \\ }
{\tctx \vdash \tcheck{P_1}{P_2} : \str}
\end{mathpar}
\caption{Typing rules for our fragment of $\lambdap$.
The typing context $\tctx$ is standard.}
\label{fig:etyping}
\end{figure}

\begin{figure}[t]
\small
$\fbox{\inferrule{}{P \treduces P}}$
$\fbox{\inferrule{}{P \err}}$

\begin{mathpar}

%\inferrule[P-E-Abs]
%{ \ }
%{\lambda x.e \sreduces \lambda x.e}
%
%\inferrule[P-E-App]
%{ e_1 \sreduces e_1' \\  e_2 \sreduces e_2' }
%{ e_1 e_2 \sreduces e_1' e_2'}
%
  \inferrule[P-E-Str]
{ \ }
{\tstr{s} \treduces \tstr{s}}

\inferrule[P-E-Rx]
{ \ }
{\rx{r} \treduces \rx{r}}

\inferrule[P-E-Concat]
{P_1 \treduces \tstr{s_1} \\ P_2 \treduces \tstr{s_2}} 
{\tconcat{P_1}{P_2} \treduces \tstr{s_1 s_2}} % ???

\inferrule[P-E-Replace]
{P_1 \treduces \rx{r} \\ P_2 \treduces \tstr{s_2} \\ P_3 \treduces \tstr{s_3} \\ \lsubst{r}{s_2}{s_3} = s} 
{\preplace{P_1}{P_2}{P_3} \treduces \tstr{s}}

\inferrule[P-E-Check-OK]
{P_1 \treduces \rx{r} \\ P_2 \treduces \strin{s} \\ s \in \lang{r}}
{\tcheck{P_1}{P_2} \treduces \tstr{s}}

\inferrule[P-E-Check-Err]
{P_1 \treduces \rx{r} \\ P_2 \treduces \tstr{s} \\ s \not \in \lang{r}}
{\tcheck{P_1}{P_2} \err}
\end{mathpar}
\caption{Big step semantics for our fragment of $\lambdap$.
Error propagation rules are omitted.}
\label{fig:ieval}
\end{figure}




\newpage
\ 
\newpage
\ 
\newpage




\subsection{Properties of Regular Languages}

Our type safety proof for language S replies on a relationship between
string substitution and language substitution given in lemma \ref{thm:substcorrespondence}.
We also rely upon several other properties of regular languages.
Throughout this section, we fix an alphabet $\Sigma$ over which strings $s$ and
regular expressions $r$ are defined. throughout the paper, $\lang{r}$ refers to the
language recognized by the regular expression $r$. This distinction between the regular expression
and its language -- typically elided in the literature -- makes our definition and
proofs about systems S and P more readable.

\begin{lem}{Properties of Regular Languages and Expressions.} \label{thm:regexprops}
The following are properties of regular expressions which are necessary for our proofs:
If $s_1 \in \lang{r_1}$ and $s_2 \in \lang{r_2}$ then $s_1s_2 \in \lang{r_1r_2}$.
For all strings $s$ and regular expressions $r$, either $s \in \lang{r}$ or $s \not \in \lang{r}$.
Regular languages are closed under difference, right quotient, reversal, and string homomorphism.
\end{lem}

If any of these properties are unfamiliar, the reader may refer to a standard text on the subject \cite{cinderella}.

\begin{defn}[$\tt{lsubst}$]
The replation $\lsubst{r}{s_1}{s_2} = s$ produces a string $s$ in which all substrings of $s_1$ matching $r$ are replaced with $s_2$.
\end{defn}

\begin{defn}[$\tt{lreplace}$]
  The relation $\lreplace{r}{r_1}{r_2} = r'$ relates $r, r_1,$ and $r_2$ to
  a language $r'$ containing all strings of $r_1$ except that any substring $s_{pre} s s_{post} \in \lang{r_1}$ where $s \in \lang{r}$
  is replaced by the set of strings $s_{pre} s_2 s_{post}$ for all $s_2 \in \lang{r_2}$ (the prefix and postfix positions may be empty).
\end{defn}

\begin{lem}{Closure.} \label{thm:total}
  If $\lang{r}, \lang{r_1}$ and $\lang{r_2}$ are regular expressions, then $\lang{\lreplace{r}{r_1}{r_2}}$ is also a regular language.
\end{lem}
\begin{proof}
The theorem follows from closure under difference, right quotient, reversal and string homomorphism.
\end{proof}

\begin{lem}{Substitution Correspondence.} \label{thm:substcorrespondence}
  If $s_1 \in \lang{r_1}$ and $s_2 \in \lang{r_2}$ then $\lsubst{r}{s_1}{s_2} \in \lang{\lreplace{r}{s_1}{s_2}}$.
\end{lem}
\begin{proof}
The theorem follows from the definitions of lsubst and lreplace; note that language substitutions over-approximate string substititons.
\end{proof}


%\begin{description}
%\item[case $r=\alpha$.]
%If $s_1 = \alpha$ then $\alpha \in \lang{r_1}$ by assumption.
%Therefore, $\lsubst{r}{s_1}{s_2} = \lsubst{\alpha}{\alpha}{s_2} = s_2$ and
%$\lreplace{r}{r_1}{r_2} = \lreplace{\alpha}{r_1}{r_2}$. 
%Since $s_1 = \alpha$ and $\alpha \in \lang{r_1}$, $r_1 \iso \alpha | r_1'$ for some $r_1'$.
%Therefore, $\lreplace{\alpha}{r_1}{r_2} \iso \lreplace{\alpha}{\alpha|r_1'}{r_2}$ by Lemma X(1).
%Finally, $s_2 \in \lang{r_2}$ which implies $s_1 \in \lang{r_2|r'}$.
%If $s_1 \not = \alpha$ the $\lsubst{r}{s_1}{s_2} = s_1$ and $\lreplace{\alpha}{r_1}{r_2} = r_1$.
%
%\item[case $r = a|b$].
%Note that $\subst{a|b}{s_1}{s_2} = \lsubst{a}{\lsubst{b}{s_1}{s_2}}{s_2}$
%and $\lsubst{b}{s_1}{s_2} \in \lreplace{b}{r_1}{r_2}$ by induction.
%Therefore, $\lsubst{a|b}{s_1}{s_2} \in \lreplace{a}{\lreplace{b}{r_1}{r_2}}{r_2}$ by induction and the definition of lreplace.
%Finally, applying definitions once more, $\lsubst{a|b}{s_1}{s_2} \in \lreplace{a|b}{r_1}{r_2}$.
%
%\item[case $r = ab$].
%By a similar argument to the disjunctive case.
%
%\item[case $r = a*$].
%By considering the once unwinding of $a*$, noting that $s_1$ and $s_2$ are finite.
%\end{description}


% NRF The coercion lemma is no longer necessary, because it is a property of
% "strip"-style sanitation rather than the more general case of replacement 
% treated in this paper. However, we should mention this difference between my
% undergraduate thesis and this paper in the related work section if we are
% going tin clude a discussio of unpublished or quasi-published (e.g. src)
% results.
%\begin{lem}{Coercion Lemma.} \label{thm:coercionalemma}
%Suppose that $R$ and $L$ are regular expressions, and that $s \in R$ is a finite string.  
%Let $s' = \coerce(R,L,s)$ with all maximal substrings recognized by $L$ replaced with $\epsilon$.  Then $s'$ is recognized by $(R \backslash L) + \emptyset$ and the construction of $R \backslash L$ is decidable.
%\end{lem}
%\begin{proof}
%Let $F,G$ be FAs corresponding to $R$ and $L$, and let $G'$ be $G$ with its final states inverted (so that $G'$ is the complement of $L$).  Define an FA $H$ as a DFA corresponding to the NFA found by combining $F$ and $G'$ such that $H$ accepts only if $R$ and $L'$ accept or if $s$ is empty (this construction may result in an exponential blowup in state size.)  Clearly, $H$ corresponds to $R \backslash L + \emptyset$.  Thus, the construction of $R \backslash L + \emptyset$ is decidable.
%
%If $R \subset L$, $s' = \emptyset$.  If $L \subset R$, either $s' = \emptyset$, or $s' \in R$ and $s' \not \in L$. If $R$ and $L$ are not subsets of one another, then it may be the case that $L$ recognizes part of $R$.  Consider $L$ as the union of two languages, one which is a subset of $R$ and one which is disjoint.  The subset language is considered above and the disjoint language is inconsequential.
%\end{proof}

% Why is this necessary?
%\begin{lem}
%  For all $r$, if $s_1 \in r_1$ and $s_2 \in r_2$ then $\subst{r}{s_1}{s_2} \subseteq \lsubst{r}{r_1}{r_2}$.
%\end{lem}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN PROOFS ABOUT S AND P
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Safety of the Source and Target Languages}

\begin{lem}
  If $\sctx \vdash S : \stringin{r}$ then $r$ is a well-formed regular expression.
\end{lem}
\begin{proof}
  The only non-trivial case is S-T-Replace, which follows from lemma \ref{thm:total}. 
\end{proof}
\begin{lem}
If $\tctx \vdash P : \regex$ then $P \treduces \rx{r}$ such that $r$ is a well-formed regular expression. 
\end{lem}

We now prove safety for the string fragment of the source and target languages.

\begin{thm}{Safety and Sanitation Correctness for the String Fragment of P.} \label{thm:scorrect}
  Let $S$ be a term in the source language. If $\sctx \vdash S : \stringin{r}$ 
  then $S \sreduces \rstr{s}$ and $\sctx \vdash \rstr{s} : \stringin{r}$; or else $S \err$.
\end{thm}
\begin{proof}
By induction on the typing relation, where (a) case holds by lemma \ref{thm:regexprops} in the S-T-Concat case and lemma \ref{thm:substcorrespondence} in the S-T-Replace case..
The (b) cases hold by unstated, but standard, error propagation rules.
\end{proof}

In addition to safety, we proof a correctness result for $\lambdas$ which ensures that well-typed terms of regular string type are in the language associated with their type.

\begin{thm}{Correctness of Input Sanitation for $\lambdas$.}\label{thm:scorrect}
  If  $\sctx \vdash S : \stringin{r}$ and $S \sreduces \rstr{s}$ then $s \in \lang{r}$.
\end{thm}
\begin{proof}
  Follows directly from type safety, canonical forms for $\lambdas$.
\end{proof}

%\begin{thm}{Correctness of Input Sanitation (CIS) for $\lambdas$.}\label{thm:scorrect}
%  If $\sctx \vdash S : \stringin{r}$ then either (a) $S \sreduces \rstr{s}$ for $s \in \lang{r}$
%  or (b) $S \err$.
%\end{thm}

\begin{thm} 
  Let $P$ be a term in the target language. If $\tctx \vdash P : \theta$ 
  then $P \sreduces P'$ and $\tctx \vdash P' : \theta$, or else $P \err$.
\end{thm}

\subsection{Translation Correctness}

\begin{thm}{Translation Correctness.} \label{thm:tcorrect}
If $\sctx \vdash S : \stringin{r}$ then there exists a $P$ such that $\trden{S} = P$ and either: 
(a) $P \treduces \tstr{s}$ and $S \sreduces \strin{s}$, or
(b) $P \err$ and $S \err$.
\end{thm}

\begin{proof}
The proof proceeds by induction on the typing relation for $S$ and an appropriate
choice of $P$; in each case, the choice is obvious. The subcases (a) proceed
by inversion and appeals to our type safety theorems as well as the induction hypothesis. The subcases (b) proceed
by the standard error propagation rules omitted for space.
Throughout the proof, properties from the closure lemma for regular languages
are necessary.
\end{proof}

Finally, our main theorem establishes that input sanitation correctness of $\lambdas$ is preserved under the translation into $\lambdap$.

\begin{thm}{Correctness of Input Sanitation for Translated Terms.}
  If $\trden{S} = P$ and $\sctx \vdash S : \stringin{r}$ then either $P \err$ or $P \sreduces \tstr{s}$
  for $s \in \lang{r}$.
\end{thm}
\begin{proof}
  By theorem \ref{thm:tcorrect}, $P \sreduces \tstr{s}$ implies that $S \sreduces \strin{s}$.
  By theorem \ref{thm:scorrect}, this together with the assumption that $S$ is well-typed implies that $s \in \lang{r}$.
\end{proof}
% PROOF OF TRANSLATION CORRECTNESS.
% This proof is slightly out of say. It's SUFFICIENT, but is actually more
% than sufficient because we prove \ref{scorrect} along with translation
% correctness....
%\begin{description}
%\item[S-T-String-I:] 
%Let $S = \rstr{s}$ and suppose $\sctx \vdash \rstr{s} : \stringin{r}$.
%Choose $T = \str{s}$ and note that $\trden{S} = P$ by Tr-String.
%By P-E-String, $P \treduces \str{s}$ and by S-E-String $S \treduces \rstr{s}$.
%Finally, by inversion of S-T-Stringin-I, $s \in \lang{r}$.
%
%\item[S-T-Concat:]
%Let $S = \rconcat{S_1}{S_2}$ and suppose $\sctx \vdash S : \stringin{r_1 r_2}$.
%By inversion, $\sctx \vdash S_1 : \stringin{r_1}$.
%It follows by induction that there exists a $P_1$ such that $\trden{S_1} = P_1$.
%By a similar argument for $S_2$ and $r_2$, there exists a $P_2$ such that $\trden{S_2} = P_2$.
%Choose $P = \concat{P_1}{P_2}$.
%
%We first prove property (a).
%Note that $S_1$ and $P_1$ do not result in errors and that $S_1$ is well typed.
%Therefore, $S_1 \sreduces \rstr{s_1}$ and $P_1 \treduces \str{s_1}$ for some $s_1 \in \lang{r_1}$ by theorems 8 and 9 respectively. % TODO-nrf make sure this numbering is correct
%Similarly, $S_2 \sreduces \rstr{s_2}$ and $P_2 \treduces \str{s_2}$ for some $s_2 \in \lang{r_2}$.
%Therefore, $S \sreduces \rstr{s_1 s_2}$ by S-E-Concat and $\concat{P_1}{P_2} \treduces \str{s_1 s_2}$ by P-E-Concat.
%Finally, $s_1s_2 \in \lang{r_1}{r_2}$ by \ref{thm:regexprops}.
%
%Consider property (b).
%If $S_1 \err$ then $P_1 \err$ by induction, and it follows that $S \err$ and $P \err$ by respective error propagation rules.
%Similarly, if $S_2 \err$ then $P_2 \err$ and it follow that $S \err$ and $P \err$ by induction and propagation.
%
%\item[S-T-Replace:]
%Let $S = \rreplace{r}{S_1}{S_2}$ and suppose $\sctx \vdash S : \stringin{r'}$ for some $s$.
%By inversion of S-T-Replace, , $\sctx S_1 : \stringin{r_1}$ and $\sctx : \stringin{r_2}$ 
%such that $\lsubst{r}{r_1}{r_2} = r'$.
%By induction, there exists some $P_1, P_2$ such that $\trden{S_1} = P_1$, $\trden{S_2} = P_2$
%and either (a) or (b) holds.
%
%If (a) holds then $S_1 \sreduces \rstr{s_1}$ and $P_1 \treduces \str{s_1}$ for some $s_1 \in \lang{r_1}$,
%and similarly for $S_2, P_2$ and some $s_2 \in \lang{r_2}$.
%Therefore, by S-E-Replace, $S \sreduces \rstr{s}$ for some $s = \lreplace{r}{s_1}{s_2}$.
%Choose $P = \preplace{r}{s_1}{s_2}$.
%By a similar argument and P-E-Replace, $P \treduces \str{s}$ for some $s = \lreplace{r}{s_1}{s_2}$.
%What remains to be shown is $\lreplace{r}{s_1}{s_2} \in \lang{\lsubst{r}{r_1}{r_2}}$,
%which follows from Leamm D since $s_1 \in r_1$ and $s_2 \in r_2$.
%
%If (b) holds for $S_1$ and $P_1$, then $S \err$ and $P \err$ by propagation rules.
%Similarly, if (b) hols for $S_2$ and $P_2$ then $S \err$ and $P \err$ by propagation rules.
%
%\item[S-T-Coerce:]
%Let $S = \rcoerce{r}{S'}$ and suppose $\sctx \vdash \rcoerce{r}{S} : \stringin{r}$.
%By inverstion $\Psi \vdash S' : \stringin{r'}$ for an arbitrary $r'$.
%By induction there exists a $P'$ such that $\trden{S'} = P'$ and either (a) or (b)
%holds for $S'$ and $P'$.
%
%If (a) holds then $S' \sreduces \rstr{s'}$ and $P' \treduces \str{s'}$ for some $s' \in \lang{r'}$.
%Note that either $s' \in \lang{r}$ or $s' \not \in \lang{r}$ by property 2 of \ref{thm:regexprops}.
%Suppose $s' \in \lang{r}$. Then $\rcoerce{r}{S} \sreduces \rstr{S'}$ by S-E-Coerce.
%Choose $P = \check{\rx{r}}{P'}$ and note that $P \treduces \str{s'}$ by P-E-Coerce.
%Now suppose $s' \not \in \lang{r}$. Then $S \err$ and $P \err$ by P-E-Check-Err
%and S-E-Coerce-Err.
%
%Finally, if (b) holds then $S \err$ and $P \err$ by propagation.
%
%\end{description}

% NRF commented out section 2 in order to determine the length of section 1.
% Replace the pattern ^% with an emptty string in the selection starting at
% the first empty line of section 2 and ending just before \end{document}. 

\section{Implementation in {Atlang}}
\begin{figure}
\begin{lstlisting}
#todo: why are these r's here?
#TODO-nrf this is maybe kind-of right bue I think there's a nicer way to do it.
@fn
def sanitize(s : string_in[r'.*']):
  return (s.replace(r'"', '&quot;') 
           .replace(r'<', '&lt;')
           .replace(r'>', '&gt;'))

@fn
def results_query(s : string_in[r'[^"]*']):
  return 'SELECT * FROM users WHERE name="' + s + '"'

@fn
def results_div(s : string_in[r'[^<>]*']):
  return '<div>Results for ' + s + '</div>'

def main(db):
  input = sanitize(user_input())
  results = db.execute(results_query(input))
  return results_div(input) + format(results)
\end{lstlisting}
\vspace{-10px}
\caption{Regular string types in atlang, a library that enables static type checking for Python. }
\end{figure}
\begin{figure}
\begin{lstlisting}
class string_in(atlang.Type):
  def __init__(self, rx):
    rx = rx_normalize(rx)
    atlang.Type.__init__(idx=rx)

  def ana_Str(self, ctx, node):
    if not in_lang(node.s, self.idx):
      raise atlang.TypeError("...", node)

  def trans_Str(self, ctx, node):
    return astx.copy(node)

  def syn_BinOp_Add(self, ctx, node):
    left_t = ctx.syn(node.left)
    right_t = ctx.syn(node.right)
    if isinstance(left_t, string_in):
      left_rx = left_t.idx
      if isinstance(right_t, string_in):
        right_rx = right_t.idx
        return string_in[lconcat(left_rx, right_rx)]
    raise atlang.TypeError("...", node)

  def trans_BinOp_Add(self, ctx, node):
    return astx.copy(node)

  def syn_Method_replace(self, ctx, node):
    [rx, exp] = node.args
    if not isinstance(rx, ast.Str):
      raise atlang.TypeError("...", node)
    rx = rx.s
    exp_t = ctx.syn(exp)
    if not isinstance(exp_t, string_in):
      raise atlang.TypeError("...", node)
    exp_rx = exp_t.idx
    return string_in[lreplace(self.idx, rx, exp_rx)]

  def trans_Method_replace(self, ctx, node):
    return astx.quote(
      """__import__(re); re.sub(%0, %1, %2)""",
      astx.Str(s=node.args[0]),
      astx.copy(node.func.value),
      astx.copy(node.args[1]))

  def syn_Method_check(self, ctx, node):
    [rx] = node.args
    if not isinstance(rx, ast.Str):
      raise atlang.TypeError("...", node)
    return string_in[rx.s]

  def trans_Method_check(self, ctx, node):
    return astx.quote(
      """__import__(string_in_helper);
      string_in_helper.coerce(%0, %1)""",
      astx.Str(s=other_t.idx),
      astx.copy(node))

  def check_Coerce(self, ctx, node, other_t):
    # coercions can only be defined between 
    # types with the same type constructor, 
    if rx_sublang(other_t.idx, self.idx):
      return other_t
    else: raise atlang.TypeError("...", node)
\end{lstlisting}
\vspace{-10px}
\caption{Implementation of the \texttt{string\_in} type constructor in atlang.}
\end{figure}

\begin{figure}
\begin{lstlisting}
output of successful compilation
\end{lstlisting}
\caption{Output of successful compilation.}
\end{figure}

\begin{figure}
\begin{lstlisting}
output of failed compilation
\end{lstlisting}
\caption{Output of failed compilation.}
\end{figure}
wwwww
Here, we use the argument annotation syntax introduced in Python 3 (a similar syntax is available for Python 2.6+, not shown).

\section{Conclusion}

An implementation of a similar system as a type system extension in the programming language Ace is discussed in \cite{fulton12} and \cite{fulton13}.
The implementation only supports a special case of replacement where unsafe substrings are simply stripped.
In practice, most libraries and frameworks escape command sequences instead of stripping characters; therefore, we plan to extend our implementation with
support for the replace operation as described in this paper..

\section{Conclusion}

Composable analyses which complement existing approaches constitute a promising approach toward the integration of security concerns into programming languages.
In this paper, we presented a system with both of these properties and defined a security-preserving transformation.
Unlike other approaches, our solution complements existing, familiar solutions while providing a strong guarantee that traditional library and framework-based approaches are implemented and utilized correctly.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END SECTION TWO -- THIS IS THE CONFLICT LINE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\newcommand{\F}[1]{\textsf{#1}~}
%\newcommand{\FF}[1]{\textsf{#1}}
%\newcommand{\Q}{\FF{Arg}}
%\newcommand{\xlA}[1]{\lfloor #1 \rfloor_{\lambda}}
%\newcommand{\xA}[1]{$\lfloor #1 \rfloor_{\text{Ace}}$}
%\newcommand{\rtotau}[1]{\lfloor #1 \rfloor}
%
%\newcommand{\tremp}{{\tt tremp}}
%\newcommand{\trdot}{{\tt trdot}}
%\newcommand{\trchar}[1]{{\tt trchar}[#1]}
%\newcommand{\trseq}[2]{{\tt trseq}(#1; #2)}
%\newcommand{\tror}[2]{{\tt tror}(#1; #2)}
%\newcommand{\tlstr}[1]{{\tt tstr}[#1]}
%\begin{table*}[t]
%\centering
%\begin{tabular}{ l l l }
%$r$ & $\xlA{r}$ & \xA{r}\\
%\hline
%$\epsilon$ & $\tremp$ & \verb|""|\\
%$.$ & $\trdot$ & \verb|"."|\\
%$a$ & $\trchar{a}$ & \verb|"|$a$\verb|"|\\
%$r_1 \cdot r_2$ & $\trseq{\xlA{r_1}}{\xlA{r_2}}$ & \xA{r_1}\verb| + |\xA{r_2}\\
%$r_1 + r_2$ & $\tror{\xlA{r_1}}{\xlA{r_2}}$ & \verb|"(" + |\xA{r_1}\verb! + "|" + !\xA{r_2}\verb| + ")"|\\
%\\
%$\psi$ & $\xlA{\psi}$ & \xA{\psi}\\
%\hline
%${\tt string\_in}[r]$ & $\fvar{stringin}[\xlA{r}]$ & \verb|string_in[|\xA{r}\verb|]|\\
%\\
%  $S$ & $\xlA{S}$ & \xA{S} \\
%  \hline
%  ${\tt str\_in}[s]$ & $\FF{intro}[\FF{str}[s]]()$ & \verb|"|$s$\verb|"|\\
%  ${\tt concat}(S_1; S_2)$  & $\xlA{S_1}\cdot\FF{elim}[\tvar{concat}](\xlA{S_2})$ & \xA{S_1}\verb| + |\xA{S_2} \\
%  ${\tt subst}[r](S_1; S_2)$  & $\xlA{S_1}\cdot\FF{elim}[\tvar{subst}~\xlA{r}](\xlA{S_2})$ & \xA{S_1}\verb|.subst(|\xA{r}\verb|, |\xA{S_2}\verb|)|\\
%  ${\tt coerce}[r](S)$  & $\xlA{S}\cdot\FF{elim}[\tvar{coerce}~\xlA{r}]()$ & \xA{S}\verb|.coerce(|\xA{r}\verb|)|
%\end{tabular}
%\caption{Embeddings of the ${\tt string\_in}$ fragment into $\lamAce$ and Ace.}
%\end{table*}
%%
%\newcommand{\atjsynX}[3]{\Gamma \vdash_\fvalCtx #1 \Rightarrow #2 \leadsto #3}
%\newcommand{\atjanaX}[3]{\Gamma \vdash_\fvalCtx #1 \Leftarrow #2 \leadsto #3}
%\newcommand{\atjerrX}[1]{\Gamma \vdash_\fvalCtx #1~ \mathtt{error}}
%\begin{figure*}[t]
%\small
%$\fbox{\inferrule{}{\atjsynX{e}{\tau}{i}}}$~~~~
%$\fbox{\inferrule{}{\atjanaX{e}{\tau}{i}}}$~~~~
%%$\fbox{\inferrule{}{\atjerrX{e}}}$
%\begin{mathpar}
%\inferrule[att-flip]{
%	\atjsynX{e}{\tau}{i}
%}{
%	\atjanaX{e}{\tau}{i}
%}
%
%%\inferrule[att-var]{
%%	x \Rightarrow \tau \in \Gamma
%%}{
%%	\atjsynX{x}{\tau}{x}
%%}
%%
%%\inferrule[att-asc]{
%%    \tau \Downarrow_\fvalCtx \tau'\\
%%	\atjanaX{e}{\tau'}{i}
%%}{
%%	\atjsynX{e : \tau}{\tau'}{i}
%%}
%%
%%\inferrule[att-let-syn]{
%%	\atjsynX{e_1}{\tau_1}{i_1}\\
%%	\Gamma, x \Rightarrow \tau_1 \vdash_\fvalCtx e_2 \Rightarrow \tau_2 \leadsto i_2\\
%%	\trepof{\tau_1} \Downarrow_\fvalCtx \titype{\sigma_1}
%%}{
%%	\atjsynX{\F{let}x = e_1~\F{in}e_2}{\tau_2}{(\ilam{x}{\sigma_1}{i_2})~i_1}
%%}
%%
%%\inferrule[att-lam-ana]{
%%	\Gamma, x \Rightarrow \tau_1 \vdash_\fvalCtx e \Leftarrow \tau_2 \leadsto i\\
%%	\trepof{\tau_1} \Downarrow_\fvalCtx \titype{\sigma_1}
%%}{
%%	\atjanaX{\lambda x.e}{\ttype{arrow}{(\tau_1, \tau_2)}}{\ilam{x}{\sigma_1}{i}}
%%}
%%
%%\inferrule[att-lam]{
%%	\tau_1 \Downarrow_\fvalCtx \tau_1'\\
%%		\trepof{\tau_1'} \Downarrow_\fvalCtx \titype{\sigma}\\\\
%%	\Gamma, x \Rightarrow \tau_1' \vdash_\fvalCtx e \Rightarrow \tau_2 \leadsto i
%%%	i \hookrightarrow_\fvalCtx i'\\
%%%		\sigma \hookrightarrow_\fvalCtx \sigma'
%%%	\ddbar{\fvar{Arrow}}{\fvalCtx}{\trepof{\tau_1'}}{\sbar_1}\\
%%	%\delfromtau{$\Xi_0$}{\fvalCtx}{\tau_1'}{\sabs}\\\\
%%}{
%%	\atjsynX{\elam{x}{\tau_1}{e}}{\ttype{arrow}{(\tau_1', \tau_2)}}{\ilam{x}{\sigma'}{i}}
%%}
%%
%\inferrule[att-intro-ana]{
%	\vdash_\fvalCtx \FF{iana}(\fvar{tycon})=\taudef\\
%	\taudef~\taut{opidx}~\taut{tyidx}~((\Gamma; e_1)? :: \ldots :: (\Gamma; e_n)? :: []) \Downarrow_\fvalCtx \titerm{i}\\\\
%%	\trepof{\ttype{tycon}{\tauidx'}} \Downarrow_\fvalCtx \titype{\sigma}\\
%		\trepof{\ttype{tycon}{\taut{tyidx}}} \Downarrow_\fvalCtx \titype{\sigma}\\
%		\Gamma \vdash_\fvalCtx i : \sigma
%}{
%	\atjanaX{\FF{intro}[\taut{opidx}](e_1; \ldots; e_n)}{\ttype{tycon}{\taut{tyidx}}}{i}
%}
%
%%\inferrule[att-i-asc-ty]{
%%	\atjanaX{I}{\tau}{i}
%%}{
%%	\atjsynX{I : \tau}{\tau}{i}
%%}
%%
%%\inferrule[att-i-asc-tycon]{
%%	\vdash_\fvalCtx \FF{isyn}(\fvar{tycon})=\taudef\\\\
%%	\taudef~\tauidx~((\Gamma; e_1)? {::}{\ldots}{::}(\Gamma; e_n)? {::} []) \Downarrow_\fvalCtx \tden{\titerm{i}}{\ttype{tycon}{\tauidx'}}\\
%%			\trepof{\tau_1'} \Downarrow_\fvalCtx \titype{\sigma}\\
%%	\Gamma \vdash_\fvalCtx i : \sigma
%%}{
%%	\atjsynX{\FF{intro}[\tauidx](e_1; \ldots; e_n)] :: \fvar{tycon}}{\ttype{tycon}{\tauidx'}}{i'}
%%}
%%
%\inferrule[att-elim-syn]{
%	\atjsynX{e}{\ttype{tycon}{\taut{tyidx}}}{i}\\
%	\vdash_\fvalCtx \FF{esyn}(\fvar{tycon})=\taudef\\\\
%	\taudef~\taut{opidx}~\taut{tyidx}~\titerm{i}~((\Gamma; e)? :: (\Gamma; e_1)? :: \ldots :: (\Gamma; e_n)? :: []) \Downarrow_\fvalCtx (\tau, \titerm{i'})\\\\
%			\trepof{\tau} \Downarrow_\fvalCtx \titype{\sigma}\\
%	\Gamma \vdash_\fvalCtx i' : \sigma
%}{
%	\atjsynX{e\cdot\FF{elim}[\taut{opidx}](e_1; \ldots; e_n)}{\tau}{i'}
%}
%\end{mathpar}
%%\vspace{-10px}
%\caption{The bidirectional active typechecking and translation judgements.}
%\label{atj}
%\end{figure*}
%\newcommand{\tlevalX}[2]{#1 \Downarrow_\fvalCtx #2}
%\begin{figure*}[t]
%\small
%$\fbox{\inferrule{}{\tau \Downarrow_\fvalCtx \tau'}}$~~~~
%\begin{mathpar}
%\inferrule[trstr-eval]{ }{\tlevalX{\tlstr{s}}{\tlstr{s}}}
%
%\inferrule[tremp-eval]{ }{\tremp \Downarrow_\fvalCtx \tremp}
%
%\cdots
%
%\inferrule[tror-eval]{
%	\tlevalX{\tau_1}{\tau_1'}\\
%	\tlevalX{\tau_2}{\tau_2'}
%}{
%	\tlevalX{\tror{\tau_1}{\tau_2}}{\tror{\tau_1'}{\tau_2'}}
%}
%
%trmatch
%
%trlsubst
%
%trsublang
%
%
%%\inferrule[repof]{
%%	\tau \Downarrow_\fvalCtx \ttype{tycon}{\tauidx}\\
%%	\vdash_\fvalCtx \FF{rep}(\fvar{tycon}) = \taurep\\
%%	\taurep~\tauidx \Downarrow_\fvalCtx \titype{\sigma}
%%}{
%%	\FF{repof}(\tau) \Downarrow_\fvalCtx \titype{\sigma}
%%}
%%
%\inferrule[syn]{
%    \tau \Downarrow_\fvalCtx (\Gamma; e)?\\
%	\atjsynX{e}{\tau}{\iota}\\\\
%    [\tau/\tvar{t}_{ty}, \titerm{\iota}/\tvar{t}_{trans}]\tau_2 \Downarrow_\fvalCtx \tau_2'
%}{
%	\FF{syn}(\tau_1; \tvar{t}_{ty}, \tvar{t}_{trans}.\tau_2) \Downarrow_\fvalCtx \tau_2'
%}
%
%\inferrule[ana]{
%	\tau_1 \Downarrow_\fvalCtx (\Gamma; e)?\\
%	\tau_2 \Downarrow_\fvalCtx \tau_2'\\
%	\atjanaX{e}{\tau_2'}{\iota}\\\\
%	[\titerm{\iota}/\tvar{t}_{trans}]\tau_3 \Downarrow_\fvalCtx \tau_3'
%}{
%	\FF{ana}(\tau_1; \tau_2; \tvar{t}_{trans}.\tau_3) \Downarrow_\fvalCtx \tau_3'
%}
%
%TODO: add rx, str stuff
%\end{mathpar}
%\caption{\small Normalization semantics for the type-level language. Missing rules (including error propagation rules and normalization of quoted internal terms and types) are unsurprising and will be given later.}
%\label{tleval}
%\end{figure*}
%\begin{figure}[t]
%\small\begin{flalign}
%& \F{tycon}\fvar{stringin}~\F{of}\FF{R}~\{\\
%& \quad \F{iana}\{\tlam{opidx}{\FF{String}}{
%	\tlam{tyidx}{\FF{R}}{
%	\tlam{a}{\klist{\Q}}{\\
%& \quad\quad \tvar{arity0}~\tvar{a}~(\tvar{check}~\tvar{opidx}~\tvar{tyidx}~\titerm{\iup{\tvar{opidx}}})
%	}}
%}\}\\
%& \quad \F{esyn}\{\tlam{opidx}{\kunit+(\FF{R}+\FF{R})}{
%	\tlam{a}{\klist{\Q}}{\\
%& \quad\quad \tsumcase{\tvar{opidx}}{\_}{\\
%& \quad\quad\quad \tvar{arity2}~\tvar{a}~\tlam{a1}{\Q}{\tlam{a2}{\Q}{\\
%& \quad\quad\quad\quad \tvar{rsyn}~\tvar{a1}~\tlam{r1}{\FF{R}}{\tlam{i1}{\kITerm}{~}}\\
%& \quad\quad\quad\quad \tvar{rsyn}~\tvar{a2}~\tlam{r2}{\FF{R}}{\tlam{i2}{\kITerm}{~}}\\
%& \quad\quad\quad\quad\quad (\ttype{stringin}{\FF{rseq}(\tvar{r1}; \tvar{r2})}, \\
%& \quad\quad\quad\quad\quad\titerm{{\tt iconcat}(\iup{\tvar{i1}}; \iup{\tvar{i2}})})
%}}\\
%& \quad\quad}{opidx'}{d}}
%}\}
%\};\\
%& \F{def}\tvar{concat} = \tinl{\kunit, \FF{R}+\FF{R}}{\tunit};\\
%& \F{def}\tvar{subst} = \tlam{r}{\FF{R}}{\tinr{\kunit, \FF{R}+\FF{R}}{\tinl{\FF{R},\FF{R}}{\tvar{r}}}};\\
%& \F{def}\tvar{coerce} = \tlam{r}{\FF{R}}{\tinr{\kunit, \FF{R}+\FF{R}}{\tinr{\FF{R},\FF{R}}{\tvar{r}}}}
%\end{flalign}
%\caption{Definition of $\phi_S$, which enables the embedding of fragment $S$ into $\lamAce$.}
%\end{figure}
%%\begin{figure}
%%\[
%%\begin{array}{lcl}
%%% & & Definition & Kind\\
%%\tvar{concat} & := & \tinl{\kunit, \FF{R}+\FF{R}}{\tunit}\\%& \kunit + (R + R)\\
%%\tvar{replace} & := & \tlam{r}{\FF{R}}{\tinr{\kunit, \FF{R}+\FF{R}}{\tinl{\FF{R},\FF{R}}{\tvar{r}}}}\\% & \karrow{a}{b}\\
%%\tvar{coerce} & := & \tlam{r}{\FF{R}}{\tinr{\kunit, \FF{R}+\FF{R}}{\tinr{\FF{R},\FF{R}}{\tvar{r}}}}\\
%%\end{array}
%%\]
%%\caption{Definitions}
%%\end{figure}
%
%\subsection{Background: Ace}
%TODO: Make a TR out of the OOPSLA submission.
%\subsection{Explicit Conversions}
%\subsection{Adding Subtyping to Ace}
%\subsection{Theory}
%
%\section{Related Work}
%
%\section{Discussion}
%
%
\bibliographystyle{abbrv}

\bibliography{research}

% The bibliography should be embedded for final submission.


%\begin{thebibliography}
%
%\bibitem{lamport94}
%Leslie Lamport,
%\emph{\LaTeX: a document preparation system}.
%Addison Wesley, Massachusetts,
%2nd edition,
%1994.
%
%\end{thebibliography}
\end{document}
