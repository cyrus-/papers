% !TEX root = omar-thesis-proposal.tex
\section{Related Work}
We review existing approaches that are available to researchers and domain experts who wish to develop novel constructs below.

\subsection{Language-Oriented Approaches}
\subsubsection{Language Frameworks}
A number of tools have been developed to assist with this task of developing new languages and their associated tools, including compiler generators, language workbenches and domain-specific language frameworks (see \cite{fowler2010domain} for a review). In some cases, these tools allow language features to be defined modularly and composed differentially to produce a variety of different languages. To our knowledge, none of these mechanisms guarantee that any combination of features can be safely composed, nor do they guarantee safety properties about the resulting languages. User-defined code is still ultimately compiled against a particular language, and because language composition cannot be automatic or guaranteed safe, interoperability with code written in other languages is thus limited by the difficulties described above despite the modular construction.

\subsubsection{Extensible Compilers and Tools}
A related methodology is to implement language features as compiler and tool extensions directly. A number of extensible compilers have been developed to support this approach (see \cite{clements2008comparison}). As with language frameworks, this approach can lead to \emph{de facto} implementation of a new language, since user libraries must be compiled against a particular combination of extensions, and these extensions cannot be guaranteed to compose in general. Moreover, a language may have multiple competing compilers and other tools. By relying on implementation-specific features of a single tool to define core semantics and behaviors, the clean conceptual separation between languages and tools is broken, leading to compatibility issues and hard-to-anticipate behaviors for user code. We argue that this approach should be considered harmful.

\subsection{Library-Oriented Approaches}
\subsubsection{Embedded DSLs}
Embedded domain-specific languages are languages that creatively repurpose existing language constructs to create interfaces that resemble those of a distinct language. In languages with rich type systems, such as Haskell, this approach can be quite successful (e.g. \cite{svensson2011obsidian}). Ultimately, however, this approach is limited by the host system, and as discussed in Section 2, thus limits experts who want to express particularly novel constructs, relative to the host language. 

\subsubsection{Term Rewriting Systems}
Many languages and tools allow developers to rewrite expressions according to custom rules. These can broadly be classified as {\it term rewriting systems}. Macro systems, such as those characteristic of the LISP family of languages \cite{mccarthy1978history}, are the most prominent example. Some compile-time metaprogramming systems also allow users to manipulate syntax trees (e.g. MetaML \cite{Sheard:1999:UMS}), and external rewrite systems also exist for many languages. These systems are expressive if used correctly, but verifying correctness and non-interference properties is difficult for the same reason. Manipulating source trees directly is a complex task, even in languages with simple grammars like LISP. Finally, term rewriting systems focus on rewriting terms to support alternative language semantics but do not intrinsically support extensions that cover the full programming system.

\subsubsection{Active Libraries}
Active libraries, as proposed by Czarnecki et al. \cite{activelibraries}, ``are not passive collections of routines or objects, as are traditional libraries, but take an active role in generating code''. They go on to suggest a number of areas in which the library could interact with the programming system, including optimizing code, checking source code for correctness, reporting domain-specific errors and warnings, and ``rendering domain-specific textual and non-textual program representations and for interacting with such representations''. 

This paper was largely a proposal. The concrete implementations of this concept have largely been term rewriting systems described above. One prominent example within the active libraries literature is Blitz++, which uses the C++ template expansion system as a metalanguage to support optimizations of array operations. An example of tool support comes from the Tau package for tuning and analyzing parallel programs. Tau allows libraries to instrument themselves declaratively to hide internal details and complex internal representations from users. A more extensive system with support for active libraries is Xroma. Xroma allows users to provide annotations that intercept compilation of a component at various stages of compilation to support rewriting, custom error handling and custom error checking. The approach taken by Xroma, by still requiring direct syntax manipulation and allowing arbitrary interception, is flexible but not compositional, and generally more complex than may be necessary. There also does not appear to be a clear, well-founded theoretical foundation for this approach, nor for active libraries in general.

%\subsection{Type-Level Computation} %Haskell, Ur and $\Omega$mega
%System XX with simple case analysis provides the basis of type-level computation in Haskell (where type-level functions are called type families \cite{Chakravarty:2005:ATC}). Ur uses type-level records and names to support typesafe metaprogramming, with applications to web programming \cite{conf/pldi/Chlipala10}. $\Omega$mega adds algebraic data types at the type-level, using these to increase the expressive power of algebraic data types at the expression level \cite{conf/cefp/SheardL07}. Dependently-typed languages blur the traditional phase separation between types and expressions, so type-level computation is often implicitly used (though not always in its most general form, e.g. Deputy \cite{conf/icfp/ChenX05}, ATS \cite{conf/esop/ConditHAGN07}.)

%\subsubsection{Run-Time Indirection}
%{\it Operator overloading} \cite{vanWijngaarden:Mailloux:Peck:Koster:Sintzoff:Lindsey:Meertens:Fisker:acta:1975} and {\it metaobject dispatch} \cite{Kiczales91} are run-time protocols that translate operator invocations into function calls. The function is typically selected according to the type or value of one or more operands. These protocols share the notion of {\it inversion of control} with type-level specification. However, type-level specification is a {\it compile-time} protocol focused on enabling specialized verification and implementation strategies, rather than simply enabling run-time indirection.

%\subsection{Specification Languages}
%Several {\it specification languages} (or {\it logical frameworks}) based on these theoretical formulations exist, including the OBJ family of languages (e.g. CafeOBJ \cite{Diaconescu-Futatsugi01}). They provide support for verifying a program against a language specification, and can automatically execute these programs as well in some cases. The  language itself specifies which verification and execution strategies are used.
%
%Type-determined compilation takes a more concrete approach to the problem, focusing on combining {\it implementations} of different\- logics, rather than simply their specifications. In other words, it focuses on combining {\it type checkers} and {\it implementation strategies} rather than more abstract representations of a language's type system and dynamic semantics. In Section 4, we outlined a preliminary approach based on proof assistant available for the type-level language to unify these approaches, and we hope to continue this line of research in future work.
%
