% !TEX root = omar-thesis-proposal.tex
\section{Active Types}\label{contributions}
\todo{better transition}The mechanisms described in this thesis are designed to be highly {expressive}, allowing library-based implementations of features comparable to built-in features found in modern programming systems, but without allowing the kinds of {safety} violations possible when using previous mechanisms. %This is accomplished by organizing extension logic around types and scoping it to or around expressions of the type it is associated with, rather than applying it globally or within contiguous blocks as in previous mechanisms. 
To motivate the approach we will take to achieve this, let us return to the example of regular expressions. Observe that each of the features described in Section \ref{regex} relates specifically to how terms representing regular expression patterns, which will always have a consistent user-defined type, let's call it \verb|Pattern|\footnote{More generally, it may be several different types within an indexed type family. For example, \texttt{Pattern(}$n$\texttt{)}  represents a pattern containing $n$ matching groups, so \texttt{Pattern} is  a type family indexed by a natural number, $n$ \cite{regex-type-system}. We will return to this distinction in Section \ref{att}. We should also note that to properly prevent conflicts, naming conflicts must also be avoided by the use of an appropriate qualified name for this type. Suitable namespacing mechanisms are already well-developed and will be assumed in this thesis.}, should be processed by various tools. %Let us refer to this type by a simple name, \verb|Pattern| (but it would need to have a fully-qualified name to ensure that conflicts due to name clashes cannot occur). 
It is only when creating, editing or compiling expressions of type \verb|Pattern| that the logic enumerated in Section \ref{regex} would ever need to be invoked. 

Indeed, this is not a coincidence of our example, but a commonly-seen pattern. Types are already known to be a natural organizational unit around which the semantics of programming languages and logics can be defined. For example, in both TAPL \cite{tapl} and PFPL \cite{pfpl}, most chapters simply describe the semantics and metatheory of a few new types without reference to other types. In these descriptions, the composition of these types and associated operators into languages is a metatheoretic (that is, language-external) notion. For example, in PFPL, the notation L\todo{use Bob's fancy L}($\rightarrow$ \verb|nat| \verb|dyn|) represents a language composed of the arrow ($\rightarrow$), \verb|nat| and \verb|dyn| types and their associated operators, each group of which is defined in separate chapters. This organization suggests a principled language-internal alternative to the mechanisms described in Section \ref{alibs} that preserves most of their expressiveness but eliminates the possibility of conflict and makes it easier to reason locally about a piece of code: associating extension logic to a single type or type family as it is defined and scoping it only to operations on expressions in that type or type family.  We call types with such logic associated with them \emph{active types} and systems that support them \emph{actively-typed programming systems}. By constraining the extension logic itself by various means, including with its own type system and by applying techniques from the compiler correctness literature, we can ensure that the system as a whole maintains important safety properties.


\subsection{Proposed Contributions}
In Section \ref{att}, we will describe how to extend the core static and dynamic semantics of a language in an actively-typed and safe manner. We will distill the essence of our approach, which we call \textbf{active typechecking and translation (AT\&T)}, by specifying an actively-typed lambda calculus called @$\lambda$, proving several key safety theorems, and examining the connections between active types and type-level computation, type abstraction and typed compilation techniques. We will then go on to demonstrate the expressiveness of this mechanism by designing and implementing a full-scale language, Ace, and implementing a number of interesting type families from existing full-scale languages as active libraries within Ace. A primary focus of this work is on high-performance computing abstractions, but we will also show some uses of Ace for other domains.

In both @$\lambda$ and Ace, semantic extensions operate over a fixed syntax. Many kinds of syntax extensions involve developing special literal forms for some type or family of types, including the examples of regular expression patterns, HTML and XML mentioned above. In Section \ref{aparsing}, we will show how such domain-specific syntax can be introduced in an actively-typed and safely composable manner. Our technique is called \textbf{actively-typed parsing} and it will be implemented within the Wyvern programming language. \todo{clean up Wyvern contributions} Our novel contributions include the design of a second parsing phase for processing ``TSL literals'' that runs in tandem with typechecking, a method for using whitespace to delimit domain-specific syntax, a generalization of standard literal forms so that they can be used for more than one type, a recursive use of the active parsing technique to introduce a declarative syntax for defining actively-typed grammars, and an elegant underlying general-purpose mechanism for associating compile-time data and functionality with structural types. We will describe each of these contributions as implemented in Wyvern, develop minimal formal systems showing how the syntax and semantics of Wyvern supports actively-typed parsing, and examine the expressiveness of this technique for introducing novel literal forms, as well as for use cases beyond literal forms that can also be expressed by creative application of this technique.

Finally, in Section \ref{acc}, we will show how editor-integrated domain-specific tooling for working with expressions of a single type can be introduced from within active libraries, by a technique known as \textbf{active code completion}. Developers associate
domain-specific user interfaces, called \emph{palettes}, with types. Users discover and invoke palettes from the code completion menu at edit-time, populated according to an actively-typed mechanism similar to that of actively-typed parsing. When they are done, the palette generates a term of that type based on the information received from the user. Using several empirical
methods, we survey\- the expressive power of this approach, describe the design and safety constraints governing
the mechanism, and develop one such system for Java\footnote{In Graphite, palettes are associated with Java classes, which serve many of the same purposes as types do in other languages. Active code completion could be implemented just as well in non-object-oriented systems.}, based on these constraints, called Graphite. Using Graphite,
we implement a palette for working with regular expressions in order to conduct a pilot study that provides evidence for the usefulness of this approach, and of contextually-invoked editor-integrated tools generally.

Taken together, these mechanisms demonstrate that actively-typed mechanisms can be introduced throughout a programming system to allow users to extend both its compile-time and edit-time semantics from within libraries, without  weakening the metatheoretic guarantees that the system provides. They also further demonstrate that types are a natural organizational unit for defining programming system semantics, because a great variety of features can be expressed in an actively-typed manner, and doing so guarantees that the features will be safely composable in any combination. In this thesis, each mechanism will be implemented within a different programming system, showing that actively-typed mechanisms are relevant across traditional paradigms, including functional languages (@$\lambda$), class-based OO languages (Graphite), structurally-typed languages (Wyvern) and scripting languages (Ace). In the future, we anticipate that mechanisms based on those in this thesis will be brought together into a single highly-extensible system with a minimal, well-specified core, where nearly every feature is distributed within a library. 

%
%This suggests that a natural place where these features can be defined is in the library containing the declaration of \verb|Pattern| itself, rather than in the language and tool implementations. An \emph{actively-typed} definition of \verb|Pattern| would thus be equipped with	 functions that described how the parser (item 1), type checker (item 2), translator (item 3) and editor (item 4) should operate when working with expressions of type \verb|Pattern|. We can abstractly denote this declaration, as it would exist within a user-defined library, as follows:
%\begin{equation*}
%{\sf type}~Pattern[f_{\text{editor}}]\{
%\textbf{z}[f_{\text{resolve-z}}, f_{\text{compile-z}}], 
%\textbf{s}[f_{\text{resolve-s}}, f_{\text{compile-s}}], 
%\textbf{natrec}[f_{\text{resolve-rec}}, f_{\text{compile-rec}}]\}
%\end{equation*}
%
%When type checking an expression like $\nats{\nats{\natz}}$, the type checker delegates to the user-provided type-level function $f_{\text{resolve-s}}$. This function would be tasked with assigning a type to expression as a whole, given information including the \emph{types} (but not necessarily the full syntax trees) of all its subexpressions, or if a type cannot be assigned, producing a specific error message. Similarly, the compiler calls the $f_{\text{compile-s}}$ function to determine a representation in the target language for the expression, checking to ensure that it is well-formed and type-correct with respect to the target type system. Finally, elements of the editor may call into the $f_{\text{editor}}$ function (or one of several such functions, more generally) to control behaviors like code completion and code prediction when an expression of type $\nat$ is being entered. 
%
%Note that these functions are \emph{not} to be conflated with methods or run-time functions -- they are functions written in a type-level language that are called at compile-time and edit-time to define the basic behaviors associated with the type that they are associated with.
%
%\subsection{Characteristics of an Actively-Typed Programming System}
%An actively-typed programming system can be characterized by its choice of type-level language, source grammar, target language and dispatch protocols.
%
%\paragraph{Type-Level Language} The type-level language is the language within which the type definitions and the functions that define their behaviors are defined. This language must be constrained so that different definitions do not interfere with one another and so that desirable safety properties for the system as a whole are maintained, as we discuss below.
%
%\paragraph{Source Language} The source language is the language with which run-time behavior is defined. In our example above, terms like $\nats{\nats{\natz}}$ are part of the source language. In the purest case, the source language is simply a grammar; its semantics are given entirely by active type specifications.
%
%\paragraph{Dispatch Protocol} For each syntactic form in the source language, there is a dispatch protocol that determines which type is delegated responsibility over it, and which specific function(s) are called for each behavior the system supports. This fixed protocol makes it possible for users to predict the meaning of a construct using information local to the term, a key differentiator of this approach compared to term-rewriting systems where there can be action at a distance.
%
%\paragraph{Target Language} The target language is the language that the front-end compilation phase of the system targets. The limitations and constraints imposed by the target language are final, because all constructs ultimately translate into terms in the target language. In other words, active type specifications can only add additional invariants to the language; they cannot violate invariants imposed by the target language.

%\subsection{Research Challenges}
%The example of natural numbers given above is relatively simple, and the solution we outline remains abstract. A key challenge is then to demonstrate that this approach is able to express the behaviors of more sophisticated language constructs that span diverse problem domains, and be implemented in the context of a realistic collection of tools. The resulting system should be usable by developers who lack the expertise needed to define new language constructs themselves.
%
%Simultaneously, we must also demonstrate that this model is well-motivated theoretically, place it within the broader context of the theory of typed programming languages, and demonstrate that it is possible for desirable system safety properties to be maintained. In particular, we are interested in properties like:
%
%\begin{itemize}
%\item Correctness of active type specifications, so that users of a library need not be forced to debug errors arising within the specifications themselves.
%\item Correctness of translations, so that the results of translation are guaranteed to be well-typed and consistent with respect to the target language.
%\item Termination of active type specifications, so that evaluation of the type-level functions cannot cause the compiler or editor to hang.
%\item Composability of active type specifications, so that the behaviors defined by one type cannot interfere with those defined by another, no matter the order in which they are imported. This property is essential if we wish to place these specifications within normal libraries.
%\end{itemize}


