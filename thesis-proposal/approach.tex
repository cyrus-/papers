% !TEX root = omar-thesis-proposal.tex
\section{Our Approach: Active Type Constructors}\label{contributions}
%We seek to introduce language-integrated mechanisms that permit library-based implementations of features that compare to and  go beyond the features built into modern programming systems. However, we seek to avoid the associated {metatheoretic} issues and  maintain the ability to understand and reason about libraries modularly, and by a type-based discipline. %This is accomplished by organizing extension logic around types and scoping it to or around expressions of the type it is associated with, rather than applying it globally or within an explicitly delimited scope as in previous mechanisms. 

To motivate our approach, let us return to our example of regular expressions. We observe that every feature described in Sec. \ref{regex} relates specifically to how terms classified by a type for regular expression patterns, e.g. \verb|Pattern|, should behave. Feature 1 calls for specialized syntax for its introductory form. Features 2a and 2b relate to which operations on patterns exist and how they should be typechecked. Feature 3 discusses editor services only relevant when editing a term of such a type. Feature 2c relates to the semantics of a related  type constructor classifying strings known to be in a regular language.% type that the logic in Sec. \ref{regex}  needs to be considered. 

Indeed, this is a common pattern: the semantics of programming languages (and logics) have long been organized around their types (equivalently, their propositions). %One of the principal tasks of the logical analysis of a given proposition is to find out the method of verification for that proposition.
For example, Carnap in his 1935 book \emph{Philosophy and Logical Syntax} stated \cite{carnap1935philosophy}:
\begin{quote}
One of the principal tasks of the logical analysis of a given proposition is to find out the method of verification for that proposition.
\end{quote}
In two modern textbooks about programming languages, \emph{TAPL} \cite{tapl} and \emph{PFPL} \cite{pfpl}, most chapters describe the syntax, semantics and metatheory of a new type constructor and its associated  operators (collectively, a \emph{fragment}) in isolation. Combining the fragments from different chapters into complete languages is, however, a language-external (that is, metamathematical) operation. In \emph{PFPL}, for example,  the notation $\mathcal{L}$\{$\rightarrow$ \verb|nat| \verb|dyn|\} represents a language that combines the arrow ($\rightarrow$), \verb|nat| and \verb|dyn| type constructors\footnote{We can consider base types like $\mathtt{nat}$ and $\mathtt{dyn}$ as being trivially indexed type constructors, see Sec. \ref{att}.} and their associated operators. Each of these are defined in separate chapters, and it is generally left unstated that the semantics developed separately can be combined conservatively, i.e. with all the fundamental metatheory left intact, a notion we will refine later. This is intuitively justified by a sense that the rules in each chapter seem ``well-behaved'' in that they  avoid violating the autonomy of other fragments. %This organization has long been employed in the study of logic as well. 
For example, they do not introduce a new value of a type defined in another fragment, because this would render invalid any conclusions arrived at by induction over value forms for that type. 

If we can somehow formalize this notion of a ``fragment'' and ``autonomy'' and internalize it into the language itself, rather than leaving it as a ``design pattern'' that only informally guides the work of a central language (or textbook) designer, we might achieve  a safely extensible language, i.e. one where separately defined embeddings of  fragments as libraries can be safely combined. Doing so without limiting expressiveness or weakening the system's metatheory is precisely the topic of this thesis. %e of organizing a fragment around the type constructors it introduces, and
%We call a type constructor defining new syntax, semantics or editor services an \emph{active type constructor}. %This choice, of associating extensions with type constructors rather than term constructors, avoids many issues collectively associated with the \emph{expression problem}, as we will discuss later.


%As we will show, taking a type-oriented point-of-view provides a means to satisfy this principle.
%Making this precise and showing how the language can preclude poorly-behaved fragments from causing problems, while retaining the ability to define interesting fragments, is the focus of this thesis.

%But enforce a golden rule: that each builder of a logic respects every other's autonomy. % That is our goal in this thesis. %By constraining the extension logic itself by various means we will show that the system as a whole can also maintain many other important safety and non-interference properties that have not previously been achieved. 
%We call types with such logic associated with them \emph{active types} and systems that support them \emph{actively-typed programming systems}. 

\subsection{Proposed Contributions}
This thesis will introduce several language-integrated extensibility mechanisms, each organized around type constructors, that decentralize control over a different feature of the system. In each case, we will show that the system retains important metatheoretic properties and that extensions cannot violate one another's autonomy, in ways that we will make more precise as we go on.  We will also discuss various points related to extension correctness (as distinct from safety, which will be guaranteed even if an incorrect extension is imported). To justify the  expressiveness of each approach, we will give a number of examples of non-trivial features that are, or would need to be, built into conventional systems, but that can be expressed within libraries using the mechanisms we introduce. To help us gather a broad, unbiased collection of examples and demonstrate the scope and applicability of our approaches in practice, we will also conduct small empirical studies when appropriate (though the primary contributions of this work are technical).

We begin in Sec. \ref{aparsing} by considering \textbf{concrete syntax}. The availability of specialized syntax can bring numerous cognitive benefits \cite{green1996usability}, and discourage the use of problematic techniques like using strings to represent structured data \cite{Bravenboer:2007:PIA:1289971.1289975}. But allowing library providers to add arbitrary new syntactic forms to a language's grammar can lead to ambiguities, as described above. We observe that many syntax extensions are motivated by the desire to add alternative  introductory forms (a.k.a. \emph{literal forms}) for a particular type constructor. For example, regular expression pattern literals as described in Sec. \ref{regex} are an introductory form for the \verb|Pattern| type constructor.  In the mechanism we introduce, literal syntax is associated directly with a user-defined type constructor and can be used only where an expression of a type it constructs is expected (shifting part of the burden of parsing into the typechecker). This avoids the problem of an extension interfering with the base language or another extension  because these grammars are never modified directly. We begin by introducing these \emph{tycon-specific languages (TSLs)} in the context of a simplified variant of a language we are developing called Wyvern. Next, we show how interference issues in the other direction -- the base language interfering with  the TSL syntax -- can be avoided by using a novel layout-delimited literal form. We then develop a formal semantics, basing it on work in bidirectional type systems and typed elaboration semantics (which we together call a \emph{bidirectionally typed elaboration semantics}). Using this semantics, we introduce a mechanism that statically prevents a third form of interference: unsafe variable capture and shadowing (a form of \emph{hygiene}).% Finally, we conduct a corpus analysis to examine this technique's expressiveness, finding that a substantial fraction of string literals in existing code could be replaced by TSL literals.

Wyvern has an extensible concrete syntax but a fixed semantics based around recursive sum and product types. These are of course simple and highly general, and implementation techniques for them are well-developed, but there remain situations where providers may wish to extend the {type system} of a language directly by introducing more specialized static semantics. Examples of language dialects motivated by a need for this level of control abound in the research literature. For example, to implement the features in Sec. \ref{regex}, new logic must be added to the type system to statically track information related to backreferences (feature 2b, see \cite{spishak2012type}) or to execute a decision procedure for language inclusion when determining whether a coercion requires a run-time check (feature 2c, see \cite{fulton-thesis,HosoyaVouillonPierce2000ICFP}). We discuss more examples from the literature in Sec. \ref{att}. To support these more advanced use cases in a decentralized manner, we next develop mechanisms for implementing \textbf{type system} extensions. We begin with a core calculus, @$\lambda$, in Sec. \ref{theory}, then design a ``practical'' implementation, @\verb|lang|, as a library inside Python in Sec. \ref{ace} (which serves as an interesting challenge because Python begins with an initially quite impoverished static semantics). Both are organized around a bidirectionally typed translation semantics (which differs from an elaboration semantics like that used for Wyvern in that the external and internal languages have different type systems). We discuss issues including type safety (using techniques borrowed from the typed compilation literature), decidability and conservativity -- that embeddings of a type system can be shown correct modularly, guaranteed using a form of ``internal'' type abstraction. We also demonstrate the expressiveness of the technique by implementing a host of type system fragments as libraries in @\verb|lang|, including the entirety of the OpenCL programming language, the core of an ML-like language, a simple object system and a type system for tracking the regular language a string belongs to (feature 2c above).
%@\verb|lang| in particular supports a claim of expressiveness -- we show a variety of type system fragments implemented as libraries, including the entirety of the OpenCL programming language, several functional abstractions, a simple object system and specialized abstractions like the regular expression types described previously.% We then switch to discussing the core calculus, showing how it guarantees type safety , and also how it guarantees that type system fragments cannot interfere (using a form of type abstraction). %This means that a strong embedding cannot be weakened once established by enforcing abstraction barriers between extensions using a form of type abstraction. We call isomorphic embeddings constructed in this way \emph{active embeddings}. By beginning from first principles, we are able to cleanly state and prove the key metatheoretic principles, define the criteria for a strong embedding and give a conservativity theorem. We also discover connections with several prior notions, including type-level computation, typed compilation and abstract types. 
%
%We then go on in Sec. \ref{ace} to demonstrate the expressiveness of this mechanism by designing and implementing a full-scale actively typed language, Ace. Interestingly, Ace is itself bootstrapped as a library within an existing language that has a rather impoverished type system, Python. We discuss how we accomplish this, define its core semantics (as a bidirectional typed elaboration semantics, as with Wyvern), and implement a number of powerful primitives from existing languages as libraries. These examples cover a variety of paradigms, including low-level parallel and concurrent languages, functional languages, object-oriented languages and specialized domains, like the regular expression types discussed in the introduction. We also introduce a novel extensible form of staged compilation where the tags associated with Python values can propagate into Ace functions as static types according to an extensible protocol, and show how this is particularly well-suited to contemporary scientific workflows.

Finally, in Sec. \ref{acc}, we show an example of a novel class of \textbf{editor services} that can be implemented within libraries, introducing a technique we call \emph{active code completion}. Code completion is a common editor service (found in editors like Vim and Emacs as well as in the editor components of development environments like Eclipse) that helps programmers  by providing a menu of code snippets based on the surrounding code context. This is a useful but rather generic user interface. There are a variety of tools in the literature and online that help programmers generate code snippets using alternative, more specialized user interfaces. For example, a regular expression workbench helps programmers write regular expression patterns more easily (e.g. \cite{IntelliJRegexp,_txt2re:_????}). A color chooser can be considered a specialized user interface for creating an expression of type \verb|Color|. 
Active code completion brings these kinds of type-specific code generation interfaces, which we call \emph{palettes}, into the editor, and allows library providers to associate them with their own type constructors. Clients discover and invoke palettes from the standard code completion menu, populated according to the expected type at the cursor (a protocol similar to the one we use for syntax extensions in Wyvern). When the interaction between the client and the palette is complete, the palette produces an elaboration of the type it is associated with based on the information received from the user (the reader may wish to skip ahead to Fig. \ref{colorpalette} in Sec. \ref{acc} for an example). Using several empirical
methods, including a large developer survey, we examine the expressive power of this approach and develop design criteria. We then develop an active code completion system called Graphite. 
%Palettes are implemented as sandboxed webpages, avoiding excessive reliance on any particular editor implementation (our initial implementation is as a very simple Eclipse extension). 
Using Graphite,
we implement a palette for working with regular expressions and conduct a small study that demonstrates the usefulness of type-specific editor services.% as compared to similar externally-available tools.

Taken together, this work aims to demonstrate that ``actively typed'' mechanisms can be introduced into many different kinds of programming systems to increase generality without the complexities of previous approaches. We approach the problem both by building up from first principles with type-theoretic models, and by developing practical designs and providing realistic contemporary examples.  
%It is precisely our type-oriented approach that makes it possible to guarantee that features introduced by extension providers will be safely composable in any combination. 
In the future, we anticipate that this work will be unified to provide foundations for an actively typed programming system organized around a minimal, well-specified and mechanically verified core, where nearly every feature is specified and implemented in a decentralized manner.% We conclude with a brief historic discussion in Sec. \ref{conclusion}.

%
%This suggests that a natural place where these features can be defined is in the library containing the declaration of \verb|Pattern| itself, rather than in the language and tool implementations. An \emph{actively-typed} definition of \verb|Pattern| would thus be equipped with	 functions that described how the parser (item 1), type checker (item 2), translator (item 3) and editor (item 4) should operate when working with expressions of type \verb|Pattern|. We can abstractly denote this declaration, as it would exist within a user-defined library, as follows:
%\begin{equation*}
%{\sf type}~Pattern[f_{\text{editor}}]\{
%\textbf{z}[f_{\text{resolve-z}}, f_{\text{compile-z}}], 
%\textbf{s}[f_{\text{resolve-s}}, f_{\text{compile-s}}], 
%\textbf{natrec}[f_{\text{resolve-rec}}, f_{\text{compile-rec}}]\}
%\end{equation*}
%
%When type checking an expression like $\nats{\nats{\natz}}$, the type checker delegates to the user-provided type-level function $f_{\text{resolve-s}}$. This function would be tasked with assigning a type to expression as a whole, given information including the \emph{types} (but not necessarily the full syntax trees) of all its subexpressions, or if a type cannot be assigned, producing a specific error message. Similarly, the compiler calls the $f_{\text{compile-s}}$ function to determine a representation in the target language for the expression, checking to ensure that it is well-formed and type-correct with respect to the target type system. Finally, elements of the editor may call into the $f_{\text{editor}}$ function (or one of several such functions, more generally) to control behaviors like code completion and code prediction when an expression of type $\nat$ is being entered. 
%
%Note that these functions are \emph{not} to be conflated with methods or run-time functions -- they are functions written in a type-level language that are called at compile-time and edit-time to define the basic behaviors associated with the type that they are associated with.
%
%\subsection{Characteristics of an Actively-Typed Programming System}
%An actively-typed programming system can be characterized by its choice of type-level language, source grammar, target language and dispatch protocols.
%
%\paragraph{Type-Level Language} The type-level language is the language within which the type definitions and the functions that define their behaviors are defined. This language must be constrained so that different definitions do not interfere with one another and so that desirable safety properties for the system as a whole are maintained, as we discuss below.
%
%\paragraph{Source Language} The source language is the language with which run-time behavior is defined. In our example above, terms like $\nats{\nats{\natz}}$ are part of the source language. In the purest case, the source language is simply a grammar; its semantics are given entirely by active type specifications.
%
%\paragraph{Dispatch Protocol} For each syntactic form in the source language, there is a dispatch protocol that determines which type is delegated responsibility over it, and which specific function(s) are called for each behavior the system supports. This fixed protocol makes it possible for users to predict the meaning of a construct using information local to the term, a key differentiator of this approach compared to term-rewriting systems where there can be action at a distance.
%
%\paragraph{Target Language} The target language is the language that the front-end compilation phase of the system targets. The limitations and constraints imposed by the target language are final, because all constructs ultimately translate into terms in the target language. In other words, active type specifications can only add additional invariants to the language; they cannot violate invariants imposed by the target language.

%\subsection{Research Challenges}
%The example of natural numbers given above is relatively simple, and the solution we outline remains abstract. A key challenge is then to demonstrate that this approach is able to express the behaviors of more sophisticated language constructs that span diverse problem domains, and be implemented in the context of a realistic collection of tools. The resulting system should be usable by developers who lack the expertise needed to define new language constructs themselves.
%
%Simultaneously, we must also demonstrate that this model is well-motivated theoretically, place it within the broader context of the theory of typed programming languages, and demonstrate that it is possible for desirable system safety properties to be maintained. In particular, we are interested in properties like:
%
%\begin{itemize}
%\item Correctness of active type specifications, so that users of a library need not be forced to debug errors arising within the specifications themselves.
%\item Correctness of translations, so that the results of translation are guaranteed to be well-typed and consistent with respect to the target language.
%\item Termination of active type specifications, so that evaluation of the type-level functions cannot cause the compiler or editor to hang.
%\item Composability of active type specifications, so that the behaviors defined by one type cannot interfere with those defined by another, no matter the order in which they are imported. This property is essential if we wish to place these specifications within normal libraries.
%\end{itemize}


