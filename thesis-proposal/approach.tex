% !TEX root = omar-thesis-proposal.tex
\section{Active Types}\label{contributions}
The mechanisms that we will introduce in this thesis are designed to be highly {expressive}, permitting library-based implementations of features comparable to built-in features found in modern programming systems, but without allowing the kinds of {safety} violations possible by previous mechanisms, such as those described above. %This is accomplished by organizing extension logic around types and scoping it to or around expressions of the type it is associated with, rather than applying it globally or within contiguous blocks as in previous mechanisms. 

To motivate the basic approach we will take in designing each mechanism to achieve these goals, let us return to the example of regular expressions. Observe that each feature described in Section \ref{regex} relates specifically to how terms representing regular expression patterns -- that is, terms classified by a single user-defined type\footnote{More generally, it may be several different types within an indexed type family. For example, \texttt{Pattern(}$n$\texttt{)}  may be the type of a pattern containing $n$ matching groups, so \texttt{Pattern} is  a type family indexed by a natural number, $n$ \cite{regex-type-system}. We will return to this distinction in Section \ref{att}.}, \verb|Pattern|\footnote{We should note at the outset that to fully prevent conflicts between libraries, naming conflicts must also be avoided. Suitable namespacing mechanisms (e.g. \cite{namespacing}) are already well-developed and will be assumed.} -- should be processed by various tools.  It is exclusively when editing or compiling expressions of type \verb|Pattern| that the logic enumerated in Section \ref{regex} would need to be invoked. 

Indeed, this is not a property unique to our chosen example, but a commonly-seen pattern. Types are already known to be a natural concept around which the semantics of programming languages and logics can be organized. For example, in both TAPL \cite{tapl} and PFPL \cite{pfpl}, most chapters simply describe the semantics and metatheory of a few new types without reference to other types. The composition of these types and associated operators into languages is a metatheoretic (in other words, language-external) notion. For example, in PFPL, the notation $\mathcal{L}$\{$\rightarrow$ \verb|nat| \verb|dyn|\} represents a language composed of the arrow ($\rightarrow$), \verb|nat| and \verb|dyn| types and their associated operators. These are defined in separate chapters, and it is  left unstated that the semantics and metatheory developed separately will compose without trouble (and indeed, almost any combination of types defined separately in PFPL can be combined in a straightforward manner). 

This type-centered organization suggests a principled language-internal alternative to the mechanisms described in Section \ref{alibs} that preserves most of their expressiveness but eliminates the possibility of conflict and makes it easier to reason locally about a piece of code: associating extension logic to a single type or type family as it is defined and scoping it only to operations on expressions in that type or type family.  We call types with such logic associated with them \emph{active types} and systems that support them \emph{actively-typed programming systems}. By constraining the extension logic itself by various means we can ensure that the system as a whole maintains important safety properties.

\subsection{Proposed Contributions}
In Section \ref{att}, we will describe how to extend the concrete static and dynamic semantics of a language in an actively-typed and safe manner. We will distill the essence of our approach, which we call \textbf{active typechecking and translation (AT\&T)}, by specifying an actively-typed lambda calculus called @$\lambda$ along with a formally definition of its compiler, proving several key safety theorems, and examining the connections between active types and several well-defined prior notions, including type-level computation, type abstraction and typed compilation. We will then go on to demonstrate the expressiveness of this mechanism by designing and implementing a full-scale language, Ace, showing how it relates to the core calculus, and implementing a number of interesting semantic constructs from existing full-scale languages as active libraries within Ace. A primary focus of this work is on high-performance computing abstractions, but we will also demonstrate how a broad variety of other primitive abstractions can coexist within Ace.

In both @$\lambda$ and Ace, user-defined semantic extensions operate over a fixed syntax. Specialized syntax that makes code more concise or readable can have a significant impact on productivity, however \cite{syntax-productivity}. Many kinds of specialized syntax extensions involve developing special ``literal'' forms for some type or family of types, including the examples of regular expression patterns, HTML and XML mentioned above. In Section \ref{aparsing}, we will show how such type-specific syntax can be introduced in an actively-typed and safely composable manner. 
Our technique is called \textbf{actively-typed parsing} and it will be implemented within the Wyvern programming language. 
%\todo{clean up Wyvern contributions} Our novel contributions include the design of a second parsing phase for processing ``TSL literals'' that runs in tandem with typechecking, a method for using whitespace to delimit domain-specific syntax, a generalization of standard literal forms so that they can be used for more than one type, a recursive use of the active parsing technique to introduce a declarative syntax for defining actively-typed grammars, and an elegant underlying general-purpose mechanism for associating compile-time data and functionality with structural types. 
We will describe several unique mechanisms, implemented in Wyvern, that ensure that syntax extensions are maximally flexible while remaining safely composable, develop minimal formal systems showing how the syntax and semantics of Wyvern supports actively-typed parsing, and examine the expressiveness of this technique for introducing novel literal forms, as well as for use cases that do not fit the conventional mold of a ``literal'' but that can nevertheless be expressed by creative application of this technique.

Finally, in Section \ref{acc}, we will show how editor-integrated domain-specific tooling for instantiating expressions of a single type can be introduced from within active libraries, by a technique known as \textbf{active code completion}. Developers associate
domain-specific user interfaces, called \emph{palettes}, with types. Users discover and invoke palettes from the code completion menu at edit-time, populated according to an actively-typed mechanism similar to that of actively-typed parsing. When they are done, the palette generates a term of that type based on the information received from the user. Using several empirical
methods, we survey\- the expressive power of this approach, describe the design and safety constraints governing
the mechanism, and develop one such system for Java\footnote{In Graphite, palettes are associated with Java classes, which serve many of the same purposes as types do in other languages. Active code completion could be implemented just as well in non-object-oriented systems.}, based on these constraints, called Graphite. Using Graphite,
we implement a palette for working with regular expressions in order to conduct a pilot study that provides evidence for the usefulness of this approach, and of contextually-invoked editor-integrated tools generally.

Taken together, these mechanisms demonstrate that actively-typed mechanisms can be introduced throughout a programming system to allow users to extend both its compile-time and edit-time semantics from within libraries, without  weakening the metatheoretic guarantees that the system provides. They also further demonstrate that types are a natural organizational unit for defining programming system semantics, because a great variety of features can be expressed in an actively-typed manner, and doing so guarantees that the features will be safely composable in any combination. In this thesis, each mechanism will be implemented within a different programming system, showing that actively-typed mechanisms are relevant across traditional paradigms, including functional languages (@$\lambda$), class-based OO languages (Graphite), structurally-typed languages (Wyvern) and scripting languages (Ace). In the future, we anticipate that mechanisms based on those in this thesis will be brought together into a single highly-extensible system with a minimal, well-specified core, where nearly every feature is distributed within a library. 

%
%This suggests that a natural place where these features can be defined is in the library containing the declaration of \verb|Pattern| itself, rather than in the language and tool implementations. An \emph{actively-typed} definition of \verb|Pattern| would thus be equipped with	 functions that described how the parser (item 1), type checker (item 2), translator (item 3) and editor (item 4) should operate when working with expressions of type \verb|Pattern|. We can abstractly denote this declaration, as it would exist within a user-defined library, as follows:
%\begin{equation*}
%{\sf type}~Pattern[f_{\text{editor}}]\{
%\textbf{z}[f_{\text{resolve-z}}, f_{\text{compile-z}}], 
%\textbf{s}[f_{\text{resolve-s}}, f_{\text{compile-s}}], 
%\textbf{natrec}[f_{\text{resolve-rec}}, f_{\text{compile-rec}}]\}
%\end{equation*}
%
%When type checking an expression like $\nats{\nats{\natz}}$, the type checker delegates to the user-provided type-level function $f_{\text{resolve-s}}$. This function would be tasked with assigning a type to expression as a whole, given information including the \emph{types} (but not necessarily the full syntax trees) of all its subexpressions, or if a type cannot be assigned, producing a specific error message. Similarly, the compiler calls the $f_{\text{compile-s}}$ function to determine a representation in the target language for the expression, checking to ensure that it is well-formed and type-correct with respect to the target type system. Finally, elements of the editor may call into the $f_{\text{editor}}$ function (or one of several such functions, more generally) to control behaviors like code completion and code prediction when an expression of type $\nat$ is being entered. 
%
%Note that these functions are \emph{not} to be conflated with methods or run-time functions -- they are functions written in a type-level language that are called at compile-time and edit-time to define the basic behaviors associated with the type that they are associated with.
%
%\subsection{Characteristics of an Actively-Typed Programming System}
%An actively-typed programming system can be characterized by its choice of type-level language, source grammar, target language and dispatch protocols.
%
%\paragraph{Type-Level Language} The type-level language is the language within which the type definitions and the functions that define their behaviors are defined. This language must be constrained so that different definitions do not interfere with one another and so that desirable safety properties for the system as a whole are maintained, as we discuss below.
%
%\paragraph{Source Language} The source language is the language with which run-time behavior is defined. In our example above, terms like $\nats{\nats{\natz}}$ are part of the source language. In the purest case, the source language is simply a grammar; its semantics are given entirely by active type specifications.
%
%\paragraph{Dispatch Protocol} For each syntactic form in the source language, there is a dispatch protocol that determines which type is delegated responsibility over it, and which specific function(s) are called for each behavior the system supports. This fixed protocol makes it possible for users to predict the meaning of a construct using information local to the term, a key differentiator of this approach compared to term-rewriting systems where there can be action at a distance.
%
%\paragraph{Target Language} The target language is the language that the front-end compilation phase of the system targets. The limitations and constraints imposed by the target language are final, because all constructs ultimately translate into terms in the target language. In other words, active type specifications can only add additional invariants to the language; they cannot violate invariants imposed by the target language.

%\subsection{Research Challenges}
%The example of natural numbers given above is relatively simple, and the solution we outline remains abstract. A key challenge is then to demonstrate that this approach is able to express the behaviors of more sophisticated language constructs that span diverse problem domains, and be implemented in the context of a realistic collection of tools. The resulting system should be usable by developers who lack the expertise needed to define new language constructs themselves.
%
%Simultaneously, we must also demonstrate that this model is well-motivated theoretically, place it within the broader context of the theory of typed programming languages, and demonstrate that it is possible for desirable system safety properties to be maintained. In particular, we are interested in properties like:
%
%\begin{itemize}
%\item Correctness of active type specifications, so that users of a library need not be forced to debug errors arising within the specifications themselves.
%\item Correctness of translations, so that the results of translation are guaranteed to be well-typed and consistent with respect to the target language.
%\item Termination of active type specifications, so that evaluation of the type-level functions cannot cause the compiler or editor to hang.
%\item Composability of active type specifications, so that the behaviors defined by one type cannot interfere with those defined by another, no matter the order in which they are imported. This property is essential if we wish to place these specifications within normal libraries.
%\end{itemize}


