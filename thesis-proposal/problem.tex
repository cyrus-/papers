\section{Introduction}\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{approaches.pdf}
\end{center}
\vspace{-20px}
\caption{\small (a) With the language-oriented approach, novel constructs are packaged into separate languages. Users can only safely and naturally call into languages consisting of common constructs. (b) With the library-oriented approach, there is one language and novel constructs are packaged as normal libraries. Thus, interoperability is not a problem but in monolithic systems, this approach is less expressive.\label{approaches}}
\end{figure}
Designing and implementing a programming language together with its supporting tools (collectively, a \emph{programming system}) that has a sound theoretical foundation, supports a natural programming style, helps users identify and fix errors as early as possible, and performs well across diverse problem domains remains a grand challenge in computing. No small, fixed collection of abstractions and associated tools that can adequately address these criteria in all situations. Instead,  researchers and domain experts regularly design and implement novel domain-specific abstractions, provide alternative implementations of existing abstractions, and supplement these implementations with a variety of edit-time, compile-time and run-time behaviors in order to better satisfy these criteria within the constraints of particular application domains.

To realize a new abstraction or behavior, researchers and domain experts must take either a \emph{language-internal approach}, where they work entirely within an existing language and distribute their solutions as libraries, or a \emph{language-external approach}, where they either construct a new, distinct system or extend an existing system by some mechanism that is not part of the language itself (such as an extension mechanism supported by a particular compiler or development environment).

When it is possible, taking a \emph{language-internal approach} (aka a \emph{library-oriented approach}), where new constructs are implemented entirely within a single host language as libraries, is a far simpler and more practical approach. % -- library-based constructs cannot interfere with one another (assuming a suitable namespacing standard), libraries benefit from common distribution infrastructure and tool support, and externally-accessible library interfaces need not be restricted to a fixed common subset of all available constructs (e.g. the object system of the JVM or CLI).  We diagram this key latter distinction in Figure \ref{approaches}. 
Of course, this is very often \emph{not} possible today because from the perspective of a library developer, the programming system is a largely inflexible, \emph{monolithic} entity. That is, the language syntax and its static and dynamic semantics are fixed in advance, the compiler is a ``black box'' implementation of these fixed semantics, and other tools operate according to domain-agnostic protocols that use only the basic structure of the program being developed as input. To enhance any of these components of the programming system, the expert must step out of the language, and often out of the programming system entirely. 

Thus, for the most sophisticated new constructs and behaviors, experts often prefer the  {language-oriented approach}, developing and distributing it together with a new programming language. The flexibility of this approach, coupled with support from tools like compiler generators and language workbenches, has led to a proliferation of specialized languages, each built around a particular set of privileged constructs. Unfortunately, a key issue limiting the practicality of this approach occurs at the boundaries between languages -- specialized constructs particular to one language cannot always be safely and naturally expressed in another, so building a program out of components written in different specialized languages can often prove difficult. 

{\color{red} (Need to reorganize this bit a little bit)} 

Although it is widely recognized that typed programming languages are well-positioned to achieve these goals, there is no small collection of types that can adequately satisfy these criteria in all cases. Instead, a large community of researchers and domain experts continue to design new domain-specific type systems and implement them in various programming systems, making trade-offs between these concerns as appropriate for the needs of the research or developer community they are targeting.


One common strategy that partially addresses this problem is to target an established language and runtime, such as the Java Virtual Machine (JVM), and support a superset of its features. This only solves the interoperability problem in one direction. While calling from the new language to the old language becomes straightforward, calls in the other direction, or between languages sharing a common target, remain restricted by the constructs available in the common language. This issue is illustrated in Figure \ref{approaches}a. This restriction can  constrain the design of new languages to only include constructs that can be expressed reasonably naturally in the target language. More novel innovations are often difficult to translate into familiar forms, however. For instance, the module system in F\# is severely constrained relative to the module system in its predecessor, OCaml, due to the need for interoperability with other CLI languages.


To put it another way, monolithic programming languages enforce a fundamental dichotomy between \emph{first-class constructs}, which enjoy support throughout the programming system but must be designed and implemented by the system designer in advance, and \emph{user-defined constructs}, which can be distributed as user libraries, but must creatively combine and repurpose the small set of available first-class constructs to express all desired run-time, compile-time and edit-time behaviors. This dichotomy has forced researchers and domain experts who want to significantly advance the state-of-the-art in programming systems, particularly in compiled, statically-typed systems where this dichotomy is most salient, to design a new language in many cases. But this then couples their core innovations with a collection of other, unrelated design choices, requires more effort both for the experts developing the innovation and its targetted user community, and leads to the intrinsic interoperability problems described above for users developing applications consisting of components written in different languages.

