\documentclass[10pt]{article}
\usepackage{stmaryrd}
\usepackage{mathpartir}
\usepackage{palatino}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage{mdwlist}
\usepackage{paralist}
\usepackage{todonotes}
%\usepackage{xypic}
\usepackage{amsmath,amssymb}
\usepackage{url}
%\usepackage{callout}L
 \usepackage{graphicx}
%\usepackage{natbib}
\usepackage{array}
%\bibpunct();A{},
%\let\cite=\citep
\usepackage{amsthm}
\usepackage{upgreek}

\newcommand{\rulename}[1]{(#1)}
\def \TirNameStyle #1{\small\rulename{#1}}
\renewcommand{\MathparLineskip}{\lineskiplimit=.3\baselineskip\lineskip=.3\baselineskip plus .2\baselineskip}

\lefthyphenmin=64

%\newcommand{\code}[1]{\texttt{#1}}
%\newcommand{\TODO}[1]{\textbf{[TODO: #1]}}
\newcommand{\cut}[1]{}

    %
    \oddsidemargin	0.5in
    \evensidemargin	0in
    \textwidth      5.5in
    \headheight     0.0in
        \headsep        0.0in
    \topmargin      0.0in
    \textheight=9.0in
    %

% Different font in captions
\newcommand{\captionfonts}{\small\bf}

%\renewcommand{\topfraction}{0.99}
%\renewcommand{\textfraction}{0.01}
%\renewcommand\floatpagefraction{0.99}

\newcommand{\minisec}[1]{\vspace{2ex}\noindent\textbf{#1}}
\newcommand{\minisecnosp}[1]{\noindent\textbf{#1}}
\newcommand{\perm}[1]{\keyw{#1}}
%\newcommand{\keyw}[1]{\texttt{\textbf{#1}}}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,frame=single,xleftmargin=15pt,escapeinside={(@}{@)}, morekeywords=[1]{atomic,state,requires,unique,immutable,shared,pure,full,none,method,val,with,match,of,syntax,for,tycase}}
\lstloadlanguages{Java,VBScript,XML,HTML}




\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\ruleT}[1] {\textsf{\sc #1}}

\usepackage{caption}
\usepackage{listings}
\lstset{
  language=Python,
%  showstringspaces=false,
  formfeed=\newpage,
  tabsize=2,
  commentstyle=\itshape,
  basicstyle=\ttfamily\fontsize{8pt}{1em}\selectfont,
  morekeywords={lambda, self, assert, as},
  numbers=none,
  captionpos=b,
%  numberstyle=\footnotesize\color{gray}\textsf,
%  xleftmargin=2em,
  stringstyle=\color{mauve},
  frame=none,
  columns=flexible,
  escapeinside={^}{^}
}
\lstdefinestyle{Bash}{
    language={}, 
    numbers=left,
    numberstyle=\scriptsize\color{light-gray}\textsf,
    moredelim=**[is][\color{blue}\bf\ttfamily]{`}{`}
}
\lstdefinestyle{OpenCL}{
	language=C++,
	morekeywords={kernel, __kernel, global, __global, size_t, get_global_id, sin}
}

\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{light-gray}{gray}{0.75}

\usepackage{float}
\floatstyle{ruled}
\newfloat{codelisting}{tp}{lop}
\floatname{codelisting}{Listing}
%\usepackage[scaled]{beramono}
\renewcommand{\ttdefault}{txtt}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{prop}{Proposition}

\usepackage{caption}
\usepackage{subcaption}
\captionsetup{compatibility=false}
\usepackage{mathrsfs}

\lstset{tabsize=2, 
basicstyle=\ttfamily\fontsize{10pt}{1em}\selectfont, 
commentstyle=\itshape\ttfamily\color{gray}, 
stringstyle=\ttfamily\color{red},
numbers=left, numberstyle=\scriptsize\color{gray}\ttfamily, language=ML,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,xleftmargin=15pt, morekeywords=[1]{tyfam,opfam,let,fn,val,def,casetype,objtype,metadata,of,*,datatype,new,toast,syntax,module,where,import,for,ana,syn,opcon,tycon,metasignature,metamodule,metasig,metamod,static,at,tycase,mod},deletekeywords={double,in},classoffset=0,belowskip=\smallskipamount,
moredelim=**[is][\color{red}]{SSTR}{ESTR},
moredelim=**[is][\color{OliveGreen}]{SHTML}{EHTML},
moredelim=**[is][\color{purple}]{SCSS}{ECSS},
moredelim=**[is][\color{brown}]{SSQL}{ESQL},
moredelim=**[is][\color{orange}]{SCOLOR}{ECOLOR},
moredelim=**[is][\color{magenta}]{SPCT}{EPCT}, 
moredelim=**[is][\color{gray}]{SNAT}{ENAT}, 
moredelim=**[is][\color{blue}]{SURL}{EURL},
moredelim=**[is][\color{SeaGreen}]{SQT}{EQT},
moredelim=**[is][\color{Periwinkle}]{SGRM}{EGRM},
moredelim=**[is][\color{YellowGreen}]{SID}{EID},
moredelim=**[is][\color{Sepia}]{SUS}{EUS},
deletestring=[d]{"}
}
\lstloadlanguages{Java,VBScript,XML,HTML}
\let\li\lstinline

\usepackage{float}
\floatstyle{ruled}
\newfloat{codelisting}{tp}{lop}
\floatname{codelisting}{Listing}
\setlength{\floatsep}{10pt}
\setlength{\textfloatsep}{10pt}
\newcommand{\lamAce}{\lambda_{\text{Ace}}}
\newcommand{\Verse}{{\text{Verse}}}

\newenvironment{proof-sketch}{\noindent{\emph{Proof Sketch.}}}{\qed}


\newtheorem{tyconinvariant}{Tycon Invariant}

\newcommand{\lstinlinep}[1]{\lstinline[language=Python,basicstyle=\ttfamily\small]{#1}}
\newcommand{\moutput}{^{\color{gray}+}}

\title{\vspace{-10px}Modularly Programmable   
Syntax \\and Type Structure (Thesis Proposal)}
\author{Cyrus Omar\\
 Computer Science Department\\
 Carnegie Mellon University\\
 comar@cs.cmu.edu}
\date{}                                           % Activate to display a given date or no date

\theoremstyle{definition}
\newtheorem{contribution}{Contribution}[section]
\input{../att-pldi15/macros-catlam}

\begin{document}
\maketitle

\begin{abstract}
%Conventional \emph{monolithic} programming systems are built around a dichotomy between \emph{built-in features}, which enjoy support from the language and tools but must be designed and implemented in advance by the system's  designers, and \emph{user-defined constructs}, which are distributed within libraries but must creatively combine or repurpose the small set of built-in features to express all desired run-time, compile-time and edit-time behaviors. This often forces researchers and domain experts who want to significantly advance the state-of-the-art in programming systems, particularly in statically-typed systems where this dichotomy is most salient, to specify and develop new or derivative languages and tools. But this then couples innovations to a collection of unrelated design decisions, requiring more effort from the experts developing the feature as well as the targeted  developer community. It also leads to a fundamental interoperability problem when building applications consisting of components written in different languages. 

%Extensible programming systems promise to avoid this problem by ... but either limited expressiveness or safety issues have plagued previous mechanisms. 
%We argue that programming language dialects should be considered harmful because there is no safe, general and natural way to interface between or combine dialects
\noindent
Functional programming languages like ML descend conceptually from minimal lambda calculi, but to be pragmatic, expose a concrete syntax and type structure to programmers of a  more elaborate design. %When new derived syntax or type structure is needed, providers have no choice but to construct new dialects of these languages. %based on simple and elegant core calculi. %Such calculi, or minor variations thereof, are often used as compiler targets. 
%, designed considering factors like perceived syntactic cost and the designer's intuitions about what idioms are likely to be common. 
Language designers have many viable choices at this level, as evidenced by the diversity of dialects that continue to proliferate  around these languages. 
But language dialects cannot be modularly combined, limiting the choices available to programmers. % (and putting pressure on these languages to adopt their ideas directly, and grow ever larger). %This has left the constructs that they house marginalized.
We propose a new functional programming language, Verse, designed to decrease the need for dialects by giving library providers the ability to safely and {modularly} express derived concrete syntax and type structure of a variety of designs atop a minimal type-theoretic internal language.% By validating the code that user-defined constructs statically generate, Verse is able to maintain a hygienic type discipline as well as strong modular reasoning principles, i.e. library providers can  reason about the constructs that they have defined in isolation and clients can use them together in any combination, without conflict.%In particular, Verse is organized around two novel meta\-programming constructs: \textbf{typed syntax macros} (TSMs) give library providers the power to express type-specific derived syntax,  and \textbf{metamodules} give them the power to express new type structure by type-directed translation to Verse's minimal \emph{typed internal language}. %Verse features a {module system} taken directly from  ML, as well as two novel metaprogramming constructs: \textbf{typed syntax macros} (TSMs) and \textbf{metamodules}. %Verse builds in very little syntax or type structure \emph{a priori}. Instead, it gives library providers metaprogrammatic control over certain aspects of parsing,  elaboration, typechecking and translation to its minimal \emph{typed internal language} (IL). 
%We show that these constructs are highly expressive, subsuming the need for many of the constructs built in to languages like ML and Scala and dialects thereof, and metatheoretically well-behaved:  % and 3) these constructs have little or no syntactic cost. % these constructs can be reasoned about separately and used together in any combination, without conflicts. %Syntactic and semantic conflicts are either impossible by construction or statically detected.
%The Verse  module system is taken directly from ML, but  the Verse core language is specified like the first stage of a type-directed compiler: as a user-facing external language (EL) given meaning by type-directed translation to a minimal typed internal language (IL). Uniquely, the Verse EL builds in very little type structure or concrete syntax \emph{a priori}. 
 %organized around a module system, taken directly from Standard ML, and two novel metaprogramming constructs, \textbf{typed syntax macros} (TSMs) and \textbf{metamodules}.  %A language ecosystem centered around Verse should spawn far fewer dialects than other contemporary language ecosystems do.

%Typed syntax macros metaprogrammatically control the parsing and elaboration of delimited segments of textual concrete syntax. This frees Verse from needing to build in derived syntax for library constructs like lists, HTML documents, regular expression patterns and quasiquotations. To maintain a typing discipline, each TSM must specify a type annotation, which Verse uses to validate all elaborations that it generates.  This annotation can abstract over types as well as modules having a specified signature, so a TSM can define  concrete syntax valid at all instances of an abstract type.

%Metamodules introduce types and operators parameterized by arbitrary {static values} and metaprogrammatically control their typechecking and translation to Verse's minimal typed internal language (IL). This gives library providers the power to express the type structure of constructs like tuples/records (and variants thereof), labeled sums, objects, regular strings, typechecked operations on format strings like \texttt{printf} and typechecked foreign function interfaces.  Just as modules can hold external types abstract to localize reasoning about representation invariants, metamodules hold internal types abstract to localize  reasoning about translation invariants.


%We will show that both metamodules and TSMs are metatheoretically well-behaved: syntactic conflicts cannot arise by construction, and the language validates the code generated statically by these constructs to maintain a hygiene discipline, a type discipline and strong modular reasoning principles. Clients are free to use metamodules and TSMs  in any combination, without worrying about syntactic or semantic conflicts. % library providers can reason about the constructs they introduce in isolation, and library clients can rely on this reasoning no matter which other constructs are simultaneously in use in a program.% also underlies modular reasoning about core language constructs defined using metamodules.. %These well-behaved constructs give library providers the power to express, and reason modularly about, new type structure and derived concrete syntax of many different designs.  


%The key novelty is in how these systems expose a  \emph{static metalanguage} (SL) to give library providers \emph{metaprogrammatic} control over parsing, elaboration, typechecking and translation. These constructs are metatheoretically very well-behaved:  and strong modular reasoning principles. Type abstraction, which is the foundation of modular reasoning about modules, is also the foundation of modular reasoning about  metamodules and TSMs. 

%Metamodules allow library providers to introduce types and operators parameterized by static values of any {kind}  and metaprogrammatically define the rules governing their typechecking and  translation to Verse's minimal typed internal language (IL). For example, This simplifies the Verse core language relative to the core languages of ML,  Scala and other comparable languages.


%

%For example, metamodules can be used to express the type structure of constructs like tuples/records, labeled sums, object systems, \emph{regular} strings, typechecked operations on format strings like \texttt{printf} and typechecked foreign function interfaces. Typed syntax macros (TSMs) allow library providers to define  derived textual syntax and associate it with a type, or a module/type-parameterized family of types, more generally. As a result, Verse does not need to build in derived syntax for constructs like lists, HTML documents, regular expressions and quasiquotations. This dramatically decreases the size of the Verse core language relative to the core languages of ML,  Scala and other comparable languages.

%The key novelty is in how these systems leverage a  \emph{static metalanguage} (SL) to give library providers \emph{metaprogrammatic} control over certain aspects of parsing, elaboration, typechecking and translation to Verse's minimal \emph{typed internal language} (IL), which itself has a completely standard semantics. 



% In particular, 

% Metamodules allow library providers to introduce types and operators parameterized by static values of any specified \emph{kind}  and metaprogrammatically define the rules governing their typechecking and  translation to Verse's minimal typed internal language (IL). For example, metamodules can be used to express the type structure of constructs like tuples/records, labeled sums, object systems, regular strings, typechecked operations on format strings like \texttt{printf} and typechecked foreign function interfaces. This simplifies the Verse core language relative to the core languages of ML,  Scala and other comparable languages.

% Typed syntax macros (TSMs) allow library providers to metaprogrammatically control the parsing and elaboration  of  delimited fragments of concrete syntax at a specified type (or more generally, a module-parameterized family of types), so Verse does not need to build in derived syntax for constructs like lists, HTML documents, regular expressions, quasiquotations or indeed any other type expressible in Verse (i.e. using metamodules, as discussed above).% TSMs can be used to introduce concrete syntax valid at all instances of an abstract type specified by a module signature. 

%Both of these constructs are well-behaved: syntactic and semantic ambiguities cannot arise by construction and the semantics validates the code that they generate to maintain a hygiene discipline, a type discipline and powerful modular reasoning principles. Type abstraction plays a fundamental role in modular reasoning with modules (as is well understood in the literature), metamodules and TSMs. 

%Finally, we introduce simple variants of these constructs that use local type inference in a novel manner to minimize the syntactic cost of using these constructs even further: \textbf{type-specific languages} (TSLs) and \textbf{metamodular type constructors}. %In particular, metamodules that declare only a single parameterized type constructor (tycon) can be organized as \textbf{metamodular tycons}. This makes certain more convenient syntactic forms available to its associated operators. Moreover, when a type is declared, one TSM can be designated as that type's \textbf{type-specific language} (TSL). Its name can be omitted in positions where the expected type is known. % The syntactic cost of using these constructs is kept low %In particular, 
%\begin{enumerate}
%\item 
% TSMs are well-behaved: syntactic conflicts cannot arise by construction and the semantics includes an elaboration validation step that maintains hygiene  and, by requiring that TSM providers provide a type annotation, a typing discipline. This annotation can be parameterized by types as well as modules. Because the Verse module system is borrowed directly from ML,  this means that TSMs can be used to define derived syntax valid for all instances of an abstract type.  

% To control the syntactic cost of invoking a TSM (controlling syntactic cost being, of course, the very purpose of TSMs), Verse can often locally infer these parameters. Moreover, when a type is declared, Verse allows the library provider to designate one TSM as its \emph{type-specific language} (TSL). Clients can then omit mention of this TSM entirely in positions where an expression of that type is expected. These mechanisms are specified by a bidirectionally typed elaboration semantics.

%\item 
% Metamodules introduce new type and operator constructors and metaprogrammatically control their typing and  translation to Verse's minimal internal language (IL), so they can be used to express the type structure of constructs tuples/records (and a number of variants thereof), labeled sums, object systems, regular strings, typechecked operations on format strings like \texttt{printf} and typechecked foreign function interfaces.%The semantics validates the code generated by these constructs according to criteria that ensure   that the language maintains important metatheoretic properties, e.g. type safety. Moreover, unlike previous such efforts, these constructs also come with strong modular reasoning principles: library providers can reason about the constructs they introduce in isolation, and library clients can rely on this reasoning no matter which other constructs are simultaneously in use in a program. Type abstraction, the fundamental technique underlying modular reasoning at the level of modules, also underlies modular reasoning about core language constructs defined using metamodules.

%\end{enumerate}

 %2) that these constructs can be reasoned about modularly and used together in any combination, without the possibility of ambiguity.% is well-behaved and can be reasoned about modularly.% important metatheoretic properties, e.g. type safety, and, critically, to guarantee that these constructs can be reasoned about separately and used together in any combination. 

% For example, record types are not built in, but they can be  expressed by defining a \emph{tycon structure} that introduces a type constructor, \texttt{record}, 
% %indexed by a finite mapping from static labels to types, 
% together with record introduction and row projection operators. The logic governing the typechecking and translation of these operators is defined using a static metalanguage where types and translations are manipulated as values. %In other words, the mapping from the external language to the internal language is governed by metaprograms written in the static language, rather than fixed \emph{a priori}.


% We propose a new programming language, Verse, that gives library providers the ability to introduce, and reason modularly about, syntactic and semantic constructs that other languages either must build in \emph{a priori} or do not support. Examples that we will touch on include list syntax, HTML syntax, regular expression pattern syntax, tuples/records, extensible tuples/records, labeled sums, object systems, operations on format strings like \texttt{printf} and typechecked foreign function interfaces. 

%More specifically, Verse introduces two novel features: \emph{typed syntax macros} and \emph{tycon structures}. Typed syntax macros allow library providers to control the parsing and elaboration of delimited segments of textual concrete syntax. Tycon structures allow library providers to introduce new type constructors and their associated operators, defining their semantics by type-directed translation to \Verse's {internal language}. %Both mechanisms constitute novel forms of {compile-time metaprogramming}.%, 

%These mechanisms integrate cleanly with {\Verse}'s module system and come equipped with modular reasoning principles of their own: library providers can prove a broad class of metatheorems about the constructs they have defined in a ``closed world'' where no other constructs need to be considered. A translation validation process ensures that all such metatheorems will necessarily continue to hold no matter which other constructs are also being used in a program, i.e. in the ``open world''. As in the module system, type abstraction plays a critical role in this process.
%Type abstraction also underlies this form of modular reasoning about core language constructs defined by these mechanisms.

% More specifically, {\Verse} is organized (like ML) into a module language and a core language (i.e. a language of types and expressions). The module language is entirely standard, but the core language is split into an external language (EL) and an internal language (IL). The EL's semantics are specified by type-directed translation to the simple IL, which has an entirely standard static and dynamic semantics. However, rather than building in a monolithic collection of external syntactic forms, types and operators, the EL is organized around  mechanisms that give library providers the ability to define new such constructs and programmatically control their semantics directly.  We demonstrate that many syntactic and semantic constructs that are, or would need to be, built into contemporary languages can be defined using these mechanisms. Moreover, unlike previous such efforts, the mechanisms we introduce come equipped with strong modular reasoning principles: library providers can reason about the constructs they introduce in isolation, and library clients can rely on this reasoning no matter which other constructs are simultaneously in use in a program. Type abstraction, the fundamental technique underlying modular reasoning at the level of modules, also underlies modular reasoning about core language constructs defined by these mechanisms.
\end{abstract}\vspace{-5px}
%\newpage

\sloppy

\begin{center}
%\large \textbf{SHF:Small: Active Types}

%\vspace{0.5cm}

%\vspace{0.5cm}

\normalsize
\end{center}

\input{problem}
\input{background}
\input{approach}
% \input{parsing}
% \input{att}
% \input{acc}
% %\input{preliminary}
% %\input{work}
% \input{timeline}
\input{conclusion}

\newpage

%% Bibliography magic
% dvips -n 15 -o description.ps description
% dvips -p=16 -o bibliography.ps description
% ps2pdf description.ps
% ps2pdf bibliography.ps
%
% OR, for pdflatex:
%
% pdftk description.pdf cat 1-15 output description1.pdf
% pdftk description.pdf cat 16-end output bibliography.pdf

\setcounter{page}{1}
\renewcommand{\thepage}{References - \arabic{page}}

\bibliographystyle{abbrv}
\bibliography{../research}
%,typestate-verification,objects,ownership,formal,dynamicweb,cloud
%\bibliographystyle{plainnat}
%\bibliography{references,dynamicweb,cloud}

\end{document}
