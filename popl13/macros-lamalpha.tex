\newcommand{\lamA}{\lambda_{\text{A}}}

\newcommand{\tvarCtx}{\Delta}
\newcommand{\iCtx}{\Theta}
\newcommand{\eCtx}{\Gamma}
\newcommand{\etvarCtx}{\overline{\Gamma}}
\newcommand{\itvarCtx}{\overline{\Sigma}}

% Generic stuff
\newcommand{\pipe}{~\text{\large $\vert$}~}
\newcommand{\splat}[3]{#1_{#2},\ldots,#1_{#3}}
\newcommand{\splatC}[3]{#1_{#2}~~~~\cdots~~~~#1_{#3}}
\newcommand{\splatTwo}[4]{#1_{#3}#2_{#3},~\ldots~, #1_{#4}#2_{#4}}
\newcommand{\substn}[2]{[#1]#2}

% \psi
\newcommand{\psiu}[1]{{\psi_{#1}}}
\newcommand{\psit}[1]{{\psi_{\text{#1}}}}
\newcommand{\psitype}{\psit{type}}
\newcommand{\psiproof}{\psit{proof}}
\newcommand{\psiidx}{\psit{idx}}
\newcommand{\psiidxn}[1]{\psit{idx,#1}}
\newcommand{\psirep}{\psit{rep}}
\newcommand{\psirepn}[1]{\psit{rep,#1}}
\newcommand{\psiden}{\psit{den}}
\newcommand{\psiIT}{\psit{IT}}
\newcommand{\psiarrow}{\psit{arrow}}
\newcommand{\psiprod}{\psit{prod}}
\newcommand{\psiint}{\psit{int}}
\newcommand{\psibool}{\psit{bool}}
\newcommand{\psiprog}{\psit{prog}}

% \delta
\newcommand{\delt}[1]{\delta_{\text{#1}}}
\newcommand{\delrep}{\delt{rep}}

% \kappa
\newcommand{\kappat}[1]{\kappa_{\text{#1}}}
\newcommand{\kappaidx}{\kappat{idx}}

% Expressions
\newcommand{\expr}[1]{{\color{red} #1}}
\newcommand{\elam}[3]{{\lam{#1}{#2}{#3}}}
\newcommand{\evar}[1]{{\textrm{#1}}}
\newcommand{\eapp}[2]{{#1~#2}}
\newcommand{\eop}[4]{{#1.\tvar{#2}\langle#3\rangle(#4)}}

% Types
\newcommand{\tdef}[3]{{\sf def}~\tvar{#1}=#2~{\sf in}~#3}
\newcommand{\tlam}[2]{\lambda[#1].#2}
\newcommand{\tvar}[1]{{\textbf{#1}}}
\newcommand{\tapp}[2]{#1(#2)}
\newcommand{\tifeq}[4]{{\sf if}~#1\equiv#2~{\sf then}~#3~{\sf else}~#4}

\newcommand{\tunit}{()}
\newcommand{\tpair}[2]{(#1, #2)}
\newcommand{\tfst}[1]{{\sf fst}~#1}
\newcommand{\tsnd}[1]{{\sf snd}~#1}

\newcommand{\fvar}[1]{\textsc{#1}}
\newcommand{\tfam}[6]{{\sf family}~\fvar{#1}[#2]~::~#3~\{#4 : #5\}~{\sf in}~#6}
\newcommand{\tfamcase}[4]{{\sf famcase}~#1~{\sf of}~\fvar{#2}~{\sf then}~#3~{\sf else}~#4}

\newcommand{\ttype}[2]{{\sf type}\in\fvar{#1}[#2]}
\newcommand{\ttypestd}{\ttype{\fvar{fam}}{\psiidx}}
\newcommand{\tidx}[1]{{\sf idx}~#1}
\newcommand{\trepof}[1]{{\sf repof}~#1}

\newcommand{\tden}[2]{\llbracket #1 \sim #2 \rrbracket}
\newcommand{\ttypeof}[1]{{\sf typeof}~#1}
\newcommand{\tvalof}[1]{{\sf valof}~#1}
\newcommand{\terr}{{\sf err}}
\newcommand{\tdencase}[4]{{\sf dencase}~#1~{\sf of}~#2~{\sf then}~#3~{\sf else}~#4}

\newcommand{\titerm}[1]{{\sf iterm}(#1)}
\newcommand{\titype}[1]{{\sf itype}(#1)}

\newcommand{\tconst}[1]{{\sf const}(#1)}
\newcommand{\tOp}[1]{{\sf op}(#1)}

\newcommand{\tprog}[1]{{\sf program}(#1)}

\newcommand{\topsempty}{\cdot}
\newcommand{\tops}[2]{\tvar{#1}=#2}
\newcommand{\topp}[2]{#1; #2}

% IL terms
\newcommand{\ivar}[1]{\textrm{#1}}
\newcommand{\ilam}[3]{\lambda #1::#2.#3}
\newcommand{\ifix}[3]{{\sf fix~}#1::#2.#3}
\newcommand{\iapp}[2]{#1~#2}
\newcommand{\ipair}[2]{(#1, #2)}
\newcommand{\ifst}[1]{{\sf fst}~#1}
\newcommand{\isnd}[1]{{\sf snd}~#1}
\newcommand{\iintlit}{n}
\newcommand{\iop}[2]{#1 + #2}
\newcommand{\iIfEq}[4]{{\sf if}~#1\equiv#2~{\sf then}~#3~{\sf else}~#4}
\newcommand{\mvalof}[1]{{\sf valof}(#1)}
\newcommand{\iup}[1]{\uparrow(#1)}

% Internal Types
\newcommand{\darrow}[2]{#1\rightarrow#2}
\newcommand{\dint}{\texttt{int}}
\newcommand{\dpair}[2]{#1\times#2}
\newcommand{\dup}[1]{\uparrow(#1)}
\newcommand{\drepof}[1]{{\sf repof}(#1)}

% Kinds
\newcommand{\kvar}[1]{\textrm{#1}}
\newcommand{\karrow}[2]{[#1]\rightarrow{#2}}
\newcommand{\kforall}[2]{\forall \kvar{#1}.#2}
\newcommand{\kunit}{\texttt{Unit}}
\newcommand{\kstr}{\texttt{Str}}
\newcommand{\kpair}[2]{#1 \times #2}
\newcommand{\klabel}[1]{\textsc{#1}}
\newcommand{\klabelOf}[2]{\klabel{#1}~{\tt of}~#2}
\newcommand{\kTypeBlur}{\texttt{Type}}
\newcommand{\kType}[1]{\texttt{Type}\in\fvar{#1}}
\newcommand{\kOp}[1]{\texttt{Op}_{#1}}
\newcommand{\kDen}{\texttt{Den}}
\newcommand{\kDenk}[1]{\texttt{Den}[\fvar{#1}]}
\newcommand{\kIdxcase}[1]{{\tt Idxcase}~#1}
\newcommand{\kIType}{\texttt{IType}}
\newcommand{\kEqProof}[3]{#1 \equiv_{#2} #3}
\newcommand{\kProg}{\texttt{Program}}
\newcommand{\kcasev}{\Omega^n}

% Arities
\newcommand{\nz}{\textbf{z}}
\newcommand{\ns}[1]{\textbf{s}(#1)}

% Cases
\newcommand{\caseZ}[2]{#1 \Rightarrow #2}
\newcommand{\caseS}[2]{#1; #2}
\newcommand{\kcaseZ}[1]{#1}
\newcommand{\kcaseS}[2]{#1; #2}

% JUdgements
\newcommand{\tof}[2]{#1 : #2}
\newcommand{\mtof}[2]{#1 :: #2}
\newcommand{\tentails}[2]{#1 \vdash #2}
\newcommand{\tentailst}[3]{\tentails{#1}{\tof{#2}{#3}}}
\newcommand{\tentailsX}[1]{\tentails{\tvarCtx}{#1}}
\newcommand{\tentailsXt}[2]{\tentailsX{\tof{#1}{#2}}}
\newcommand{\kentails}[3]{#1~#2 \vdash #3}
\newcommand{\kentailsX}[1]{\kentails{\kvarCtx}{\labelCtx}{#1}}
\newcommand{\casemap}[2]{#1 : #2}
\newcommand{\mentails}[3]{#1, #2 \vdash #3}
\newcommand{\mentailsX}[1]{\mentails{\tvarCtx}{\itvarCtx}{#1}}
\newcommand{\eentails}[3]{#1, #2 \vdash #3}
\newcommand{\eentailsX}[1]{\eentails{\tvarCtx}{\etvarCtx}{#1}}
\newcommand{\mtentails}[2]{#1 \vdash #2}
\newcommand{\mtentailsX}[1]{\mtentails{\iCtx}{#1}}
\newcommand{\mtentailsXt}[2]{\mtentails{\iCtx}{\mtof{#1}{#2}}}

% Big-Step Semantics
\newcommand{\tevals}[3]{#1 \Downarrow_{#3} #2}
\newcommand{\teval}[2]{\tevals{#1}{#2}{\Sigma}}
\newcommand{\tevalms}[3]{#1 \Downarrow_{#3} #2}
\newcommand{\tevalm}[2]{\tevalms{#1}{#2}{\Sigma}}
\newcommand{\tevales}[3]{#1 \Downarrow_{#3} #2}
\newcommand{\tevale}[2]{\tevales{#1}{#2}{\Sigma}}
\newcommand{\noprob}{\text{ok}}
\newcommand{\prob}{!}

% Verification and Translation
\newcommand{\translates}[4]{\entails{#1}{#2 \longrightarrow \tden{#3}{#4}}}

% Compilation Semantics
\newcommand{\compiless}[3]{#1 \Longrightarrow \tden{#2}{#3}}
\newcommand{\compiles}[3]{#1 \Longrightarrow \tden{#2}{#3}}
%\newcommand{\translates}[6]{\entails{#1}{\translatesTo{#2}{#3}{#4}{#5}{#6}}}
\newcommand{\translatesTo}[5]{#1 \longrightarrow \tden{#2}{\ttype{#3}{#4}{#5}{6}{7}}}
\newcommand{\translatesX}[5]{\translates{\eCtx}{#1}{#2}{#3}{#4}{#5}}
